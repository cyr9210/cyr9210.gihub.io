---
title: 예상 면접 질문
date: 2019-05-27 01:05:43
tags: Interview
---
# 면접 대비 - 예상 면접 질문

## 개발상식

### 객체지향 프로그래밍(Object Oriented Programming)
- 이전의 프로그래밍이 컴퓨터 중심이었다면, 인간 중심적 프로그래밍 패러다임이라고 할 수 있다.
- 현실세계를 프로그래밍으로 옮겨와 프로그래밍 하는것.
- 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다. 이것을 추상화라한다.

#### 장점
- 코드에 대한 재사용성이 높다.
- 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 있으므로 **버그 발생이 줄어든다.**
- 내부적으로 어떻게 동작하는지 몰라도 개발자는 라이브러리가 제공하는 기능들을 사용할 수 있기 때문에 **생산성이 높아지게 된다.**
- 객체 단위로 코드가 나눠져 작성되기 때문에 디버깅이 쉽고 **유지보수에 용이하다.**
- 데이터 모델링을 할 때 객체와 매핑하는 것이 수월하기 때문에 **요구사항을 보다 명확하게 파악하여 프로그래밍 할 수 있다.**

#### 단점
- 객체가 상태를 갖는다.
    - 변수가 존재하고, 이 변수를 통해 객체가 예측할 수 없는 상태를 갖으며, 애플리케이션에 버그를 발생시킬 수 있다.
    
#### 설계원칙
- SRP(단일 책임 원칙)
    - 클래스는 단 하나의 책임을 가져야한다.
    - 클래스를 변경하는 이유는 오직 하나의 이유여야한다.
- OCP(Open-Closed Principle)개방 폐쇠 원칙
    - 확장에는 열려있어야하고, 변경에는 닫혀 있어야한다.
- LSP(리스코프 치환 원칙)
    - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위타입을 사용하는 프로그램을 정상 동작해야한다.
- ISP(인터페이스 분리 원칙)
    - 인터페이스는 인터페이스를 사용하는 클라이언트 기준으로 분리해야한다.
- DIP(의존 역전 원칙)
    - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
<br><br>
    
### RESTfulAPI
- REST : REpresentational State Transfer
    - 분산 하이퍼미디어 시스템(예: 웹)을 위한 아키텍쳐 스타일
- API 설계 중심에 자원(Resource)이 있고, HTTP method를 통해 자원을 처리하도록 하는것.

#### 6가지 원칙
아키텍쳐는 제약조건의 집합 아래 6가지 원칙을 지켜야한다.
- **Uniform Interface**
- Stateless
- Caching
- Client-Server
- Hierarchical system
- Code on demand(optional)

http만 잘 따라도 Uniform Interface조건을 제외한 나머지 조건은 만족한다.

#### Uniform Interface의 제약조건
- identification of resource
    - 리소스가 URI로 식별되면 된다.
- mainpulation of resources through representations
    - 리소스 생성/변경/삭제 등의 일을 할때 http메세지에 표현을 담아서 전송해야한다.
- **self-descriptive**
    - 메세지는 스스로 설명해야 한다.
    - 목적지를 추가해야한다.
    - ContentType 헤드가 필요하다.
    - 해석에 필요한 명세를 넣어줘야한다.
- **hypermedia as the engine of application state(HATEOAS)**
    - 애플리케이션에 상태가 항상 Hyperlink를 이용해 전이 되어야 한다.
    - 링크정보를 포함해야 한다.(link헤더를 통해서..)

#### 장점
- 독립적 진화
    - 서버와 클라이언트가 각각 독립적으로 진화한다.
    - 서버의 기능이 변경되어도 클라이언트 업데이트가 필요없다.
- Open API를 제공하기 쉽다.
- 원하는 타입으로 데이터를 주고 받을 수 있다.
- 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

#### 단점
- 사용할 수 있는 메소드가 4가지 밖에 없다.
- 분산 환경에는 부적합하다.
- HTTP통신 모델에 대해서만 지원한다.
<br><br>

### TDD(Test-Driven Development)
- 말 그대로 테스트가 코드 작성을 주도하는 개발방식
- 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스
- 요구되는 새로운 기능에 대한 테스트 케이스를 작성하고, 통과하기위한 가장 간단한 코드를 작성한 후, 상황에 맞게 리팩토링한다.

#### 단점
-  빠른 생산성이 요구되는 시점에서 TDD 는 큰 걸림돌이 될 수 있다.
<br><br>

### MVC
![mvc](/images/interview/interview01.png)
<br>

## 자료구조
### Array VS LinkedList
#### Array
- 논리적 저장 순서와 물리적 저장순서가 일치한다.
- 인덱스로 해당 원소에 접근이 가능
- 삽입 또는 삭제시 인덱스값을 shift 해야하는 비용이 생긴다.

#### LinkedList
- 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다.
- Search과정에 있어 첫번째 원소부터 전부확인해야 한다.
- Tree구조의 근간이 되는 자료구조이다.
<br><br>

### Stack and Queue
#### Stack
- 선형 자료구조의 일종으로 Last In First Out(즉, 나중에 들어간 원소가 먼저 나온다)

#### Queue
- 선형 자료구조의 일종으로 First In First Out (FIFO)(먼저 들어간 놈이 먼저 나온다.)
- 참고로 Java Collection 에서 Queue 는 인터페이스이다.
<br><br>

### Tree
- 비선형 자료구조
- 트리는 계층적 관계를 표현하는 자료구조

#### 구성요소
- Node(노드) : 트리를 구성하고 있는 각각의 요소
- Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선
- Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드
- Terminal Node(=leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드
- internal Node(내부노드, 비단말노드) : 단말노드를 제외한 모든 노드

#### Binary Tree(이진트리)
- 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어 진다.
- 나누어진 두 서브 트리도 모두 이진트리이다.
- 트리에서 각 층별로 숫자를 매겨서 이를 트리의 level이라고 한다.(0부터 시작)
- 트리의 최고레벨을 high라고 한다.

#### Full Binary Tree(포화 이진 트리), Complete Binary Tree(완전 이진 트리)
- 모든 레벨이 꽉 찬 이진 트리를 가리켜 포화 이진 트리
- 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 완전 이진 트리
- Full Binary Tree와 Complete binary tree는 노드의 개수가 n 개 일 때, i 번째 노드에 대해서 parent(i) = i/2 , left_child(i) = 2i , right_child(i) = 2i + 1 의 index 값을 갖는다.

### BST(Binary Search Tree, 이진 탐색 트리)
- 이진 트리의 일종
-  단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다.

#### 규칙
- 노드에 저장된 키는 유일하다.
- 루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떠한 노드의 키보다 크다.
- 루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떠한 노드의 키보다 작다.
- 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다.

#### 단점
- 배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생할 수 있다.
    - Rebalancing 기법이 등장(균형을 잡기 위한 트리 구조의 재조정, 편향 트리가 될 수 있기 때문에)
<br><br>
### Binary Heap
- 자료구조의 일종 Tree형식(Complete Binary Tree)
- 배열에 트리의 값들을 넣어줄 때, 0 번째는 건너뛰고 1 번 index 부터 루트노드가 시작된다.
    - 노드의 고유번호 값과 배열의 index 를 일치시켜 혼동을 줄이기 위함
- 최대힙(max heap), 최소힙(min heap) 두 종류가 있다.
    - Max Heap이란, 각 노드의 값이 해당 children 의 값보다 크거나 같은 complete binary tree를 말한다.(Min heap 은 그 반대이다.)

#### 장점
- Max heap에서는 Root node 에 있는 값이 제일 크므로, 최대값을 찾는데 소요되는 연산의 time complexity 이 O(1)이다.
- 배열을 사용하여 효율적으로 관리할 수 있다.

#### 단점
- heap구조를 계속 유지하기 위해 제거된 노드에 대한 대체 노드가 필요하다.
    - 여기서 heap 은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다. 
    - 이런 경우에는 결국 O(log n)의 시간복잡도로 최대값 또는 최소값에 접근할 수 있게 된다.
    
## 네트워크
### GET, POST방식
- 둘 다 HTTP 프로토콜을 이용해서 서버에 무언가를 요청할 때 사용하는 방식

#### GET
- 요청하는 데이터가 HTTP Request Message의 Header 부분의 url에 담겨서 전송
- ?뒤에 데이터가 붙어 request를 보내는 것.
- url이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다.
- 보안이 필요한 데이터에 대해서는 url에 노출됨으로 부적절하다.
- SELECT적인 성향을 가지고 있다. 서버의 값이나 상태를 변경하지 않는다.
- 브라우저에서 Caching 할 수 있다.
- 기존에 Caching되었던 데이터가 응답할 가능성이 존재한다.

#### POST
- HTTP Message Body 부분에 데이터가 담겨서 전송된다.
- 데이터가 바이너리 데이터를 요청하는 경우 POST로 보내야한다.
- GET방식보다 데이터의 크기가 크고 보안면에서 낫다.
<br><br>

### TCP와 UDP 비교
