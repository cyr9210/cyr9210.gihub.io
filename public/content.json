{"pages":[{"title":"Project","text":"","link":"/project/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"About","text":"Introduce안녕하세요. 최용락입니다.좋은 Back-End 개발자가 되기위해 얻은 지식을 기록하고 있습니다. 본 블로그에서는 Java/Spring/devops를 주로 다루고 있습니다. Experience Rsupport (웹개발 1팀) : 2019.06.17 ~ 재직중 KOSTA (Web Framework 개발자 양성 과정) : 2018.10.29 ~ 2019.02.28 KOMOS (설계팀) : 2017.06.04 ~ 2018.05.31 (Steering wheel/wheel cover/wheel cap) Contact Email : jipsyer@naver.com","link":"/about/index.html"}],"posts":[{"title":"iTerm2 설치 및 커스터마이징","text":"생활코딩의 지옥에서 온 git 강의를 듣다 보면 이고잉님의 터미널이 뭔가 특별한것을 보실 수 있습니다.현재 path 및 branch 등도 표현되며 무엇보다 뭔가 있어 보였습니다.😁구글링을 통해 알아보니, macOS에서 사용하며 mac용 터미널인 iterm2를 설치한 후 여러 설치과정들을 통해 멋진 터미널을 만들 수 있다는 정보를 알게되었고.. 참고블로그 : Beomi’s Tech Blogmac을 사용하고 있고, 앞으로 터미널 이용이 더 많아질 예정이기 때문에.. 제 mac 터미널에 적용하기로 결정하였습니다.편리하고 다양하게 터미널을 사용하기위해 기본 Shell인 bash 대신에 zsh를 사용하고, 보다 깔끔하고 멋진 테마를 적용하는 방법에 대해 알아봅시다. iterm 설치 및 꾸미기iterm2 설치 iTerm2 홈페이지에서 iTerm2를 설치한다. 접근권한 설정이 필요한 경우 설정을 해준다. HomeBrew 설치하기 HomeBrew란 우분투의 APT와 비슷하게 프로그램 패키지를 관리해 주는 프로그램.brew라는 명령어로 패키지를 관리할 수 있다. HomeBrew 홈페이지 이동 해당 명령어 업력 Zsh 설치하기zsh은 bash에 추가적인 명령어를 추가하고 편의성을 개선한 새로운 쉘이다.한가지 예로 git 폴더 상태를 관리하고 터미널에 상태를 나타내준다.zsh는 위에서 설치한 HomeBrew를 통해 설치할 수 있다.1brew install zsh 상기 명령어 입력 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; oh-my-zsh 설치하기 위해 상기 명령어를 입력 oh-my-zsh는 zsh를 편리하게 사용하도록 도와주는 zsh플러그인이라고 보면된다. Oceanic Next iTerm 색 테마 입히기 Oceanic Next iTerm github 레퍼지토리 이동 후 zip파일 다운 master.zip 파일의 압축을 푼다.(상기 파일목록을 확인한다.) iterm → preference profiles → Default → Color presets… → import 상기파일 추가 후 적용 iTerm2 재시작 시, 칼라적용 Agnoster 테마 설치하기 .zshrc 파일 찾는다. (숨김파일 상태이다.) 해당 피일을 열어 위와 같이 수정한다. 터미널 재시작 시, 제대로 실행은 되지만, 일부 폰트 깨짐 Ubuntu Mono derivative Powerline 폰트 설치 &amp; 설정하기 Ubuntu Mono derivative Powerline 폰트 다운로드 다운받은 폰트를 설치한다. 칼라테마 적용고 같은방법으로 Color가 아닌 Text로 들어간다. Change Font를 선택하고 위와같이 변경한다. zsh-syntax-highlighting 설치하기 zsh-syntax-highlighting 시스템의 PATH에 등록된 명령어들을 자동으로 Syntax HighLighting 해준다. 12git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitecho &quot;source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; ${ZDOTDIR:-$HOME}/.zshrc 위 두줄의 명령어를 터미널에 입력한다. 터미널 재시작 완성","link":"/2019/03/05/Etc/iterm/"},{"title":"알고리즘, 반복 (doit-알고리즘)","text":"StudyAlgorism 알고리즘 시험을 시행하는 회사들이 많아졌습니다.시험을 대비하기 위해 매주 조금씩 알고리즘을 공부하기로 마음을 먹었습니다. 알고리즘은 아래 교재로 진행할 예정입니다. 🙂 기본알고리즘알고리즘문제를 해결하기 윈한 것으로, 명확하게 정의되고 순서가 있는 유한 개의 규칙으로 이루어진 집합 세 값의 최대값123456789101112131415161718192021222324252627public void max(){ Scanner sc = new Scanner(System.in); System.out.println(&quot;세 정수의 최대값을 구합니다.&quot;); System.out.print(&quot;a : &quot;); int a = sc.nextInt(); sc.nextLine(); System.out.print(&quot;b : &quot;); int b = sc.nextInt(); sc.nextLine(); System.out.print(&quot;c : &quot;); int c = sc.nextInt(); sc.nextLine(); int max = a; if (max &lt; b) { max = b; } if (max &lt; c) { max = c; } System.out.println(max);} 과정 max에 a값을 넣는다. b값이 max보다 크면 max에 b값을 넣는다. c값이 max보다 크면 max에 c값을 넣는다. 결과 학습내용 순차적 구조 : 위와 같이 세 문장이 아래로 나란히 있을 때, 순차적으로 실행되는 구조 선택(Selection) 구조 : ()안에 식의 평가 결과에 따라 프로그램의 실행흐름을 변경하는 if문과 같은 구조 조건 판단과 분기123456789101112public void judgeSign(){ System.out.print(&quot;정수를 입력하세요 : &quot;); int n = sc.nextInt(); if (n &gt; 0) { System.out.println(&quot;양수입니다.&quot;); } else if (n &lt; 0) { System.out.println(&quot;음수입니다.&quot;); }else{ System.out.println(&quot;0입니다.&quot;); }} 결과 순서도의 기호프로그램 순서도 데이터 : 데이터의 입력과 출력 처리 : 연산집합이나 연산군의 실행 미리 정의한 처리 : 서브루틴 및 모듈 등 다른곳에서 이미 정의한 하나 이상의 연산 또는 명령어들로 이루어진 처리 판단 : 하나의 입구와 하나 이상의 출구가 있고, 정의한 조건을 평가하여 하나의 출구를 선택하는 판단기능 루프 범위 : 루프의 시작과 종료 루프의 이름 사용(시작과 종료에 같은값) 시작 또는 종료 기호에 초깃값, 증갓값, 종룟값 표기 선 : 제어의 흐름 흐름의 방향을 분명히 나타내고자 할 때, 화살표를 붙인다. 단말 : 외부환경으로 나가거나, 들어오는것을 나타냄 ex)프로그램의 시작과 종료 반복1부터 n까지 정수의 합 구하기, 양수만 입력하123456789101112131415161718192021222324252627282930313233343536373839public void sum(){ /*무한for문 사용(while(ture)도 마찬가지 int n; for (;;){ System.out.print(&quot;n : &quot;); n = sc.nextInt(); sc.nextLine(); if(n &gt; 0){ break; }else{ System.out.println(&quot;0보다 큰 숫자를 입력해주세요.&quot;); } }*/ int n; do{ System.out.print(&quot;n : &quot;); n = sc.nextInt(); sc.nextLine(); if (n &lt;= 0) { System.out.println(&quot;0보다 큰 숫자를 입력해주세요.&quot;); } }while(n &lt;= 0); int sum = 0; for (int i = 1; i &lt;= n; i++) { sum += i; } System.out.println(n + &quot;까지 합 : &quot; + sum); } 결과 구조적 프로그래밍하나의 입구와 하나의 출구를 가진 구성 요소만을 계층적으로 배치하여 프로그래밍을 구성하는 방법 구조적 프로그래밍을 3종류의 제어흐름을 사용한다. 순차 선택 반복 논리연산과 드모르간 법칙 단푹평가 : 논리 연산의 식 전체를 평가한 결과가 왼쪽 피연산자의 평가 결과만으로 정확해지는 경우, 오른쪽 피연산자의 평가를 수행하지 않는다. 드모르간 법칙 : 각 조건을 부정하고 논리곱을 논리합으로, 논리합을 논리곱으로 바꾸고 다시 전체를 부정하면 원래의 값과 같다. 다중루프다중루프 반복안에서 다시 반복되는 등의 경우 곱셉표12345for (int i = 2; i &lt; 10; i++) { for (int j = 1; j &lt; 10; j++) { System.out.println(i + &quot; x &quot; + j + &quot; = &quot; + i*j); }} 결과 직각 이등변 삼각형 출력1234567891011121314151617 public void triangleLB(){ int n; System.out.println(&quot;왼쪽아래가 직각인 직각 삼각형 출력&quot;); do{ System.out.print(&quot;n : &quot;); n = sc.nextInt(); sc.nextLine(); }while (n &lt;= 0); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { System.out.print(&quot;*&quot;); } System.out.println(); }} 결과","link":"/2019/03/14/Algorithm/doitAl01/"},{"title":"인터넷, IP, 도메인, DNS, 포트, 포트포워딩, 절대경로, 상대경로, 유동IP, DDNS","text":"생활코딩 - 인터넷web 저는 네트워크에 대해서 http완벽가이드라는 교재로 공부할 예정이지만..그전에 AWS를 공부하기위해 선행학습으로 인터넷과 네트워크를 간단하게 정리해보려고 합니다.🙂관련강의 : 생활코딩 - 인터넷 인터넷 웹애플리케이션에 모든 사람들이 접근할 수 있도록 해주는 것이다. IP Internet Protocol Address 접근하기 위한 주소 단점 기억하기 어렵다. myip를 검색하면 자신의 ip를 알 수 있는 여러 서비스가 있다. 도메인 소유지 서버컴퓨터의 이름 하나의 IP주소를 대응하는 관계이다. 기억하기 쉽게하기 위해 도메인을 통해 서버에 접속할 수 없다. 사람이 보기 편하것일 뿐 IP주소를 통해서만 접속할 수 있다. 도메인을 구입하여 네임서버에 등록해야한다. DNS Domain Name System 도메인 네임이 동작하는 체계 동작원리 Name Server에 접속하여 해당 IP주소를 요청하고 응답받는다. 응답받은 IP주소로 접속한다. IPv6 IP는 0.0.0.0 ~ 255.255.255.255 의 주소체계를 가진다. 42억개의 IP가 만들어질 수 있다. 부족하다. 해결책이 필요하다. IPv4 기존체계 IPv6 해결책으로 엄청나게 많은 양의 IP주소 사용할 수 있는 주소체계 아직은 IPv4와 공존하고 있다. 언젠가는 사라질것… 포트 공유기 하나의 공인IP로 여러개의 컴퓨터에서 인터넷을 사용할 수 있도록 하는것 포트포워딩 웹서버가 설치되어있는 IP로 토스해준다. 공유기에서 포트포워딩 설정 (iptime기준) 192.168.0.1 접속 (대부분의 공유기가 해당 IP를 사용한다. 아닐수 있음.) 포트포워딩 설정 탭에서 토스하려는 IP주소를 입력한다. 절대경로, 상대경로 절대경로나의 위치와 무관 상대경로나의 위치에 따라서 달라짐 / 가 맨앞에 한개 있으면 최상위 디렉토리를 의미한다. ../ 는 현재 디렉토리의 상위 디렉토리 ./ 는 현재 디렉토리 (아무것도 없을때도 현재 디렉토리) 유동IP와 DDNS유동IP 오랫동안 사용하지 않은 IP를 회수 새로운 가입자 및 사용자에게 준다. 다시 사용 시, 새로운 IP부여 Dynamic Address 라고 부른다. IP가 한정적이기 때문에 고갈문제를 해결하기 위해 사용한다. DDNS Dynamic DNS(Domain Name System) 주기적으로 네임서버에 접속하여 자신의 IP주소를 알려준다. 사용자는 도메인 네임으로 접속 DDNS는 도메인과 호스트의 IP를 지속적으로 동기화 시키고 있다. iptime DDNS설정 iptime 펌웨어 버전이 9.58이상이어야 한다. 해당 PC와 연결되어 있는 공인IP가 바뀌면 도메인 이름과 동기화 시켜준다. 도메인이름은 Domain_name.iptime.org 로 설정한다. id와 pw 설정 정상등록이라고 표시되면 DDNS설정 완료 도메인을 구입하여 DDNS서비스 이용 시, 무료 서비스 : FreeDNS","link":"/2019/03/16/AWS/internet01/"},{"title":"KOSTA 예제, DFS","text":"KOSTA DAY16Algorism kosta 예제문제고전게임을 잘하기로 소문난 두 형제 종현이와 종원이는 요새 갤러그라는 게임에푹 빠져 있다.현재 종현이와 종원이의 점수는 각각 A점과 B점이고, 종현이의 점수는 A는 종원이의 점수 B보다 높거나 같다.조현이는 매주 점수가 2배씩 상승하지만, 노력파인 종원이는 종현이를 이기기 위해 쉬지 않고 연습한 결과 매일 점수가 3배씩 상승하는 능력을 갖추었다.이때 며칠이 지나야 종원이가 종현이의 점수보다 높아질 수 있을까? [입력]첫 번째 줄에 테스트케이스의 수 T(1&lt;= T&lt;=50)가 주어진다.각 테스트케이스마다 최초 종현이의 점수 A와 종원이의 점수 B가 각각 공백을 두고주어진다. 단 최초 종현이의 점수 A는 종원잉의 점수 B보다 크거나 같으면 1점이상 5천점 이하의 점수이다. (A&gt;=B, 1&lt;=B&lt;=5000) [출력]각 줄마다 “#T”(T는 테스트케이스 번호)를 출력한 뒤, 종원이의 점수가 종현이의 점수를추월하게 되는데 필요한 일수를 출력한다. [sample input] 4 7 / 1 8 / 3 4 / 4 4500 / 2 [sample output] 1 / 5 2 / 3 3 / 1 4 / 20 작성답안 DFS(깊이우선탐색) 알고리즘루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법 구현방법 순환 호출(재귀함수) 명시적인 스택 사용 BFS(너비우선탐색)보다 좀 더 간단하다. 단순검색 속도 자체는 BFS에 비해서 느리다. 모든 노드를 방문하고자 하는경우에 이방법을 선택예제 문제1번부터 N번까지 번호가 매겨져 있는 도시가 있고, 도시를 사이에 길이 있는 경우에만 이동할 수 있다.여행을 좋아하는 종민이는 M번 도시에서 출발하여 출발지를 제외한 모든 도시를 정확히 한 번씩만 방문한 후 처음 출발지인 M번 도시로 돌아오려 한다.이때 도시들 사이의 길을 지날갈 때 지불해야 하는 통행료가 있어,종민이는 최소한의 비용으로 모든 도시를 여행하고 싶다.종민이가 모든 도시를여행할 때 필요한 최소비용을 출력하는 프로그램을 작성하시오. [입력]첫 번째 줄에 테스트케이스의 수 T(1&lt;= T &lt;= 10)가 주어진다.각 테스트케이스 마다 첫 번째 줄에는 도시의 수 N과 출발지 M이 공백을 두고 주어진다.(3&lt;=N&lt;=10, 1&lt;=M&lt;=N) 다음 N개의 줄에는 각 줄에 N개의 숫자들이 공백을 두고 주어지는데 i번째 줄의 j번째 숫자는 i번째 도시에서 j번째 도시로 가는 드는통행료 MAT[i][j]를 의미한다.만약 통행료가 0인 경우는 i도시에서 j도시로 가는 길이없음을 의미하다. (0&lt;=MAT[i][j]&lt;=50) [제한조건] 도시를 잇는 도로는 일방통해이다. 심지어 i번째 도시에서 j번째 도시로 가는 길은 있어도, j번째 도시에서 i번째 도시로 가는 길은 없을 수도 있다. 모든 도시를 정확히 한 번씩만 지나야 함에 유의하라. [출력]각 줄마다 “#T(T는 테스트케이스 번호)를 출력한 뒤, 종민이가 M번 도시부터 시작하여 모든 도시를 정확히 한 번씩 순회하고 오는데 드는 통행료 최소값을 출력하시오.(단 불가능할 경우 -1을 출력한다.) [sample]33 10 1 11 0 102 20 04 30 8 13 305 0 6 206 11 0 217 7 6 05 50 17 0 3 01 0 3 4 50 5 0 2 544 10 0 0 09 3 9 7 0 [sampe output]1 132 403 30 강사님 해답못풀었다.. 강사님 작성 답안은 아래와 같다.","link":"/2018/11/20/Algorithm/kosta_algorithm/"},{"title":"블로그 명령어 정리","text":"블로그 명령어 정리hexo npm run dev (“hexo serve”) npm run deploy (“hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy”) hexo new post “게시물이름” MarkDown 인용문구 리스트 ㄴㄴ ㅇㅇ 리스트2 리스트3 순서리스트 순서리스트2 순서리스트3 링크1[네이버](naver.com) 이미지1![Java](/images/javaimage.png) 코드`(빽팁) x 3 열고닫고 강조 수평선 1&lt;img src=&quot;/images/doit_algorithm.jpg&quot; width=&quot;40%&quot;&gt;","link":"/2019/02/17/Etc/블로그-마크다운-활용/"},{"title":"Git - branch, stash","text":"Git Git branch branch는 가지라는 뜻으로 작업을 분기해서 처리하는 경우에 대한 시적인 표현입니다. git branch git branch 브랜치 조회 git branch “생성할 브랜치 이름” 브랜치가 생성된다. git branch -d &lt;브랜치이름> 브랜치 삭제 (병합된것만 가능하다.) git branch -D &lt;브랜치이름> 병합되지 않은 브랜치 강제 삭제 git checkout git checkout &lt;전환하려는 브랜치 이름> 브랜치를 전환 커밋로그 입력 시, 해당 커밋으로 체크아웃된다. git checkout -b &lt;생성하고 전환할 브랜치 이름> 브랜치를 생성하고 전환까지 할 때 브랜치 정보확인 git log : 현재 브랜치 로그 정보 조회 git log “브랜치명1”..”브랜치명2” : 브랜치 로그 비교 git log --branches : 모든 브렌치의 commit 정보를보여준다. git log --branches --decorate --graph : 모든 브렌치의 commit 관계를 그래프형태로 보여준다. git log --branches --decorate --graph --oneline: 모든 브렌치의 commit 관계를 한줄로 관계를 보여준다. merge(병합) A 브랜치로 B 브랜치를 병합할 때 (A ← B) git checkout A git merge B 반드시 A상태에서 B를 merge 해야한다. fast forward와 merge commit fast forward 빨리감기라는 뜻이다. 어떠한 새로운 커밋도 발생하지 않은 상태로 다른 브랜치의 커밋과 병합을 하게되면 가르키는 커밋의 방향만 바꿔준다. 기존의 브랜치를 지운다. 별도의 커밋을 생성하지 않는다. merge commit 두 개의 브랜치가 합쳐졌다는 정보를 가진 새로운 커밋이 발생한다. 합쳐진 두 브랜치의 정보가 담겨있다. git stash git stash 현재 작업내용을 스테이징 파일에 올리지않고 stash라는 새로운 공간에 저장한다. git status 확인 시, 변경내용 없음으로 표시된다. (변경사항들이 stash에 저장됨) git stash list 저장된 stash 조회 git stash apply 최근에 저장됬던 stash를 적용한다. 변경사항이 적용된다. stash는 삭제되지 않는다. (최근 stash가 남아있음) git stash drop 최근의 stash를 삭제한다. git stash apply; git stash drop; 동시 수행된다. git stash pop으로 대체할 수 있다. (같은역할) stash는 버전관리를 하고있는 파일에 한해서 동작한다.(즉, untracked파일은 적용 되지않는다.) 다음 git 블로깅은 github 원격저장소와 관련된 내용 및 ssh 설정 방법 .gitingore 설정까지 할 예정입니다.","link":"/2019/04/19/Git/git02/"},{"title":"Git - status, init, commit, config, log, reset, revert","text":"Git개발공부를 시작하면서.. git에대한 이야기를 참 많이 들었습니다.커밋, 푸쉬, 풀등… 알 수 없는 이야기들을 하고 나중에 그것이 git과 관련된 명령어였다는 사실을 알게되었습니다.회사에 일을 시작하기전에 알아야 할 필수적인 내용이라고 듣게되어 좀 자세히 알아보려고 합니다.git을 사용하는 방법에는 gui방식의 툴(소스트리, 크라켄)을 사용하는 방법도 있지만 보다 본질적으로 이해하고 싶어 명령어에 대해 공부하게 되었습니다. Git 명령어01Git 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템(DVCS)이다. git --version git 버전확인 git config 환경설정 git config --global --list 현재 설정정보를 조회 global 명령어는 전역설정에 대한 옵션 git config --global user.name “사용자명” 필수 원격 저장소 같도록하는것이 좋다. git config --global user.email “이메일주소” 필수 원격 저장소 같도록하는것이 좋다. git init 현재 디렉토리에 git 저장소를 생성한다. git init 명령어를 사용하면 현재 디렉토리에 .git이라는 디렉토리가 생성되며 버전관리를 시작할 수 있습니다. .git 폴더에는 버전에 대한 정보를 가지고 있다. (삭제하면 안됩니다.) git status git의 저장소는 3단계로 이루어져 있다. 작업 디렉토리 (unstaging) 인덱스 (staging) HEAD (최종 확정본 commit) HEAD는 현재 브랜치의 가장 최신커밋을 의미한다. git status 커밋되지 않은 변경사항을 조회합니다. git add 스테이징 영역에 올라간 파일만이 commit 즉, 버전등록이 가능하다. git add &lt;파일이름&gt; untracked file(버전관리를 하지않는 파일)을 버전관리 시작해주며 스테이징 영역으로 올려준다. 버전관리를 하고 있으나 스테이징영역에 올라기지 않은 파일을 스테이징 영역으로 올려준다. git add . untracked 및 unstaged 파일을 모두 add 한다. git add -i 대화식으로 추가 가능하다. git commit 버전을 만드는 작업 git commit 버전이름을 정의하여 현재 staging된 파일들을 버전으로 등록한다. i 입력 후 메세지 입력 메세지 입력 완료후 esc :wq 로 쓰고 나가기(write, quit) git commit -m “&lt;커밋메세지&gt;” 커밋메세지와 함께 명령할 수 있다. git commit -C HEAD -a --amend 최근 커밋을 덮어쓴다. HEAD를 commit 로그로 변경하면 해당 commit의 메세지로 커밋이 덮어써진다. -c 사용 시, 커멧메세지를 변경 할 수 있다. git diff 사전 조건(test03.txt) git diff 스테이징 영역과 작업 디렉토리의 차이정을 알려준다. git diff -cached 스테이징 영역과 저장소 git diff HEAD 작업디렉토리, 스테이징영역, 저장소 모두 볼 수 있다. git log git log 커밋로그 조회 -1, -2 등을 붙여 조회로그 갯수를 지정할 수 있다. -p 옵션을 주면 변경사항도 같이 조회된다. --decorate --graph 옵션을 주면 브랜치 트리를 볼 수 있다. git blame 갈 줄 앞에 커밋명과 커밋한 사람등의 정보를 볼 수 있습니다. reset 과 revert git reset 과거 버전으로 돌아가기 --hard : 돌아가려는 이력이후의 모든 내용을 지운다. --soft : 돌아가려 했던 이력으로 되돌아 갔지만, 이후의 내용이 지워지지 않고, 해당 내용의 인덱스(또는 스테이지)도 그대로 --mixed : 역시 이력은 되돌려집니다. 이후에 변경된 내용에 대해서는 남아있지만, 인덱스는 초기화 됩니다. git revert 기존의 커밋에서 변경한 내용을 취소해서 새로운 커밋을 만듭니다. 차이점 : https://www.popit.kr/%EA%B0%9C%EB%B0%9C%EB%B0%94%EB%B3%B4%EB%93%A4-git-back-to-the-future/ 다음 블로깅에서는 branch와 관련된 내용에 관하여 정리하겠습니다.","link":"/2019/04/19/Git/git01/"},{"title":"Git - merge, rebase","text":"Git merge 브랜치를 병합한다. 3wayMerge를 통해 병렬로 병합한다. fast forward 자동 병합이 가능한 상태 커밋까지 해준다. conflict 자동병합이 안되고 충돌이 난 상태 git status를 통해 충돌 파일을 확인하고 직접 수정해주고 커밋해주어야 한다. 명령어 합쳐질 대상에서 명령어 입력 git merge 대상 rebase 브랜치 병합방법중 하나이다. merge와 차이점 장점 병렬로 저장되는 merge와 다르게 일렬로 저장되어 history를 보다 정확하게 확인할 수 있다. 단점 어렵고 위험하다. 주의사항 다른사람과 공유하지 않은 커밋에 대해서만 해야한다. (git pull 하고나서 하지 말 것.) 명령어 git rebase 대상 git rebase –abort : rebase 중단 git rebase –continue : 진행 대상이없으면 중단 git rebase –skip : 해당 커밋을 rebase 하지 않고 반영하지 않는다.","link":"/2019/05/29/Git/git04/"},{"title":"Git - 원격저장소(Github), gitignore설정, ssh설정","text":"Git Github github은 git이라는 버전관리시스템에 저장소를 빌려주는 호스팅 사이트이다. 호스팅 사이트로는 github외에도 GitLab, BitBucket등이 있다. 원격저장소 git clone &lt;주소(https/ssh)&gt; 현재 디렉토리(local)에 github의 소스코드를 가져온다. git fetch 원격저장소의 변경사항을 가져와서 원격 브랜치를 갱신한다. git pull fetch와 master에 자동으로 merge가된다. git push 로컬의 변경내용을 원격저장소에 업데이트한다. tag를 달았을 경우, 기본적으로 푸싱하지 않기 때문에 아래와 같이 사용해야한다. git push origin &lt;태그명&gt; git push origin –tags git remote 원격저장소 목록 조회 git remote add &lt;이름&gt; 저장주소 지역저장소(local)에 원격 저장소를 추가한다.(연결) 기본적으로 origin이라는 이름을 대부분 사용한다. gitignore git에서 버전관리하지 않는것을 원할 때, .gitignore로 설정 할 수 있다. gitignore파일 생성 touch .gitignore gitignore 설정 .gitignore파일안에 해야할 설정을 모를 때, 아래 사이트를 통해서 쉽게 설정 할 수 있다. http://www.gitignore.io 사용하는 언어, IDE등을 입력한다. 만들어준 내용을 .gitignore파일에 입력한다. 이미 github 파일을 올렸을 경우, 아래와같은 설정을 해줘야한다. 전체 캐쉬 내용 삭제 git rm -r --cached . 다시 전체 내용 업로드 git add . git commit -m “커밋메세지” git push origin &lt;branch> SecureShell 터미널에서 ssh 를 생성한다. ssh-keygen 다른 컴퓨터로 접속할 수 있는 비밀번호가 생긴다. 기계적으로 굉장히 복잡한 비밀번호로 뚫을 수 없다. ~/.ssh 디렉토리에 생성된다.(숨김) id_rsa private key id_rsa.pub public key 접속하고자 하는 컴퓨터에 public key를 옮겨주어야한다. github 사이트에서 settings → SSH Keys → New SSH Key → id_rsa.pub 안의 내용을 넣어준다. ssh 로 접속할 수 있게된다. 처음 접속시 ssh로 접속하겠냐는 질문에대해 yes를 입력해주어야한다. github이 아니고 다른 컴퓨터에 접속할때도 사용할 수 있다. 그때는 원격으로 비밀번호로 접속후에 .ssh디렉토리에 위치한다. id_rsa.pub를 복사한다. scp &lt;id_rsa.pub위치> id@&lt;접속주소>:복사위치ex) scp $HOME/.ssh/id_rsa.pub egoing@egoing.net:id_rsa.pub id_rsa.pub 키를 authorized_keys에 등록한다. cat 위치/id_rsa_pub &gt;&gt; 위치/authorized_keysex) cat $HOME/id_rsa.pub &gt;&gt; $HOME/.ssh/authorized_keys 여기서 &gt;&gt; 는 뒤에 붙여넣는것이다.(append) >는 덮어쓰기가된다. ssh 접속하기 ssh &lt;주소>ex) ssh egoing.net id_rsa 파일을 $HOME/.ssh/id_rsa에 만들지 않고 다른 디렉토리에 만들었다면 -i 옵션을 사용 ssh -i &lt;파일위치> &lt;주소>ex) ssh -i $HOME/auth egoing.net debug모드로 접속하기 위해서는 -v옵션을 줄수있다. (좀 더 자세한 내용을 원할때는 -vv, -vvv까지 가능 )ex) ssh -v egoing.net 참고 강좌 : https://opentutorials.org/module/432/3742","link":"/2019/04/19/Git/git03/"},{"title":"Git/GitHub 입문 (oss개발자포럼 세미나)","text":"Git/GitHub 입문 (oss개발자포럼 세미나)Git 버젼관리 시스템인 Git에 대하여 생활코딩 ‘지옥에서 온 git’을 수강하며, 공부를 하던중…oss개발자 포럼 커뮤니티와 국민대학교가 주관하는 ‘Git과 Github을 이용한 버전관리 입문’이라는 주제로 강연을 진행하단다는 정보를 알게되었습니다.해당 커뮤니티에 대한 궁금함과 동시에 오프라인으로 강의를 들어보는게 나쁘지 않을것 같아서 신청하게 되었습니다.🙂 형상 관리와 버전 관리형상 관리소프트웨어의 변경사항을 체계적으로 추적하고 관리, 통제하는 것 관리대상 요구사항 명세서 설계서 소스코드 이미지 라이브러리 파일 프로젝트 회의록 그외많은관리대상들 형상관리를 왜 해야할까? 소프트웨어 개발 생산성을 향상시켜 준다 (요구사항을 바탕으로 개발을 진행하므로) 소프트웨어의 품질을 향상시켜 준다 (문제가 있는 경우를 쉽게 발견할 수 있으므로) 유지보수 비용을 절감시켜 준다 버전 관리 시스템소스코드의 변경사항을 체계적으로 추적하고 관리, 통제하는 시스템 버전 관리 시스템 - VCS(Version Control System) 로컬에서 직접 모든 자원을 관리 USB, 메일 첨부파일 집중형 버전 관리 시스템 - CVCS(Centralized VCS) 하나의서버를두고서버를중심으로모든자원을관리 SVN - https://subversion.apache.org/ 분산형 버전 관리 시스템 - DVCS(Distributed VCS) CVCS처럼 서버를 두고 서버에서 자원 관리를 하지만 로컬에서도 자원 관리를 함 Git - https://github.com/git/git Git / Github Git : 버전관리 시스템 Github : Git 호스팅 사이트 호스팅 : 웹의 공간을 빌려주거나 빌리는것 Git Hosting GitHub ( https://github.com/ ) GitLab ( https://gitlab.com ) BitBucket ( https://bitbucket.org )Git Client Git bash Git을 설치하면 기본제공되는 CLI 기반 Git Client Windows / Mac / LinuxSourceTree https://www.sourcetreeapp.com/ Windows / MacGitKraken https://www.gitkraken.com/ - Windows / Mac / Linux Git을 이용한 버전 관리 버전관리 ⊂ 형상관리 Git은 분산형 버전 관리 시스템(DVCS) Git ≠ GitHub GitHub는 Git Hosting 웹 서비스 버전관리를 어떻게할까? CVCS DVCS Git(DVCS) Git의 흐름(workflow) GitHub 둘러보기 fork : 다른사람의 프로젝트를 복제 Pull Request : 자신이 변경한 코드를 상대방의 리포지토리에 넣고 싶을 때 사용하는 기능 git Lab에서는 merge request라고 부른다. Pull Request에도 순서가 있다. git fetch : 리포지토리에서 변경된 기록을 가져오되 merge는 하지 않음 git pull : 리포지토리에서 변경된 기록을 가져오고 merge도 바로 이루어짐 알아두면 좋은것 생활코딩 지옥에서 온 Git 동네개발자형 교육방송 - git bisect 여러 프로젝트, 소식 살펴보기 : gitexplore 오픈소스 fork시, 라이센스에 주의해야한다.참고자료 : https://www.slideshare.net/ssuser22e7fc/gdg-campus-korea-2-132342619 gitignore 적용하기 gitignore.io 참고하면 도움이 될 책 소프트웨어 개발의 모든 것 성공으로 이끄는 팀 개발 실천 기술 팀을 위한 git 명령어 git 사용자 정보 조회 git config –global –list 이전에 git을 사용한 적이 있다면 사용자 정보를 지워줍니다. git config –global –unset-all user.name git config –global –unset-all user.email 강의는 매우 만족스럽지 못했습니다..발표자는 20분이 넘는 시간을 지각하고, wifi접속은 안되고, 강의내용은 기존 공지내용과 달랐습니다.bash기반의 명령어 및 구동원리 강의를 기대하고 왔는데..해당 강연은 git 크라켄을 사용하는 gui방식의 툴을 기반으로 하고 있었으며, git에대해 전혀 알지못하는 사람을 대상으로 하는 수준이었기 때문에 제가원하는 강연은 아니었던것 같습니다.분명 강의내용에 명령어 강의라고 되어있어서 신청했는데..😂git을 처음접하시는 분들에게는 어땠을지 모르겠지만 제게는 많이 아쉬웠던 강의였습니다.","link":"/2019/03/23/Git/oss-git-github/"},{"title":"ORM01 - JPA 소개","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편JPA 소개 SQL 중심적인 개발의 문제점 무한반복, 지루한 코드 CRUD INSERT INTO… UPDATE… SELECT… DELETE… 필드 추가 시, 각 쿼리마다 수정이 필요하다. 휴먼 에러가 발생하기 쉽다. 관계형 DB사용함에 있어서는 SQL에 의존적인 개발을 피하기 어렵다. 패러다임 불일치 객체와 관계형 데이터 베이스의 차이 상속 연관관계 데이터 타입 데이터 식별방법 처음 실행하는 SQL에 따라 탐색 범위가 결정 엔티티 신뢰 문제 Query를 확인하기 전까지는 엔티티를 신뢰할 수 없다. 계층 분할이 어렵다. 객체 비교의 결과가 다르다. 객체지향적으로 설계를 하면 할수록 매핑 작업만 늘어난다. 객체를 자바 컬렉션에 저장하듯이 DB에 저장할 수는 없을까? -&gt; JPA JPA 소개 Java Persistence API 자바 진영의 ORM 기술 표준 ORM Object Relational Mapping 객체 관계 매핑 객체는 객체대로 설계 관계형 데이터베이스는 관계형 데이터베이스대로 설계 ORM 프레임워크가 주간에서 매핑 대중적인 언어는 대부분 ORM 기술이 존재 JPA는 애플리케이션과 JDBC 사이에서 동작 개발자 직접 JDBC API를 사용하는것이 아니고 JPA에 명령을 하면 JPA가 JDBC API를 사용해서 SQL을 호출하고 결과를 받아서 동작한다. JPA 동작 - 저장 적절한 query를 생성한다. (개발자가 만드는것이 아니고 만들어준다.) JPA 동작 - 조회 JPA 역사 과거에는 EJB(엔티티 빈)이 있었다. 자바표준으로 사용되었다. 그러나, 아마추어적인 기술… (속도 느림, 성능 떨어짐 등..) ‘개빈 킹’이라는 개발자가 ORM 프레임워크 하이버네이트를 개발여러 개발자들의 동참하여 오픈소스화가 되었다. 자바 진영에서 ‘개빈킹’을 스카웃 하이버네이트를 기반으로 자바 표준 JPA를 만들었다.(거의 유사하다. 다듬고.. 용어정리.. ) JPA는 표준 명세 JPA는 인터페이스의 모음 3가지 구현체가 있다. 하이버네이트 우리가 사용하는 JPA의 80~90퍼 구현체 EclipseLink DataNucleus JPA를 왜 사용해야 하는가? SQL 중심적인 개발에서 객체 중심으로 개발 생산성 저장 : jpa.persist(member); 조회 : Member member = jpa.find(memberId); 수정 : member.setName(“update_name”); 삭제 : jpa.remove(member); 유지보수 기존 : 필드 변경 시, 모든 SQL 수정 JPA 사용 : 필드만 추가하면 된다. 패러다임 불일치 해결 JPA와 상속 JPA와 연관관계 JPA와 객체 그래프 탐색 JPA와 비교하기 JPA의 성능 최적화 기능 1차 캐시와 동일성(identity) 보장 같은 트랜잭션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상 여러번 조회해도 같은 SQL을 여러번 실행하지 않는다. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) 트랜잭션을 커밋할 때까지 INSERT SQL을 모음 JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송 JDBC BATCH : query를 모아서 한번에 날려준다. 이 과정이 코드가 굉장히 지저분해진다. JPA는 옵션설정하나로 이 작업을 해준다. 지연 로딩(Lazy Loading) 지연로딩 : 객체가 실제 사용될 때 로딩 즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회 두 로딩을 로직에 맞게 옵션을 설정하여 효과적으로 SQL을 호출한다. 데이터 접근 추상화와 벤더 독립성 표준","link":"/2019/10/04/JPA/ORM-JPA01/"},{"title":"ORM04 - 엔티티 매핑(객체와 테이블 매핑(@Table), 데이터베이스 스키마 자동생성, 필드와 컬럼 매핑(@Column), 기본 키 매핑(@Id, @GenerateValue))","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편엔티티 매핑 객체와 테이블 매핑@Entity JPA가 관리, 엔티티라고 한다. 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) final, enum, interface, inner 클래스 사옹불가 저장할 필드에 final 사용 불가 @Entity 속성 정리 name 기본값은 클래스의 이름 JPA에서 사용할 엔티티 이름을 지정 같은 클래스 이름이 없으면 가급적 기본값을 사용하는것을 추천한다. @Table 엔티티와 매핑할 테이블 지정 name 매핑할 테이블 이름 기본값은 엔티티 이름을 사용 catalog 데이터베이스 catalog 매핑 schema 데이터베이스 schema 매핑 uniqueConstraints DDL생성 시에 유니크 제약 조건 생성 데이터베이스 스키마 자동 생성 DDL을 애플리케이션 실행 시점에 자동 생성 테이블 중심 -&gt; 객체 중심 데이터베이스 방언을 활용하여 데이터베이스에 맞는 적절한 DDL 생성 이렇게 생성한 DDL은 개발 장비에서만 사용 생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용 hibernate.hbm2ddl.auto 설정 create : 기존 테이블 삭제 후 다시 생성 (DROP + CREATE) create-drop : create와 같으나 종료시점에 테이블 DROP update : 변경된 부분만 반영(운영 DB에는 사용하면 안됨) 기존에 있던 컬럼이 지워지는 경우는 아무런 일이 일어나지 않는다. validate : 엔티티와 테이블이 정상 매핑 되었는지만 확인 none : 사용하지 않음 사실 없음 매칭되는게 없으나 관례적으로 none이라고 적는다. 주의 운영 장비에서는 절대 create, create-drop, update는 사용하면 안된다. 개발 초기 단계는 create or update 테스트 서버 update or validate 스테이징, 운영서버는 validate or none DDL 생성 기능 제약조건 추가 @Column(nullable = false, length = 10) 유니크 제약조건 추가 @Table(uniqueConstraints = {@UniqueContstranin(name = &quot;NAME_AGE_UNIQUE&quot;, columnNames = {&quot;NAME&quot;, &quot;AGE&quot; })}) DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고, JPA의 실행 로직에는 영향을 주지 않는다. 필드와 컬럼 매핑 어노테이션 설명 @Column 컬럼매핑 @Temporal 날짜 타입 매핑 @Enumerated enum 타입 매핑 @Lob BLOB, CLOB 매핑 @Transient 특정 필드를 컬럼에 매핑하지 않음(매핑 무시) @Column 속성 설명 기본값 name 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름 insertable, updatable 등록, 변경 가능여부 TRUE nullalbe(DDL) null값 허용여부. false로 설정 시 DDL 생성할 때 not null 제약 조건이 붙는다. unique(DDL) @Table의 uniqueConstraints와 같지만 한 컬럼에 간단한 유니크 제약조건을 줄 때 사용한다. 255 length(DDL) 문자 길이 제약조건, String 타입에만 사용한다. 255 precision, scale(DDL) BigDecimal 타입에서 사용한다.(BigInteger도 사용할 수있다.)prevision은 소수점을 포함한 전체 자릿수sacle은 소수의 자릿수double, float타입에는 적용되지 않는다.아주 큰 숫자나 정밀한 소수를 다룰때 사용. precision = 19sclae = 2 unique의 경우, Constraints 이름은 줄 수 없다. Constarints 이름을 주고 싶다면 @Table(uniqueConstraints)를 사용하자. @Enumerated 자바 enum 타입을 매핑할 때 사용 ORDINAL 사용 X 추가 되거나, 수정 발생 시에 문제가 발생될 수 있다. 속성 설명 기본값 value EnumType.ORDINAL : enum 순서를 데이터 베이스에 저장EnumType.STRING : enum 이름을 데이터 베이스에 저장 Enumtype. ORDINAL @Temporal 날짜 타입을 매핑할 때 사용 자바8에 LocalDateTime, LocalDate 가 생겼기 때문에, 최근에는 거의 사용하지 않는다. 최신 하이버네이트 버전에서 지원하고 있다. @Lob 데이터베이스 BLOB, CLOB 타입과 매핑 지정할 수 있는 속성이 없다. 매핑하는 필드 타입이 문자면 CLOB, 나머지는 BLOB 매핑 CLOB : String, char[], java.sql.CLOB BLOB : byte[], java.sql.BLOB CLOB 사이즈가 큰 데이터를 외부 파일로 저장하기 위한 데이터 타입 a문자열 데이터를 DB외부에 저장하기 위한 타입이다. 데이터의 최대 길이는 외부 저장소에서 생성 가능한 파일 크기이다. SQL문에서 문자열 타입으로 입출력 값을 표현한다. CHAR, VARCHAR, NCHAR, NCHAR VARYING 타입과 호환 명시적 타입 변환만 허용 데이터 길이가 서로 다른 경우 최대 길이가 작은 타입에 맞추어 절삭된다. BLOB 바이너리 데이터를 DB외부에 저장하기 위한 타입이다. BLOB 데이ㅓㅌ의 최대 길이는 외부 저장소에서 생서 가능한 파일크기이다. SQL문에서 비트열 타입으로 입출력 값을 표현한다. BIT, BIT VARYING 타입과 호환 명시적 타입 변환만 허용 데이터 길이가 서로 다른 경우 최대 길이가 작은 타입에 맞추어 절삭된다. BLOB타입값을 바이너리 값으로 변환하는 경우, 변환된 데이터는 초대 1GB를 넘을 수 없다. 반대로 바이너리를 BLOB타입으로 변환하는 경우, 변환된 데이터는 BLOB저장소에서 제공하는 파일 크기를 넘을 수 없다. 기본 키 매핑 직접 할 : @Id만 사용 자동생성 : @GenerateValue IDENTITY 데이터베이스에 위임, (MYSQL의 AUTO_INCREMENT) SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용, ORACLE @SequenceGenerator 필요 TABLE : 키생성용 테이블 사용, 모든 DB에서 사용 @TableGenerator 필요 AUTO : 방언에 따라 자동 지정, 현재 기본값 예를 들어 오라클이면 sequence 생성… 변경사항이 있을 수 있으니 확인하고 사용하는 것을 추천. IDENTITY 전략123@Id@GeneratedValue(strategy = GenerationType.IDENTITY)private String id; 기본 키생성을 데이터 베이스에 위임 주로 MY_SQL, PostgreSQL, SQL server, DB2에서 사용 JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행 AUTO_INCREMENT는 데이터 베이스에 INSERT SQL을 실행 한 이후에 ID값을 알 수 있음 IDENTITY 전략은 em.persist(entity); 시점에 즉시 INSERT SQL 실행하고 DB에서 식별자 조회 DB에 아이디값이 null로 날라왔을 때, DB가 ID를 생성한다. 생성한 ID값을 리턴받아서 영속성 컨텍스트에 넣어준다. SEQUENCE 전략123@Id@GeneratedValue(strategy = GenerationType.SEQUENCE)private Long id; 숫자 타입 사용해야한다. Integer를 쓴다고 해서 성능적 차이는 미비하다. Long을 쓰자. Sequence를 DB에 요청해서 먼저 받고 영속성 컨텍스트에 저장 -&gt; 트랜잭션 commit 시점에 쿼리를 호출 DB와 너무 많은 커넥션을 맺는것 아닌가..? 성능에 문제가 있지 않나? allocationSize만큼 DB의 시퀀스값으 올려두고 하나씩 사용한다. (밑에 예는 allocationSize = 2) 첫번째 시퀀스 1을 더미처럼 호출한 후, 시퀀스를 2증가시킨 3까지 증가시키는 콜을 한다. (사용값 : 1, DB 시퀀스 현재값 : 3) 2번째 엔티티를 persist할 때, 미리 증가시켰던 시퀀스 범위 안으로 시퀀스 2를 사용한다. (사용값 : 2, DB 시퀀스 현재값 : 3) 3번째 엔티티를 persist할 때, 미리 증가시켰던 시퀀스 범위 안으로 시퀀스 3를 사용한다. (사용값 : 3, DB 시퀀스 현재값 : 3) 4번째 엔티티를 persist할 때, 시퀀스를 2증가 시키는 콜을한다. (사용값 : 4, DB 시퀀스 현재값 : 5) 여러 WAS가 있어도 동시성 문제없이 다양한 문제를 해결해준다. Table마다 Sequence를 가지고 시픙면 설정을 해주면 된다. 123456789101112@Entity@SequenceGenerator( name = \"MEMBER_SEQ_GENERATOR\", sequenceName = \"MEMBER_SEQ\", initialValue = 1, allocationSize = 1)public class Member { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"MEMBER_SEQ\") private Long id; @SequenceGenerator 속성 속성 설명 기본값 name 코드에서 사용할 이름 필수 sequenceName 데이터베이스에 매핑할 시퀀스 이름 hibernate_sequence initialValue 초기값 1 allocationSize 증가값 50 catalog, schema 데이터베이스 catalog, schema 이름 TABLE 전략12345678910@Entity@TableGenerator( name = \"MEMBER_SEQ_GENERATOR\", table = \"MY_SEQUENCES\", pkColumnName = \"MEMBER_SEQ\", allocationSize = 1)public class Member { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"MEMBER_SEQ_GENERATOR\") private Long id; 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략 @TableGenerator가 필요 장점 : 모든 데이터베이스에 적용 가능 단점 : 성능; pikColumName 컬럼 이름 @TableGenerator 속성 속성 설명 기본값 name 식별자 생성기 이름 필수 table 키생성 테이블명 hibernate_sequences pkColumnName 시퀀스 컬럼명 sequence_name valueColumnNa 시퀀스 값 컬럼명 next_val pkColumnValue 키로 사용할 값 이름 엔티티 이름 initialValue 초기 값, 마지막으로 생성된 값이 기준이다. 0 allocationSize 증가값(sequence전략과 동일) 50 catalog, schema 데이터베이스 catalog, schema 이름 uniqueConstraints(DDL) 유니크 제약조건 권장하는 식별자 전략 기본 키 제약 조건 null 아님 유일 변하면 안된다. 미래까지 이 조건을 만족하는 자연키(주민등록번호, 전호번호 등)는 찾기 어렵다.비지니스와 상관없는 대리키를 사용하자. 권장 : Long형 + 대체키 + 키 생성전략 사용","link":"/2019/10/11/JPA/ORM-JPA04/"},{"title":"ORM02 - JPA 시작하기(프로젝트 생성, 애플리케이션 개발)","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편JPA 시작하기 프로젝트 생성H2 데이터베이스 최고의 실습용 DB 가볍다 웹용 쿼리를 제공 MySQL, Oracle 데이터베이스 시뮬레이션 기능 sequence, Auto Increment 기능 지원 H2 데이터베이스 설치와 실행 http://www.h2database.com/ OS에 맞게 다운로드 및 압축해제 윈도우 외 : All Platforms 다운 압축해제위치/h2/bin/h2.sh 실행(mac의 경우) 프로젝트 생성 자바8 메이븐 groupId : jpa-basic artifactId : ex1-helo-jpa version : 1.0.0 라이브러리 추가 - pom.xml1234567891011121314&lt;dependencies&gt; &lt;!-- JPA 하이버네이트 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;5.3.10.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- H2 데이터베이스 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.199&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; JPA는 인터페이스의 모음이며 구현체로 하이버네이트를 선택했다. hibernate 라이브러리가 jpa 인터페이스를 가지고 있다. h2 DB 버전을 맞추는게 좋다. JPA 설정하기 - persistence.xml JPA 설정파일 위치는 반드시 /META-INF/persistence.xml persistence-unit_name으로 이름지정 가능 javax.persistence로 시작 : JPA 표준 속성 hibernate가 아닌 다른 구현체를 사용하여도 같은 설정이 가능 hibernate로 시작 : 하이버네이트 전용 속성 스프링 부트의 경우 properties or yml 파일로 설정이 가능하다. 설정파일 예시 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persistence version=\"2.2\" xmlns=\"http://xmlns.jcp.org/xml/ns/persistence\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd\"&gt; &lt;persistence-unit name=\"hello\"&gt; &lt;properties&gt; &lt;!-- 필수 속성 --&gt; &lt;property name=\"javax.persistence.jdbc.driver\" value=\"org.h2.Driver\"/&gt; &lt;property name=\"javax.persistence.jdbc.user\" value=\"sa\"/&gt; &lt;property name=\"javax.persistence.jdbc.password\" value=\"\"/&gt; &lt;property name=\"javax.persistence.jdbc.url\" value=\"jdbc:h2:tcp://localhost/~/test\"/&gt; &lt;property name=\"hibernate.dialect\" value=\"org.hibernate.dialect.H2Dialect\"/&gt; &lt;!-- 옵션 --&gt; &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt; &lt;property name=\"hibernate.format_sql\" value=\"true\"/&gt; &lt;property name=\"hibernate.use_sql_comments\" value=\"true\"/&gt; &lt;!--&lt;property name=\"hibernate.hbm2ddl.auto\" value=\"create\" /&gt;--&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; javax.persistence.jdbc.driver : DB 드라이버 javax.persistence.jdbc.user : DB id javax.persistence.jdbc.password : DB password javax.persistence.jdbc.url : DB 위치 hibernate.dialect : 데이터 베이스 방언 설정 hibernate는 특정 데이터베이스에 종속적이지 않다. 각 DB별 방언을 설정하여 일정한 결과를 나올 수 있도록한다. hibernate는 40가지 이상의 데이터베이스 방언을 지원한다. 애플리케이션 개발JPA 구동방식 META-INF/persistence.xml에서 설정 정보를 확인 확인한 정보로 EntityManagerFactory를 생성 필요할 때마다 EntityManger를 생성한다. EntityManagerFactory는 애플리케이션 로딩시점에 한번만 생성해준다. 한 트랜잭션에 대한 DB커넥션을 위해서는 EntityManager를 만든다. EntityManger는 쓰레드간 절대 공유하지 않는다.(사용 후 버림.) JPA의 모든 데이터 변경은 트랜잭션 안에서 실행 객체와 테이블을 생성하고 매핑하기 h2 DB에 객체에 해당하는 테이블 생성 쿼리를 날린다. 12345create table Member ( id bigint not null, name varchar(255), primary key (id)); 객체 클래스 생성 1234567891011121314151617181920212223@Entitypublic class Member { @Id private Long id; private String name; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; }} @Entity : JPA가 관리할 객체 @Table : name값을 지정해주면 설정한 이름의 테이블고 매핑된다. (없으면 클래스 이름)@Column 도 마찬가지로 동작한다. (없으면 필드 이름) @Id : 데이터베이스 PK와 매칭 회원저장 em.persist(Object entity); hibernate.show_sql : 쿼리가 출력된다. hibernate.format_sql : 쿼리가 이쁘게 포맷팅된다. hibernate.use_sql_comments : 이 쿼리가 왜나왔는지 주석이 달린다. 사실은 위와 같은 코드는 좋지 않은 코드이다. EntityManger를 만드는 과정에서 에러가 발생한다면.. close() 메소드등을 호출하지 못한다. 실제론 이와같은 코드가 될 것이다. 회원 단 건 조회 Member member = em.find(Member.class, 1L); 회원 삭제 찾은 회원을 remove 메소드 파라미터에 넣어준다.em.remove(entity); 회원수정 찾은 회원을 객체를 수정한다. 따로 저장하는 업데이트 메소드를 호출하지 않았지만, 트랜잭션을 커밋하는 시점에 변경사항을 체크한다. (dirty checking)변경 사항이 있으면 update 쿼리를 날려준다. JPA 쓸 때, 원하는 데이터를 최적화 및 목적에 맞도록 query를 날리고 싶다면 어떻게 해야할까..JPA에서는 JPQL을 통해 도와준다. JPQL 소개 JPA를 사용하면 엔티티 객체를 중심으로 개발 문제는 검색 쿼리 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요 SQL을 추상화해서 특정 데이터베이스 SQL에 의존X (DB방언) JPQL을 한마디로 정의하면 객체 지향 SQL","link":"/2019/10/08/JPA/ORM-JPA02/"},{"title":"ORM03 - 영속성 관리(내부 동작 방식)(영속성 컨텍스트(Dirty checking, 스냅샷..), 플러시, 준영속 상태)","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편영속성 관리 - 내부 동작 방식 JPA에서 가장 중요한 2가지 객체와 관계형 데이터베이스 매핑하기(설계) 영속성 컨텍스트 영속성 컨텍스트 JPA를 이해하는데 가장 중요한 용어 ‘엔티티를 영구 저장하는 환경’이라는 뜻 EntityManger.persist(entity); 사실 이것은 DB에 저장한다는 뜻이아닌, 엔티티를 영속성컨텍스트에 저장한다는 뜻 영속성 컨텍스트는 논리적인 개념 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근 엔티티의 생명주기 비영속 (new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 영속 (managed) 영속성 컨텍스트에 관리되는 상태 준영속 (detached) 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제 (removed) 삭제된 상태 코드로 살펴보자. 비영속 123Member member = new Member();member.setId(\"member1\");member.setUsername(\"회원1\"); 객체를 생성한 상태 JPA와 전혀 상관없는 상태 영속 12345678Member member = new Member();member.setId(\"member1\");member.setUsername(\"회원1\");EntityManager em = emf.createEntityManger();em.getTransaction().begin();em.persist(member); 영속성 컨텍스트안에 Member객체가 들억간다. 아직 DB에 저장되는것이 아니다. DB에 저장된다면 BEFORE와 AFTER사이에 쿼리가 찍혔을것이다. 준영속1em.detatch(member); 영속성 컨텍스트에서 분리 삭제1em.remove(member); 객체를 DB에서 영구삭제 영속성 컨텍스트의 이점 1차 캐시 동일성(identity) 보장 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) 변경 감지(Dirty Checking) 지연로딩(Lazy Loading) 컨텍스트 이점들에 대해 자세히 알아보자. 엔티티 조회, 1차 캐시 엔티티를 영속하면 1차캐시에 저장된다. @Id 값을 키값 Entity를 value값인 맵형태의 1차 캐시에 저장 1차캐시에서 조회 1차 캐시에서 먼저 찾는다. 데이터베이스에서 조회 1차캐시에 없을 경우 DB를 조회한 후, 결과를 1차캐시에 저장 후 반환한다. 테스트 1차캐시에 저장된 값을 반환했기 때문에 SELECT 쿼리문이 없다. commit 시에 데이터가 insert 된다. 조회 쿼리가 하나만 조회된다. 조회할때 영속성컨텍스트의 1차캐시 안에 저장하고 반환하기 때문에 두번째 조회할때는 1차캐시 안의 값을 반환한다. 영속 엔티티의 동일성 보장 자바 컬렉션처럼 비교가 가능 엔티티 등록 시, 트랜잭션을 지원하는 쓰기 지연 기본적으로 commit, flush 전에는 DB에 반영하지 않고 쓰지 지연 SQL 저장소에 저장한다. flush, 또는 commit 시에, 일괄 설정에서 hibernate.jdbc.batch_size 를 설정해주면 그 사이즈 만큼 모아서 쿼리를 날린다.(버퍼링 같은 기능) 테스트 코드 실행 변경감지(Dirty Checking) JPA는 commit 시 flush() 메소드를 호출한다. flush를 할 때, 엔티티와 스냅샷을 비교한다. 스냅샷은 1차 캐시안에 존재하는것으로, 해당 엔티티가 1차캐시로 들어올때의 값을 저장해둔것. 비교 후에 값의 변경이 있으면 쓰기 지연 SQL 저장소에 UPDATE 쿼리를 저장해둔다. 그 후에 데이터베이스에 반영 테스트 코드 실행 플러시 영속성 컨텍스트의 변경내용을 데이터베이스에 반영 플러시 발생 변경감지(Dirty Checking) 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제, 쿼리) 영속성 컨텍스트를 플러시하는 방법 em.flush(); 직접 호출 트랜잭션 커밋 : 플러시 자동 호출 JPQL 쿼리 실행 : 플러시 자동 호출 무조건 플러시를 한번 호출 왜냐하면 JPQL은 query를 날리는데 기존에 데이터들이 1차캐시에만 있고 DB에 반영이 안되어있다면 잘못된 결과를 불러올 수 있으므로, 기본모드가 query를 날리기전에 플러시를 한번 해주는것이다. 플러시 모드 옵션1em.setFlushMode(FlushModeType.COMMIT); FlushModeType.AUTO 커밋이나 쿼리를 실행할 때 플러시 (기본값) FlushModeType.COMMIT 커밋할 때만 플러시 거의 사용하지 않는다. 사용하는 경우 : 앞에서 insert한 데이터와 상관없는 테이블을 조회하는 쿼리를 날리는 경우 플러시를 하는 의미가 없기 때문에 사용할 수 도 있으나 … 거의 사용하지 않는다. 주의사항 쓰기 지연 SQL저장소에 있는 쿼리들이 데이터베이스에 반영되는것. 영속성 컨텍스트를 비우지 않음(영속성 컨텍스트에 있는 1차캐시는 지워지지는 않는다.) 트랜잭션이라는 작업 단위가 중요 커밋 직전에만 동기화 하면 된다. JPA는 기본적으로 데이터동기화등 동시성 관련내용은 트랜잭션에 위임한다. 준영속 상태 영속 -&gt; 준영속 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 영속성 컨텍스트가 제공하는 기능을 사용 못함 준영속 상태로 만드는 방법 em.detach(entity); 특정 엔티티만 준영속 상태로 전환 em.clear(); 영속성 컨텍스트를 완전히 초기화 em.close(); 영속성 컨텍스트를 종료 예시 상태값이 변경 됬지만, update 쿼리문이 날라가지 않는다.","link":"/2019/10/08/JPA/ORM-JPA03/"},{"title":"ORM07 - 고급매핑(상속관계 매핑, MappedSuperclass)","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편고급매핑상속관계 매핑 객체는 상속관계가 있지만, 관계형 데이터베이스는 상속 관계가 없다. 슈퍼타입 서브타입 관계라는 모델링 기법이 객체의 상속과 유사하다. 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법 조인 전략 : 각각 테이블로 변환 각 테이블을 모두 생성 슈퍼타입 테이블의 PK를 서브타입의 PK,FK로 둔다. 해당 PK로 조인하여 조회 슈퍼타입에 구분하기 윈한 구분자 컬럼을 둔다. 단일 테이블 전략 : 통합 테이블로 변환 모든 테이블을 하나의 테이블로 구현하고 구분자 컬럼을 둔다. 구현 클래스마다 테이블 전략 : 서브타입 테이블로 변환 모든 테이블을 따로 구현한다. 조인전략12345678910111213141516171819202122232425262728@Entity@Inheritance(strategy = InheritanceType.JOINED)@DiscriminatorColumnpublic class Item { @Id @GeneratedValue private Long id; private String name; private int price;}@Entitypublic class Book extends Item { private String author; private String isbn;}@Entitypublic class Album extends Item { private String artist;}@Entitypublic class Movie extends Item { private String director; private String actor;} @DiscriminatorColumn 을 추가 하지 않으면 구분자 컬럼은 생략된다. name값은 기본은 엔티티 이름이다. 넣어주는게 DB에서 확인하기 좋다. 구분자 컬럼 value값에 들어갈 값을 엔티티명이 아닌 다른값으로 변경하려면 @DiscriminatorValue(&quot;A&quot;) 처럼 사용할 수 있다. 12345@Entity@DiscriminatorValue(\"A\")public class Album extends Item { private String artist;} 장점 테이블이 정규화 된다. 외래 키 참조 무결성 제약조건 활용가능 저장공간 효율화 JPA와 가장 유사 모델 단점 조회시 조인을 많이 사용 -&gt; 성능 저하 조회쿼리가 복잡하다. 데이터 저장 시, INSERT 2회 호출 단일 테이블 전략1234567891011@Entity@Inheritance(strategy = InheritanceType.SINGLE_TABLE)@DiscriminatorColumnpublic class Item { @Id @GeneratedValue private Long id; private String name; private int price;} 기본전략(starategy를 적어주지 않았을 때는 이옵션이 선택된다.) 장점 조인이 필요 없어 일반적으로 조회 성능이 빠름 조회쿼리가 단순하다. 단점 자식 엔티티가 매핑한 컬럼은 모두 null 허용이 필요하다. 단일 테이블에 모든것을 저장하므로 테이블이 커질 수 있다.(상황에 따라 조회 성능이 느려질 수 있다.) @DiscriminatorColumn 가 없어도 hibernate가 DType(구분자 컬럼)을 생성해준다. 구현 클래스마다 테이블 전략 구분자컬럼을 사용할 필요가 없다. (각각 생성되기 때문에) 장점 서브 타입을 명확하게 구분해서 처리할 대 효과적이다. not null 제약조건 사용가능 단점 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요) 자식 테이블을 통합해서 쿼리하기 어려움 이 전략은 데이터베이스 설계와 ORM 전문가 둘 다 추천 X 조인 전략과 단일 테이블 전략 사이에서 고민을 하여 결정하자. 비지니스 로직적으로 중요하거나 데이터가 많은 경우, 조인전략 비교적 단순한경우 단일 테이블 전략 @MappedSuperClass 공통 매핑 정보가 필요할 때 사용(id, name등의 항상 필요한 컬럼) 상속관계 매핑 X 엔티티 X, 테이블과 매핑X 부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공 조회, 검색 불가 em.find(BaseEntity) 와 같은 검색 불가 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용되는 매핑 정보를 모으는 역할 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용 @Entity 클래스는 엔티티나 @MappedSuperclass로 지정된 클래스만 상속가능","link":"/2019/11/18/JPA/ORM-JPA07/"},{"title":"ORM06 - 다양한 연관관계 매핑(다대일, 일대다, 일대일, 다대)","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편다양한 연관관계 매핑연관관계 매핑시 고려사항 다중성 단방향, 양방향 양방향일 때, 연관관계의 주인 다중성 다대일 : @ManyToOne 일대다 : @OneToMany 일대일 : @OneToOne 다대다 : @ManyToMany 실무에서는 쓰지 않는다. 단방향, 양방향 테이블 외래키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음 객체 참조용 필드가 있는 쪽으로만 참조가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향 사실 단방향 두개 연관관계의 주인 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음 객체 양방향 관계는 A -&gt; B, B -&gt; A 처럼 참조가 두개 객체 양방향 관계는 참조가 2군데 있음. 둘중 테이블 외래키를 관리할 곳을 지정해야한다. 연관관계의 주인 : 외래키를 관리하는 참조 주인의 반대편 외래 키에 영향을 주지 않음, 단순 조회 가능 다대일(N : 1)다대일 단방향 가장 많이 사용하는 연관관계 다대일의 반대는 일대다 다대일 양방향 외래 키가 있는 쪽이 연관관계의 주인 다가 연관간계의 주인이 되는것이 좋다. 양쪽을 서로 참조하도록 개발 주인이 아닌쪽은 읽기만 가능 일대다(1 : N)일대다 단방향 이모델은 권장하지 않음 일대다 단방향은 일대다(1 : N)에서 일(1)이 연관관계의 주인 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있음 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조 @JoinColumn을 꼭 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블이 추가된다.) 단점 엔티티가 관리하는 외래키가 다른 테이블에 있음 연간관계 관리를 위해 추가로 UPDATE SQL 실행 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자. 일대다 양방향 이런 매핑은 공식적으로 존재 X @JoinColumn(insertable=false, updatable=false) 을 추가한다. 1234567891011121314@Entitypublic class Team { @Id @GeneratedValue @Column(name = \"team_id\") private Long id; @Column(name = \"name\", length = 50) private String name; @OneToMany @JoinColumn(name = \"team_id\") private List&lt;Member&gt; members = new ArrayList&lt;&gt;();} 1234567891011121314@Entitypublic class Member { @Id @GeneratedValue @Column(name = \"member_id\") private Long id; @Column(name = \"name\") private String username; @ManyToOne @JoinColumn(name=\"team_id\", insertable = false, updatable = false) private Team team;} 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법 insertable = false, updatable = false 를 쓰면 읽기 전용이 된다. 다대일 양방향을 사용하자. 일대일(1 : 1)일대일 관계 일대일 관계는 그 반대도 일대일 주 테이블이나 대상 테이블 중에 외래 키 선택 가능 주 테이블 외래 키 대상 테이블에 외래 키 외래 키에 데이터베이스 유니크 제약조건 추가 안줘도 되지만 세심한 관리가 필요해진다. @JoinColumn을 넣어주는것을 추천(default값이 지저분하다.) 일대일: 주 테이블에 외래 키 양방향 다대일 양방향 매핑 처럼 외래 키가 있는곳이 연관관계의 주인 반대편은 mappedBy 적용 일대일: 대상 테이블에 외래 키 단방향 정리 단방향 관계는 JPA에서 지원하지 않는다. 양방향 관계는 지원 일대일: 대상 테이블에 외래 키 양방향 정리 일대일 주 테이블에 외래 키 양방향과 매핑 방법은 같음 정리 주 테이블 외래 키 주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음 객체지향 개발자가 선호 JPA매핑관리 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인가능 단점 : 값이 없으면 외래 키에 null 허용 대상 테이블에 외래 키 대상 테이블에 외래 키가 존재 전통적인 데이터베이스 개발자 선호 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지 단점 : 프록시 기능의 한계로 지연로딩으로 설정해도 항상 즉시 로딩됨 다대다(N : M) 실무에서 사용하지 않는것을 추천한다. 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야한다. 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능 @ManyToMany 사용 @JoinTable 로 연결 테이블 지정 name = 생성될 연결 테이블의 이름 다대다 매핑 : 단방향, 양방향 가능 양방향 시, @ManyToMany(mappedBy =&quot;&quot;) 옵션으로 대상 객체에 추가 다대다 매핑의 한계 편리해 보이지만 실무에서 사용하지 않는것을 추천한다. 실제 로직은 연결 테이블이 단순히 연결만하고 끝나지 않음 주문시간, 수량같은 데이터가 들어올 수 있음. 다다대 매핑의 한계 극복 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격) @ManyToMany -&gt; @OneToMany, @ManyToOne 12345678910111213141516@Entity@NoargsConstructor@Getterpublic class MemberProduct { @Id @GeneratedValue private Long id; @ManyToOne @JoinColumn(name = \"member_id\") private Member member; @ManyToOne @JoinColumn(name = \"product_id\") private Product product;} 반대쪽에는 @OneToMany(mappedBy = &quot;product&quot;), @OneToMany(mappedBy = &quot;member&quot;)와같이 설정해준다. 원하는 필드를 추가 가능하다. PK는 의미없는값을 쓰느것을 추천한다. 유연성이나, 운영시에 유리하다.","link":"/2019/10/19/JPA/ORM-JPA06/"},{"title":"ORM08 - 프록시와 연관관계 관리(프록시, fetchType, cascade, orphanRemoval, 고아객체)","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편프록시와 연관관계 관리프록시기초 em.find() vs em.getReference() em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회 query를 날린다. em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회 query를 날리지 않는다. 직접 사용할 때 query를 날린다. hibernate가 만든 가짜 클래스를 호출한다.(Proxy객체) 프록시의 특징 실제 클래스르 상속 받아서 만든다. 실제 클래스와 겉모양은 같다. 껍데기는 같고 ID값만 가지고 있다. 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.(이론상) 프록시 객체는 실제 객체의 참조(target)을 보관한다. 처음에는 target = null인 상태이다.(DB에서 조회한적이 없기 때문에…) 프록시 객체를 호출하면, 프록시 객체는 실제 객체의 메소드 호출 프록시 객체의 초기화12Member member = em.getReference(Member.class, 1L);member.getUsername(); 실제 사용 요청(member.getName()) 영속성 컨텍스트로 초기화 요청 DB 조회 실제 엔티티 생성하고 target에 연결해준다. target.getName() 호출 프록시의 특징 프록시 객체는 처음 사용할 때 한번만 초기화 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는것은 아니다. 초기화되면 프록시 객체를 통해 실제 엔티티 접근 가능 프록시 객체는 원본 엔티티를 상속받음 타입 체크 시 주의가 필요( == 대신 instanseof 사용) 영속성 컨텍스트에 찾는 엔티티가 있으면 em.getReference()를 호출해도 실제 엔티티 반환 JPA는 같은 트랜잭션안에서 같은 데이터에 대하여 인스턴스 비교(==)를 보장한다.(type이 다르면 ==비교는 무조건 false) 프록시로 한번 조회가 되면 em.find()로 조회해도 프록시 클래스로 조회가 된다. 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제발생 org.hibernate.LazyInitializationException 예외 발생 프록시 확인 프록시 인스턴스의 초기화 여부 확인 1PersistenceUnitUtil.isLoaded(Object entity); 프록시 클래스 확인 방법 1entity.getClass().getName(); 프록시 강제 초기화 1org.hibernate.Hibernate.Initialize(entity); JPA표준에는 강제 초기화가 없다. member.getName(), size() 등으로 강제호출하여 초기화시킨다. 즉시로딩과 지연로딩지연로딩(LAZY)Member를 조회할 때 Team도 조회해야할까? 해당 연관관계에 해당하는 엔티티를 프록시객체로 가져온다. 실제로 사용하는 시점에 초기화(DB조회) 즉시로딩(EAGER)Meber와 Team을 자주 함께 사용한다면? 해당 연관관계에 해당하는 엔티티를 실제 엔티티 객체로 초기화하여 가져온다. JPA구현체는 가능하면 조인을 사용해서 SQL 한번에 함께 조회 프록시와 즉시로딩 주의 가급적 지연 로딩만 사용(실무에서는 특히…) 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생 즉시 로딩은 JPQL에서 N+1문제를 발생시킨다. 일단 주조건 JPQL 쿼리를 SQL로 번역하여 날린다. 그다음에 fetchType등의 조건을 확인 문제를 해결하려면…(일단 지연로딩으로 설정) fetchJoin @EntityGraph 배치사이즈 (1+1으로 쿼리가 나온다.) @ManyToOne, @OneToOne은 기본이 즉시로딩(EAGER) -&gt; LAZY로 변경하는것을 추천 @OneToMany, @ManyToMany는 기본이 지연로딩 지연로딩 활용 이론적으론 자주 함께 사용 -&gt; 즉시로딩 가끔 사용 -&gt; 지연로딩 실제로는 모든 연관관계에서 지연로딩으로 설정하자. 즉시 로딩은 상상하지 못한 query가 발생한다. JPQL의 fetchJoin 또는 EntityGraph기능을 사용하자. 영속성 전이: CASCADE 특정 엔티티를 영속상태로 만들 때, 연관된 엔티티도 함께 영속상태로 만들고 싶을 때 예시&gt; 부모 엔티티를 저장할 때, 자식 엔티티도 함께 저장. CascadeType.ALL or PERSIST를 주로 사용 저장만 필요한 경우 PERSIST 아닌경우 ALL(삭제등..) 주의사항 영속성 전이는 연관관계를 매핑하는 것과 아무 관련 없다. 엔티티를 영속화할 때, 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐 라이프 사이클이 유사할 때, 사용하자. 단일 소유자 일 때, 사용하자. CASCADE의 종류 ALL : 모두적용 PERSIST : 영속 REMOVE : 삭제 MERGE : 병합 REFRESH : REFRESH DETACH : DETACH 고아객체 부모 엔티티와 연관관계가 끊어진 자식 엔티티 orphanRemoval = true : 고아객체를 자동으로 삭제 단일 소유자(참조가 1개)일 때, 사용하자. 또한 부모가 삭제되면 고아객체가 되어 삭제된다.(CascadeType.REMOVE 처럼 동작한다.) 고아객체 자동삭제 주의 단일 소유자 일 때만 사용하자. 특정 엔티티가 개인소유 참조하는 곳이 하나 영속성 전이 + 고아객체, 생명주기 스스로 생명주기를 관리하는 엔티티는 em.persist() , em.remove() 로 제거 CascadeType.ALL + orphanRemoval=true 두 옵션 모두를 활성 화 시, 부모 엔티티로를 통해서 자식의 생명주기를 관리할 수 있다. orphanRemoval = true 미설정 시, collection 객체 삭제에 대하여 작동하지 않는다. DDD(DomainDrivenDesign) 도메인 주도 설계의 AggregateRoot개념을 구현할 때, 유용하다. Aggregate하나당 Repository하나인 것을 추천한다.","link":"/2019/12/08/JPA/ORM-JPA08/"},{"title":"ORM05 - 연관관계 매핑 기초(단방향 연관관계, 양방향 연관관계, 연관관계의 주인, 연관관계 매핑 주의사항)","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편연관관계 매핑 기초 객체와 테이블 연관관계의 차이를 이해가 필요 객체의 참조와 테이블의 외래키 매핑 방향(Direction) : 단방향, 양방향 다중성(Multiplicity) : 다대일(N : 1), 일대다 (1 : N), 일대일 (1 : 1), 다대다(N : M) 연관관계의 주인(Owner) : 객체 양방향 연관관계는 관리 주인이 필요 연관관계가 필요한 이유 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다. 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾는다. 객체는 참조를 사용해서 연관객체를 찾는다. 테이블과 객체 사이에는 이런 큰 간격이 있다. 단방향 연관 관계 도메인 모델링123456789101112131415@Entity@Getter @Setter @NoArgsConstructorpublic class Member { @Id @GeneratedValue private Long id; @Column(name = \"name\") private String username; @ManyToOne @JoinColumn(name = \"team_id\") private Team team;} 1234567891011@Entity@Getter @Setter @NoArgsConstructorpublic class Team { @Id @GeneratedValue @Column(name = \"team_id\") private Long id; @Column(name = \"name\", length = 50) private String name;} 실행 코드12345678910111213141516171819202122232425262728293031323334public class JpaMain { public static void main(String[] args) { EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\"); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try { Team team = new Team(); team.setName(\"team A\"); em.persist(team); Member member = new Member(); member.setUsername(\"bong\"); member.setTeam(team); em.persist(member); Member findMember = em.find(Member.class, member.getId()); Team findTeam = findMember.getTeam(); System.out.println(\"findTeam.name : \" + findTeam.getName()); tx.commit(); } catch (Exception e) { tx.rollback(); }finally { em.close(); } emf.close(); }} member.getTeam() 으로 team을 찾을 수 있다. 연관관계수정 실행코드123456789101112131415161718192021222324252627282930313233343536373839public class JpaMain { public static void main(String[] args) { EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\"); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try { Team team = new Team(); team.setName(\"team A\"); em.persist(team); Member member = new Member(); member.setUsername(\"bong\"); member.setTeam(team); em.persist(member); Member findMember = em.find(Member.class, member.getId()); System.out.println(\"findTeam.name : \" + findMember.getTeam().getName()); Team newTeam = new Team(); newTeam.setName(\"updateTeam\"); em.persist(newTeam); findMember.setTeam(newTeam); System.out.println(\"update findTeam.name : \" + findMember.getTeam().getName()); tx.commit(); } catch (Exception e) { tx.rollback(); }finally { em.close(); } emf.close(); }} 객체만 변경해주면 DB에도 업데이트 된다. 양방향 연관관계와 연관관계의 주인 도메인 모델링123456789101112131415@Entity@Getter @Setter @NoArgsConstructorpublic class Member { @Id @GeneratedValue @Column(name = \"member_id\") private Long id; @Column(name = \"name\") private String username; @ManyToOne @JoinColumn(name = \"team_id\") private Team team;} 1234567891011121314@Entity@Getter @Setter @NoArgsConstructorpublic class Team { @Id @GeneratedValue @Column(name = \"team_id\") private Long id; @Column(name = \"name\", length = 50) private String name; @OneToMany(mappedBy = \"team\") private List&lt;Member&gt; members = new ArrayList&lt;&gt;();} 연관관계의 주인은 주로 관계의 다수 인쪽에 설정하는것이 좋다. 바꿔 말하면 @ManyToOne인쪽이 주인 mappedBy는 연관관계의 주인이 아닌쪽에 설정한다. 바꿔 말하면 @OneToMany인쪽에 mappedBy 테스트 실행에 앞서 알아야 할 내용들이 있다. 객체의 양방향 관계 객체 연과관계 = 단방향 연관관계 2개 회원 -&gt; 팀 연관관계 1개(단방향) 팀 -&gt; 회원 연관관계 1개(단방향) 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개이다. 객체를 양방향으로 참조하려면 단방향 연관관계 2개를 만들어야 한다. 테이블의 양방향 연관관계 테이블 연관관계 1개 회원 팀 연관관계 1개(양방향) 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리 MEMBER.TEAM_ID 외래 키 하나로 양방향 연관관계 가짐(양쪽으로 조인 가능) 외래 키 관리 객체의 경우 두개의 단방향 관계이기 때문에 한족에서 외래 키를 관리해야한다. 외래키를 관리하는 객체를 연관관계의 주인(Owner)이라고 한다. 한쪽은 읽기만 가능한 가짜 매핑이 될 수 밖에 없다. 연관관계의 주인(Owner)양방향 매핑 규칙을 기준으로 .. 객체의 두 관계중 하나를 연관관계의 주인으로 지정 연관관계의 주인만이 외래 키를 관리(등록, 수정) 주인이 아닌쪽은 읽기만 가능 주인은 mappedBy 속성 사용 X 주인이 아니면 mappedBy 속성으로 주인 지정 주인쪽에서 현재 자신으로 매핑된 필드 이름을 입력한다. 누구를 주인으로? 외래키가 있는 곳을 주인 DB에서 foreign key는 다인쪽이 갖는다. 즉, 다대일 관계에서 다인쪽이 주인이 되는것이 좋다.(헷갈리지 않음) 예) team(1) : member(n) -&gt; 주인 member 주의사항 양방향 매핑 시, 연관관계의 주인에 값을 입력 또는 수정해야 DB에 반영된다. 주인이 아닌쪽은 읽기만 가능 실행코드 연관관계 주인쪽 입력 1234567891011121314Team team = new Team();team.setName(\"team A\");em.persist(team);Member member = new Member();member.setUsername(\"bong\");member.setTeam(team);em.persist(member);em.flush();em.clear();Team findTeam = em.find(Team.class, 1L);List&lt;Member&gt; members = findTeam.getMembers(); 주인이 아닌쪽 입력 12345678910111213141516Team team = new Team();team.setName(\"team A\");em.persist(team);Member member = new Member();member.setUsername(\"bong\");team.getMembers.add(member);em.persist(member);em.flush();em.clear();Team findTeam = em.find(Team.class, 1L);List&lt;Member&gt; members = findTeam.getMembers(); 정상적으로 DB에 저장되지 않는것을 볼 수 있다. 주의점 양방향 매핑시 가장 많이 하는 실수 연관관게의 주인에 값을 입력하지 않음 1234567891011Member member = new Member();member.setUsername(\"bong\");em.persist(member);Team team = new Team();team.setName(\"team A\");team.getMembers().add(member);em.persist(team);em.flush();em.clear(); 연관관계의 주인은 Member이다. Team에서만 Member를 지정해주었다. DB에는 반영되어지지 않는다. 양방향 연관관계 주의 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하는것을 추천한다. 객체지향적으로 생각을하면 양쪽에 값을 넣는것 맞기 때문에… flush하지 않고 1차캐시 값을 사용할 때, 값이 정확하지 않다. flush() 사용 -&gt; DB에 바로 반영 flush() 사용안함 -&gt; 1차 캐시 값 사용 test케이스 작성 시, JPA를 사용하지 않고 JAVA코드로 작성할 때 값이 정확하지 않다. 연관관계 편의 메소드를 생성하자 1234public void changeTeam (Team team) { this.team = team; team.getMembers().add(this);} 이런식으로 양방향 값을 변경해주는 메소드를 만들어 놓는것이 좋다. 양쪽에 이러한 연관관계 설정 메소드가 있으면 헷갈리수 있으니 한쪽에만 만들어 놓는것을 추천한다. 양방향 매핑시에 무한 루프를 조심하자 toString() 양방향 매핑 필드는 제외해야한다. lombok 양방향 매핑 필드는 제외해야한다. JSON생성 Controller에서 Entity를 직접 반환하는일은 없도록 해야한다. DTO사용하여 반환한는 것이 좋다. 양방향 매핑 정리 단방향 매핑만으로 이미 연관관계 매핑은 설계는 완료가 되야한다. 양방향 매핑은 반대 방향으로 조회기능만 추가된것 뿐 JPQL에서 역방향으로 탐색할 일이 많을때 양방향이 필요. 단방향 매핑을 잘 하고 양방향은 필요할 때만 추가 (테이블에 영향을 주지 않음)","link":"/2019/10/13/JPA/ORM-JPA05/"},{"title":"ORM10 - 객체지향 쿼리언어1 기본문법(JPQL, 조인, 페이징, 서브쿼리, 조건식, 사용자 정의 방언)","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편객체지향 쿼리언어1 - 기본문법 JPA는 다양한 쿼리 방법을 지원한다. JPQL 표준문법 JPA Criteria 자바 코드로 JPQL을 빌드해주는 Generator 클래스의 모음 QueryDSL 자바 코드로 JPQL을 빌드해주는 Generator 클래스의 모음 네이티브 SQL DB종속적인 문법 사용 시, 사용 JDBC API 직접사용(MyBatis, SpringJdbcTemplate 함께 사용) 대부분의 문제는 JPQL로 해결할 수 있다.소개 JPQL JPA를 사용하면 엔티티 객체를 중심으로 개발 문제는 검색 쿼리 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색 모둔 DB 데이터를 객체로 변환해서 검색하는 것은 불가능 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요 JPA는 SQL을 추상화한 JPQL이라는 객체지향 쿼리 언어 제공 SQL과 문법이 유사 ANSI표준 SQL 문법을 전부 지원 SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 등 JPQL은 엔티티 객체를 대상으로 쿼리 SQL은 데이터베이스 테이블을 대상으로 쿼리 JPQL 작성하면 SQL로 번역되어서 실행된다. 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리 SQL을 추상화해서 데이터베이스 SQL에 의존하지 않는다. 한마디로 정의하면 객체지향 SQL 예시 Criteria 문자가 아닌 자바코드로 JPQL을 작성할 수 있음 SQL스럽지 않다. JPQL 빌더 역할 JPA 공식기능 너무 복잡하고 실용성이 없다. Criteria 대신 QueryDSL 사용을 권장한다. 예시 1234567CriteriaBuilder cb = em.getCriteriaBuilder();CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class);Root&lt;Member&gt; m = query.from(Member.class);CriteriaQuery&lt;Member&gt; cq = query.select(m).where(cb.equal(m.get(\"username\"), \"kim\"));List&lt;Member&gt; resultList = em.createQuery(cq).getResultList(); QueryDSL SQL 스럽다. 사용하기 위해서는 Setting이 필요하다. 문자가 아닌 자바코드로 JPQL을 작성할 수 있다. JPQL 빌더 역할 컴파일 시점에 문법 오류를 찾을 수 있다. 동적쿼리 작성 편리함. 단순하고 쉽다. 실무사용 권장. NativeSQL JPA가 제공하는 SQL을 직접 사용하는 기능 JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능 예시) 오라클의 CONNECT BY, 특정 DB만 사용하는 SQL 힌트 예시 1List resultList = em.createNativeQuery(\"select member_id, city, street from member\").getResultList(); NativeQuery 사용 대신 JDBC직접사용, SpringJdbcTemplate으로 대체하여 사용할 수 있다. (더 편함) JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스등을 함께 사용 가능 단 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요 예)JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시 해야한다. JPQL은 commit 할 때, 또는 query 날릴 때(createQuery()등) flush가 발생한다. JPA가 아닌 직접 DB connection으로 query를 날릴 때(JDBC직접사용, SpringJdbcTemplate사용 등)는 사전에 em.flush() 를 사용해서 수동으로 flush를 해줘야한다. 정리 JPQL을 확실히 알아야한다. QueryDSL로 작성하면 문법 버그 및 오타를 줄일 수 있다. JPQL 및 QueryDSL을 중점으로 학습하자. JPQL Java Persistence Query Language 객체지향 쿼리 언어 테이블을 대상으로 쿼리하는것이 아닌 엔티티 객체를 대상으로 쿼리한다. JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다. JPQL은 결국 SQL로 변환된다. 문법 select select 절from 절[where 절][groupby 절][having 절][orderby 절] update update 절 [where 절] 한번에 여러개를 update 할 때, 사용 delete delete 절 [where 절] 한번에 여러개 delete 할 때, 사용 1select m from Member as m where m.age &gt; 18 엔티티와 속성은 대소문자를 구분한다.(Member, age…) JPQL 키워드는 대소문자를 구분하지 않는다.(select, from, where) 엔티티 이름 사용, 테이블 이름이 아니다. 별칭은 필수(m) as는 생략가능 집합과 정렬 JPA는 ANSI SQL 표준 function을 지원한다. COUNT(m) : 회원수 SUM(m.age) : 나이 합 AVG(m.age) : 나이 평균 MAX(m.age) : 최대 나이 MIN(m.age) : 최소 나이 GROUP BY, HAVING ORDER BY TypeQuery, Query TypeQuery : 반환 타입이 명확할 때 사용한다. 1TypedQuery&lt;Member&gt; findMember = em.createQuery(\"select m from Member m\", Member.class); Query : 반환 타입이 명확하지 않을 때 사용 1Query query = em.createQuery(\"select m.age, m.name from Member m\"); 결과조회 query.getResultList() : 결과가 하나 이상일 때, List 반환 결과가 없으면 빈 List query.getSingleResult() : 결과가 한개일 때, 단일 객체 반환 결과가 없으면, javax.persistence.NoResultException 결과가 둘 이상 이면, javax.persistence.NonUniqueResultException 파라미터 바인딩 - 이름 기준, 위치기준 이름기준 123TypedQuery&lt;Member&gt; query = em.createQuery(\"select m from Member m where m.name = :username\", Member.class);query.setParameter(\"username\", \"bong\");Member findMember = query.getSingleResult(); 위치기준 123TypedQuery&lt;Member&gt; query = em.createQuery(\"select m from Member m where m.name = ?1\", Member.class);query.setParameter(1, \"bong\");Member findMember = query.getSingleResult(); 위치기준은 혼선을 줄 수 있으니, 안쓰는것을 추천한다. 프로젝션 SELECT 절에 조회할 대상을 지정하는 것 프로젝션 대상 엔티티 타입 SELECT m FROM Member m SELECT m.team FROM Member m 임베디드 타입 SELECT m.address FROM Member m 스칼라 타입(숫자, 문자등 기본 데이터타입) SELECT m.username, m.age FROM Member m DISTINCT로 중복 제거 1List&lt;Member&gt; findMember = em.createQuery(\"select m from Member m\", Member.class).getResultList(); findMember는 영속성 컨텍스트에 관리가 될까? 결과로 나오는 Member 모두 관리가 된다. 연관관계의 엔티티도 마찬가지로 관리가 된다. 프로젝션 - 여러 값 조회1SELECT m.username, m.age FROM Member m 위와 같이 String, Integer 두개의 스칼라 타입을 조회하는 쿼리문은 응답 타입이 2개인데 어떻게 가져올까? Query 타입으로 조회 Object[] 타입으로 변환하여 사용 Object[] 타입으로 조회 new 명령어로 조회 DTO를 생성 jpql new 명령어 사용 패키지명을 포함한 전체 클래스 명 입력 순서와 타입이 일치하는 생성자 필요 QueryDSL을 사용하면 보다 편하게 사용할 수 있다. 페이징 API JPA는 페이징을 다음 두 API로 추상화 setFirstResult(int startPosition) : 조회 시작 위취 setMaxResult(int maxResult) : 조회할 데이터 수 설정한 방언에 따라서 페이징 SQL을 만들어준다.(Oracle 등의 DB에서는 페이징 처리가 굉장히 복잡했다…) 조인 내부 조인 : SELECT m FROM Member m [INNER] JOIN m.team t 외부 조인 : SELECT m FROM Member m LEFT [OUTER] JOIN m.team t 세타 조인 : select count(m) from Member m, Team t where m.username = t.name ON 절 JPA 2.1 부터 지원 (우리가 쓰는건 대부분 2.1 이상이다.) 조인 대상 필터링 연과관계 없는 엔티티 외부 조인(하이버네이트 5.1부터 지원) 조인대상 필터링예시 : 회원과 팀을 조인하면서, 팀 이름이 A인 팀만 조인 JPQL : SELECT m, t FROM Member m LEFT JOIN m.team t ON t.name ='A' SQL : SELECT m.*, t.* FROM member m LEFT JOIN TEAM t ON m.team_id = t.id and t.name = 'A' 연관관계 없는 엔티티 외부 조인예시 : 회원의 이름과 팀의 이름이 같은 대상 외부 조인 JPQL : SELECT m, t FROM Member m LEFT JOIN Team t ON m.username = t.name SQL : SELECT m.*, t.* FROM member m LEFT JOIN Team t ON m.usernmae = t.name 서브 쿼리 예시 : 나이가 평균보다 많은 회원 12SELECT m FROM Member mwhere m.age &gt; (SELECT avg(m2.age) FROM Member m2) 한건이라도 준한 고객 12SELECT m from Member mwhere (SELECT count(o) FROM Order o WHERE m = o.member) &gt; 0 지원함수 (NOT) EXISTS : 서브쿼리에 결과가 존재하면 참 팀 A 소속인 회원 12SELECT m FROM Member mwhere exists (select t from m.team t where t.name = '팀A') ALL 모두 만족 시, 참 전체 상품 각각의 재고보다 주문량이 많은 주문들 12SELECT o FROM Order oWHERE o.orderAmount &gt; ALL(SELECT p.stockAmount FROM Product p) ANY, SOME : 조건을 하나라도 만족하면 참 어떤 팀이든 팀에 소속된 회원 12SELECT m FROM Member mWHERE m.team = ANY (SELECT t from Team t) (NOT) IN : 서브쿼리 결과중 하나라도 같은것이 있으면 참 일반적인 SQL의 IN과 같다고 보면 된다. JPA 서브쿼리 한계 JPA는 WHERE, HAVING 절에서만 서브 쿼리 사용 가능 SELECT 절도 가능 (JPA 표준 스펙은 아니고 하이버네이트에서 지원) FROM 절의 서브쿼리는 현재 JPQL에서 불가능하다. 조인으로 풀 수 있으면 풀어서 해결 극복방법 Native SQL 쿼리 분해해서 날린다. 어플리케이션 로직에서 처리 JPQL 타입 표현 문자 : ‘HELLO’, ‘She’’s’ (‘가 필요하면 두개’) 숫자 : 10L(Long), 10D(Double), 10F(Float) Boolean : TRUE, FALSE ENUM : jpql.MemberType.ADMIN(패키지명 포함) 파라미터로 넣으면 좀 더 편하게 넣을 수 있다. 엔티티 타입 : TYPE(m) = Member (상속 관계에서 사용) Book은 ITEM을 상속받는다. JPQL 기타 SQL과 문법이 같은 식은 다 가능하다. AND, OR, NOT =, &gt;, &lt;, &gt;=, &lt;= BETWEEN, LIKE, IS NULL 조건식 - CASE 기본 CASE 식 12345selectcase when m.age &lt;= 10 then '학생요금' when m.age &gt;= 60 then '경로요금'endelse '일반요금'from Member m 단순 CASE 식 123456selectcase t.namewhen '팀A' then '인센티브110%' when '팀B' then '인센티브120%'endelse '인센티브105%'from Team t 정확한 매칭 COALESCE : 하나씩 조회해서 null이 아니면 반환 NULLIF : 두 값이 같으면 null 반환, 다르면 첫번째 값 반환 JPQL 기본함수JPQL에서 제공하는 표준함수 CONCAT 문자 더하기 SUBSTRING 문자 자르기 TRIM 공백 없애기 LOWER, UPPER 대문자, 소문자 LENGTH String 길이 LOCATE String 검색 위치 ABS, SQRT, MOD SIZE, INDEX SIZE : 컬렉션의 사이즈.. 사용자 정의 함수 하이버네이트는 사용전 방언에 추가해야 한다. 사용하는 DB방언을 상속받고, 사용자 정의함수를 등록한후, 사용한다. 1SELECT FUNCTION('group_concat', i.name) FROM ITEM i 기본적인 함수들은 등록이 되어있다. 사용자 방언 생성 사용하는 DB 방언을 상속받아서 만들고, 사용할 사용자정의함수를 등록한다.(생성자를 통해서) 생성한 방언을 사용한다고 설정한다.","link":"/2020/01/27/JPA/ORM-JPA10/"},{"title":"ORM09 - 값 타입(값 타입, 임베디드 타입, 값 타입 컬렉션)","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편값 타입기본값 타입 JPA의 데이터 타입분류 엔티티 타입 @Entity로 정의하는 객체 데이터가 변해도 식별자로 지속해서 추적가능 값 타입 int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 식별자가 없고 값만 있으므로 추적 불가값 타입 분류 기본값 타입 자바 기본 타입(int, double) 래퍼 클래스(Integer, Long) String 임베디드 타입 복합 값 타입 (ex&gt; x, y 좌표등의 값) 컬렉션 값 타입 자바 컬렉션객체에 기본값이나 임베디드 타입을 넣는것. 기본값 타입 예) String name, int age 등 생명주기를 엔티티에 의존 회원이 삭제되면 이름, 나이 필드도 함께 삭제 값 타입은 공유하면 안된다. 회원 이름 변경 시, 다른 회원의 이름도 함께 변경되면 안된다. 자바의 기본 타입은 절대 공유가 안된다.자바의 기본타입(primitive type)은 공유되지 않는다.기본타입은 항상 값을 복사한다.Integer같은 래퍼 클래스나 String같은 특수한 클래스는 공유 가능한 객체이지만 변경이 되지 않는다. 임베디드 타입 새로운 값 타입을 직접 정의할 수 있다. JPA는 임베디드 타입 이라고 한다. 주로 기본값 타입을 모아서 만들어서 복합 값 타입이라고도 한다. 임베디드 타입을 어떤경우에 사용할까?example 회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소도시, 주소번지, 주소 우편번호를 가진다. 이러한 경우 근무기간(근무 시작일, 근무 종료일), 집주소(도시, 번지, 우편번호)로 그룹지어 관리할 수 있다. 최종적으로 JPA는 아래와 같은 모습으로 관리하게 된다. 임베디드 타입 장점 재사용 높은 응집도 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있다. 예) WorkPeriod.isWork() (현재 근무 상태를 체크)와 같이 의미 있는 메소드를 만들어 사용할 수 있다. 임베디드 타입을 포함한 모든 값 타입은, 값을 소유한 엔티티의 생명주기에 의존한다. 임베디드 타입과 테이블 매핑 임베디드 타입은 엔티티의 값일 뿐이다. 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다. 테이블 입장에서는 차이가 없다. 임베디드 타입 미사용 임베디드 타입 사용 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다. 임베디드 타입 사용법 @Embeddable : 값 타입을 정의하는곳에 표시 기본생성자 필수 @Embedded : 값 타입을 사용하는 곳에 표시 데이터입력 예시 임베디드 타입과 연관관계 임베디드 타입의 값으로 엔티티를 참조 할 수 있다. @AttributeOverride 속성 재정의 한 엔티티에서 같은 값 타입을 사용 컬러몀이 중복됨 @AttributeOverrides, @AttributeOverride 를 사용해서 컬럼명 속성을 재정의 12345678910111213@Embedded @AttributeOverrides({ @AttributeOverride( name = \"city\", column = @Column(name = \"work_city\") ), @AttributeOverride( name = \"street\", column = @Column(name = \"work_street\") ), @AttributeOverride( name = \"zip_code\", column = @Column(name = \"work_zip_code\") ) }) private Address workAddress; 임베디드 타입과 null 임베디드 타입의 값이 null 이면 매핑한 컬럼 모두 null 값 타입과 불변 객체 값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념 값 타입은 단순하고 안전하게 다룰 수 있어야 한다. 값 타입 공유 참조 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함 부작용 발생 (값이 같이 변화하게됨) 12345678910111213Address address = new Address(\"city\", \"street\", \"zip_code\");MemberForEmbeded member = new MemberForEmbeded();member.setUsername(\"bong\");member.setHomeAddress(address);em.persist(member);MemberForEmbeded member2 = new MemberForEmbeded();member2.setUsername(\"rack\");member2.setHomeAddress(address);em.persist(member2);member.getHomeAddress().setCity(\"anyang\"); update문이 2개 나가는것을 확인할 수 있다. 공유하고 싶다면 엔티티로 사용해야한다. 값 타입 복사 값 타입의 실제 인스턴스인 값을 공유하는 것은 위험 대신 값(인스턴스)을 복사해서 사용 1234567891011121314Address address = new Address(\"city\", \"street\", \"zip_code\");MemberForEmbeded member = new MemberForEmbeded();member.setUsername(\"bong\");member.setHomeAddress(address);em.persist(member);Address address2 = new Address(address.getCity(), address.getStreet(), address.getZipcode());MemberForEmbeded member2 = new MemberForEmbeded();member2.setUsername(\"rack\");member2.setHomeAddress(address2);em.persist(member2);member.getHomeAddress().setCity(\"anyang\"); 객체 타입의 한계 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다. 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본타입이 아니라 객체 타입 기본(primitive) 타입은 =으로 값을 할당하면, 복사된다. 객체 타입은 참조 값을 직접 대입한다. 객체의 공유참조는 피할 수 없다. 예시 기본 (primitive) 타입 123int a = 10;int b = a; b = 4; a = 10, b =4 객체 123Address a = new Address(\"Old\");Address b = a;b.setCity(\"New\"); a.city = “New”, b.city = “New” 참조값을 전달하기 때문에 함께 변경된다. 불변객체 객체타입을 수정할수 없게 만들면 부작용을 원천 차단 값 타입은 불변객체(immutable object)로 설계해야한다. 생성시점 이후 절대 값을 변경 할 수 없는 객체 생성자로만 값을 설정, 수정자(Setter)를 만들지 않으면 됨(가장 쉬운 방법) Integer, String 은 자바가 제공하는 대표적인 불변객체이다. 값을 바꾸고 싶다면, 전체 객체를 바꿔야한다. 값타입을 복사하여 객체를 새로 생성하는 메소드를 활용하는것이 좋아보임. 123public Address copyAddressExceptCity(String city, Address address) { return new Address(city, address.getStreet(), adress.getZipcode());} 값 타입의 비교 값 타입 : 인스턴스가 달라도 그안에 값이 같으면 같은것으로 봐야한다. 123int a = 10;int b = 10;boolean result = (a==b); result = true 123Address address1 = new Adderess(\"city\", \"street\", \"1000\");Address address2 = new Adderess(\"city\", \"street\", \"1000\");boolean result = (address1 == address2); result = false 인스턴스 참조값을 비교한다. 동일성 (identity) 비교 : 인스턴스의 참조값을 비교, == 사용 동등성(equivalence) 비교 : 인스턴스의 값을 비교, equals() 사용 값 타입은 a.equals(b); 사용하여 동등성을 비교해야한다. 값 타입의 equals() 메소드를 적절하게 재정의 해야한다. 프록시를 사용하는등 복잡해지면 getter로 값을 가져와야 하는 경우도 있다,(인텔리제이 equals 생성 시, 옵션에서 선택가능) 값 타입 컬렉션 값타입을 하나이상 저장할 때 사용 DB는 컬렉션을 같은 테이블에 저장할 수 없다. 컬렉션을 저장하기 위한 별도의 테이블이 필요하다. @ElementCollection, @CollectionTable 사용 식별자를 따로두지 않고 값들을 묶어서 PK로 둔다. 사용 예제 - 설정123456789101112131415161718192021@Entitypublic class MemberForEmbeded { @Id @GeneratedValue private Long id; @Column(name = \"name\") private String username; @Embedded private Address homeAddress; @ElementCollection @CollectionTable(name = \"favoirite_foods\", joinColumns = @JoinColumn(name = \"member_id\")) @Column(name = \"food_name\") private Set&lt;String&gt; favoriteFoods = new HashSet&lt;&gt;(); @ElementCollection @CollectionTable(name = \"address\", joinColumns = @JoinColumn(name = \"member_id\")) private List&lt;Address&gt; addressHistory = new ArrayList&lt;&gt;();} favoriteFoods의 경우 String 단일 컬렉션으로 @Column(name = &quot;&quot;) 저장될 컬럼이름을 설정할 수 있다. @ElementCollection 로 컬렉션임을 설정 CollectionTable 로 생성될 테이블의 이름 및 join colum을 설정한다. 저장12345678910111213MemberForEmbeded member = new MemberForEmbeded();member.setUsername(\"bong\");member.setHomeAddress(new Address(\"city\", \"street\", \"1000\"));member.getFavoriteFoods().add(\"치킨\");member.getFavoriteFoods().add(\"족발\");member.getFavoriteFoods().add(\"피자\");member.getAddressHistory().add(new Address(\"old1\" ,\"street\", \"1000\"));member.getAddressHistory().add(new Address(\"old2\" ,\"street\", \"1000\"));em.persist(member);tx.commit(); 값 타입 컬렉션은 사용하고 있는 엔티티의 라이프사이클에 의존한다 별도로 persist 및 update, remove 할 필요 없다. 영속성 전이(Cascade) + 고아객체제거 기능을 필수로 가진다고 볼 수 있다. 조회 값 타입 컬렉션도 지연로딩 전략 사용 수정 치킨 -&gt; 한식 1234MemberForEmbeded findMember = em.find(MemberForEmbeded.class, member.getId());findMember.getFavoriteFoods().remove(\"치킨\");findMember.getFavoriteFoods().add(\"한식\"); immutable해야한다. 치킨을 지우고 한식을 새로 넣어줘야한다. 컬렉션의 값만 변경해도 JPA가 알아서 날려준다. Address 변경 equals메소드를 값 비교로 잘 구현 해놓으면, 같은 값을 가지는 값 객체를 remove메소드에 넣었을 때, 삭제된다. 12findMember.getAddressHistory().remove(new Address(\"old1\", \"street\", \"1000\"));findMember.getAddressHistory().add(new Address(\"new1\", \"street\", \"1000\")); 그러나 실행된 query를 살펴보면…old1에 대한 데이터만삭제하고 new1을 추가해주는 쿼리가 아니고모든 데이터를 삭제하고 새로 추가를 해준다. 값 타입 컬렉션의 제약사항 값 타입은 엔티티와 다르게 식별자 개념이 없다. 값을 변경하면 추적이 어렵다. 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야한다. (null 입력 X, 중복저장 X) @OrderColumm(name = &quot;address_history_order&quot;) 등을 사용하면 순서값이 컬럼에 같이 저장되며, 모두 지우고 새로 입력해주는 동작이 아닌 update문을 사용하여 동작하지만, 이로인해 발생하는 사이드 이펙트가 많음으로 사용하지 않는것을 추천한다. 값 타입 컬렉션 대안 실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려 일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용 영속성 전이(Cascade) + 고아 객체 제거를 사용해서 값 타입 컬렉션 처럼 사용 정말 단순한 내용일 때만, 값 타입 컬렉션을 사용한다. 나머지는 엔티티로 만들어서 사용하자. 엔티티타입르로 승급 사용예시 AddressEntity 12345678910111213@Entity@Table(name = \"address\")public class AddressEntity { @Id @GeneratedValue private Long id; private Address address; public AddressEntity(String city, String street, String zipCode) { this.address = new Address(city, street, zipCode); }} Member 12345678910111213@Entitypublic class MemberForEmbeded { @Id @GeneratedValue private Long id; @Column(name = \"name\") private String username; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) @JoinColumn(name = \"member_id\") private List&lt;AddressEntity&gt; addressHistory = new ArrayList&lt;&gt;();} insert 1member.getAddressHistory().add(new AddressEntity(\"old1\", \"street\", \"1000\")); 영속성 전이 및 고아 객체 제거 옵션을 사용하여 라이프 사이클 관리를 엔티티에 맡긴다. 그러나 일대다 맵핑이기 때문에 인서트 시에 업데이트 쿼리가 나간다. 엔티티 타입 vs 값 타입 엔티티 식별자 생명 주기 관리 공유 값 타입 식별자 X 생명주기를 엔티티에 의존 공유하지 않는것이 안전 (복사해서 사용하자.) 불변 객체로 만들어야한다. 주의사항 값 타입은 정말 값 타입이라 판단될 때만 사용 엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨 식별자가 필요하고, 지속해서 값을 추적, 변경해야 한다면 그것 은 값 타입이 아닌 엔티티","link":"/2019/12/22/JPA/ORM-JPA09/"},{"title":"ORM11 - 객체지향 쿼리언어2 중급문법(경로표현식, 페치조인, 다형성쿼리(상속), NamedQuery, 벌크연산, @BatchSize)","text":"자바 ORM 표준 JPA 프로그래밍 - 기본편객체지향 쿼리언어2 - 중급 문법JPQL - 경로 표현식 점(.)을 찍어 객체 그래프를 탐색하는 것 상태 필드(state field) : 단순히 값을 저장하기 위한 필드 연관 필드(association field) : 연관관계를 위한 필드 단일 값 연관 필드 : 대상이 엔티티 @ManyToOne @OneToOne 컬렉션 값 연관 필드 : 대상이 컬렉션 @OneToMany @ManyToMany경로 표현식 특징 상태 필드 : 경로 탐색의 끝, 더이상 탐색이 불가능 단일 값 연관 경로 : 묵시적 내부 조인(inner join) 발생, 탐색이 더 가능하다. 실무에서는 묵시적인 내부조인이 발생하지 않도록 쿼리를 짜야한다… 튜닝이 어려움. SQL과 비슷하게 JPQL을 짜야한다. 컬렉션 값 연관 경로 : 묵시적 내부 조인 발생, 더이상 탐색이 불가능 FROM 절에서 명시적인 조인을 통해 별칭을 얻으면 별칭을 통해 탐색이 가능하다. 명시적 조인, 묵시적 조인 명시적 조인 : join 키워드를 직접 사용 1SELECT m FROM Member m join m.team t 묵시적 조인 : 경로 표현식에 의해 묵시적으로 SQL 조인 발생(내부 조인만 가능) 1SELECT m.team FROM Member m 경로 표현식 예제 select o.member.team from Order o -&gt; 성공 select t.members from Team -&gt; 성공 select t.members.username from Team t -&gt; 실패 컬렉션 값 연관경로는 추가 탐색 불가능 select m.username from Team t join t.members m -&gt; 성공 FROM절에서 명시적 조인사용 경로 탐색을 위한 묵시적 조인 주의사항 항상 내부 조인 컬렉션은 경로 탐색의 끝, 명시적 조인을 통해 별칭을 얻어야함. 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM(JOIN)절에 영향을 준다. 묵시적 조인은 사용하지 않고, 명시적 조인을 사용하는것을 권장한다. JPQL - 페치조인 SQL 조인 종류가 아니다. JPQL에서 성능 최적화를 위해 제공하는 기능 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능 join fetch 명령어 사용 페치 조인 ::= [ LEFT (OUTER) | INNER ] JOIN FETCH 조인경로 엔티티 페치 조인 회원을 조회하면서 연관된 팀도 함께 조회(SQL 한 번에) 예시 JPQL 1SELECT m FROM Member m join fetch m.team SQL 123SELECT m.*, T.* FROM Member m INNER JOIN TEAM tON m.team_id = t.id 예시 join N+1 문제가 발생한다. join fetch 한 번에 쿼리를 날린다.(N+1문제가 발생하지 않는다.) 컬렉션 패치 조인 데이터 중복 발생 왜? 조회 ROW가 두개 나오기 때문에같은 주소값을 가진 결과가 두 줄나온다. 페치 조인과 DISTINCT SQL의 DISTINCT는 중복된 결과를 제거하는 명령 JPQL의 DISTINCT SQL에 DISTINCT를 추가 애플리케이션에서 중복된 엔티티 제거 SQL에 DISTINCT 만으로는 데이터가 다르므로 중복제거가 되지 않는다. 애플리케이션에서 중복 제거 시도 결과 페치 조인과 일반 조인의 차이 일반 조인 실행 시, 연관된 엔티티를 함께 조회하지 않는다. join은 나가되 select 절에서 포함하지 않음 JPQL은 결과를 반환할 때, 연관관계를 고려하지 않는다. 단지 SELECT 절에 지정한 엔티티만 조회한다. 페치 조인을 사용할 때만, 연관된 엔티티도 함께 조회(즉시로딩) 페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념 대부분의 N+1문제를 페치 조인으로 해결한다. 패치 조인의 특징과 한계 패치 조인 대상에는 별칭을 줄 수 없다. 하이버네이트는 가능, 가급적 사용하지 않는것이 좋다. 연관관계가 여러개 일때, join을 하기 위해서만 사용하자. 1234# 예시select t From Team tjoin fetch t.members mjoin fetch m.something s 둘 이상의 컬렉션은 패치 조인 할 수 없다. 데이터가 잘 안맞는다. 컬렉션을 패치 조인하면 페이징 API(setFirstResult, setMaxResult)를 사용할 수 없다. 일대일, 다대일 관계들은 페치조인해도 페이징 가능 하이버네이튼 경고 로그를 남기고 메모리에서 페이징(전체를 조회..매우위험) 다대일로 변경하여 페치조인하여 해결하거나, @BatchSize(size = 100) 를 사용하여 레이지 로딩 시, 사이즈만큼 IN 쿼리를 날려 한번에 조회가 가능하다. size는 보통 1000이하로 크게잡는다. N + 1을 해결하는 방법중 하나 실무에서는 글로벌 세팅으로 사용한다. @BatchSize를 안써도된다. 연관된 엔티티들을 SQL한번으로 조회(성능 최적화) 글로벌 로딩 전략보다 우선 순위로 적용된다. @OneToMany(fetch = FetchType.LAZY) 보다 우선.. (실무에서 글로벌 로딩전략은 모두 지연 로딩으로 적용) 최적화가 필요한곳은 페치 조인 적용 JPA 성능문제의 70~80% 는 페치조인으로 해결할 수 있다. 페치조인 - 정리 페치 조인은 객체그래프를 유지할 때 사용하면 효과적 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야하면, 패치조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적 예를들면 통계 데이터 JPQL - 다형성 쿼리 아래 예제 공통 TYPE 조회 대상을 특정 자식으로 한정 예) item 중 Book과 Movie를 조회하라 JPQL 12select i from Item iwhere type(i) IN (Book, Movie) SQL 12select i.* from Item iwhere i.DTYPE IN ('B', 'M') TREAT(JPA2.1) 자바의 타입 캐스팅과 유사 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용 FROM, WHERE, SELECT (하이버네이트 지원) 사용 예) 부모 : Item , 자식 : Book JPQL 12select i from Item iwhere treat(i as Book).author = 'kim' SQL 12select i.* from Item iwhere i.DTYPE = 'B' and i.author = 'kim' 상속관계 매핑 전략에 따라서 쿼리는 다르게 나간다. JPQL - 엔티티 직접 사용 JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본 키값을 사용한다. JPQL 12select count(m.id) from Member m; select count(m) from Member m; 전자는 엔티티 아이디를 사용, 후자는 엔티티를 직접사용 SQL 1select count(m.id) as cnt from Member m; 둘 다 같은 SQL이 실행됨. 엔티티를 파라미터로 전달 자동으로 식별자를 전달한다. 엔티티 직접 사용 - 외래 키 값 마찬 가지로 식별자를 전달 JPQL - Named 쿼리 미리 정의해서 이름을 부여해두고 사용하는 JPQL 사용 정적 쿼리만 가능하다. 어노테이션, XML에 정의 애플리케이션 로딩 시점에 초기화 후, 재사용 애플리케이션 로딩 시점에 쿼리를 검증 배포 전에 알 수 있다. SpringDataJpa에서 인터페이스 위에 @Query로 정의된 쿼리가 NamedQuery로 등록한다. 어플리케이션 로딩 시점에 파싱을 하여 SQL 문법 오류를 잡아준다. 이름없는 NamedQuery라고 불린다. Named 쿼리 환경에 따른 설정 XML이 우선권을 가진다.(어노테이션 보다) 애플리케이션 운영 환경에 따라 다른 XML을 배포할 수 있다. JPQL - 벌크연산 여러데이터를 수정 삭제하는 작업 재고가 10개 미만인 모든상품의 가격을 10% 상승하려면? JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행 전체 리스트 조회 상품엔티티 가격 변경 트랜잭션 커밋 시점에 변경 감지하여 동작 변경된 데이터가 100건이라면 100번의 UPDATE SQL 실행 쿼리 한번으로 여러 테이블의 로우를 변경 executeUpdate() 메소드 사용으로 벌크연산이 가능하다. result는 적용된 숫자 UPDATE, DELETE 지원 INSERT(insert into .. select )는 하이버네이트에서는 지원한다. 벌크 연산 주의 영속성 컨텍스트를 무시하고 데이터 베이스에 직접 쿼리 데이터가 꼬일 수 있다. 해결책 벌크 연산을 먼저 실행 먼저 실행하지 못하면 벌크연산 수행 후 영속성 컨텍스트 초기화 플러쉬는 상관이 없다. 벌크연산도 JPQL이 실행되고 쿼리가 나가기 때문에플러쉬가 된다. 벌크연산 전에 flush가 자동 호출된다. em.flush() 가 없어도 flush 된다. em.clear() 는 반드시 필요 Spring Data Jpa 에서는 Modifying Query를 제공한다. 이 또한, 영속성컨텍스트를 자동으로 clear 해주지 않는다.","link":"/2020/02/20/JPA/ORM-JPA11/"},{"title":"웹 어플리케이션 서버,Servlet, JSP","text":"KOSTA DAY38JSP 웹 어플리케이션 서버setting 상기내용을 체크시 web.xml이 생성된다. 웹 어플리케이션의 동작원리 클라이언트와 서버의 요청과 응답 관계속에서 이루어진다. 클라이언트는 서비스를 요청하는 사용자가 되고 서버가 제공해 주는 서비스를 클라이언트가 응답 받으면 웹 브라우저에 결과화면으로 출력된다. 웹 어플리케이션 동작 순서 사용자가 웹 브라우저의 주소 란에 특정 사이트의 주소를 입력하게 되면 웹 브라우저가 해당 웹 서버에 홈페이지를 요청하는 것이 된다. 해당 웹 서버에는 웹 브라우저의 요청이 있을 경우 이를 받아들여 요청한 페이지를 응답할 책임을 지고 있다.요청한 페이지는 웹 서버에서 바로 공급되지 못하고 웹 어플리케이션 서버(WAS : Web Application Server)에서 다양한 로직이나 데이터베이스와의 연동을 통해서 완성되어야만 공급된다. 웹 어플리케이션 서버(WAS)는 웹 서버가 클라이언트에게 제공할 페이지를 완성하기 위해서 이에 필요한 로직이나 데이터베이스와의 연동과 데이터 처리를 담당한다. 로직이나 데이터베이스 작업 처리 결과를 웹 서버에게 보낸다. 웹 서버는 이 결과를 다시 클라이언트 측 웹 브라우저에 응답하게 된다. 웹 어플리케이션의 구성요소 웹브라우저 : 사용자(클라이언트)가 요청한 웹서버의 결과를 화면에 출력해 볼 수 있도록하는 어플리케이션 웹서버 : 요청을 받아 이에 알맞는 결과를 웹브라우저에 응답해주는 역할을한다. 요청에 필요한 페이지의 로직이나 데이터베이스와의 연동을 위해서 어플리케이션 서버에 이들의 처리를 요청한다. 웹 어플리케이션 서버 : 요청한 페이지의 로직이나 데이터베이스와의 연동을 처리하는 부분 데이터 베이스 : 데이터를 정보를 저장하는 곳 예를 들어 회원의 정보나 게시판에 올린 글에 대한 정보 등을 저장한다. 자바의 web 기술 J2SE(Java 2 Standard Edition) J2EE(Java 2 Enterprise Edition) J2ME(Java 2 Micro Edition)이중에서도 서블릿과 JSP는 J2EE를 구성하는 기술 중 하나이다.최근에는 서블릿 및 JSP 를 사용하지 않지만, 현재 국내에서는 많이 사용한다. J2EEJ2EE는 클라이언트/서버 환경이나 웹 환경의 서버 단에서 수행되는 프로그램을 자바로 구현하고자 할 때 사용하는 자바 기술이다. JSP는 html코드 안에 java 언어를 포함한다. servlet는 java 코드안에 html코드를 포함한다. JSP와 servlet은 사실상 같다.WAS는 JSP에 작성된 코드를 자동으로 servlet코드로 변환한다. 출력은 JSP, 요청을 받는것은 servlet이 적합하다. Servlet 서블릿이란 서블릿 클래스로부터 만들어진 객체이다. 서블릿 클래스는 javax.servlet.http.HttpServlet 클래스를 상속하도록 만들어야 한다. 클래스는 public 으로 만들어야 한다. javax.servlet.http.HttpServletRequest 와 javax.servlet.http.HttpServletResponse 타입의 파라미터를 받아야 하고 메서드 밖으로 javax.servlet.ServletException 과 java.io.IoException 을 던질 수 있도록 선언해야 한다. 예제 servlet은 java언어로 이루어져있기 때문에 출력을 위해서는 위의 예제 내용과 같이 html언어로 print 해야한다. ‘@webServlet(“/HelloServlet”) 에 hello라는 url주소를 추가하기 위해서 → ‘@WebServlet({“/HelloServlet”, “/hello”}) 로 변경하였다. 상기내용과 같이 서블릿에서 출력을 하기위해서는 불편한 부분이 많다.때문에 jsp를 사용하여 보다 편하게 출력하는 방법에 대해 알아보자. &lt;% %&gt; 사이에 Java 코드 입력하여 사용한다. 출력 시, &lt;%= %&gt;사이에 출력할값을 지정한다. 앞서 Servlet은 요청을 받는것에, JSP는 출력에 적합하다고 언급을 한 적이 있다. 그 방법에 대해 알아보자 먼저 값을 입력받을 input태그를 만들기 위해 jsp를 사용하여 만들었다. 받은 입력값을 관련 servlet 주소로 전송한다. servlet안에서 해당 결과값을 계산하고 결과값을 Dispatcher를 사용하여 결과값을 출력할 JSP를 연결한다. 여기서 만약 Dispatcher가 아닌 Redirect를 사용하였다면 어떻게 될까? 상기 예시와 같이 sendRedirect를 사용 시, 다른 request객체를 가지기 때문에 값이 나오지 않는다. Dispatcher 사용 시, 결과값을 출력하는 url은 input에서 요청한 페이지Redirect 사용 시, 결과값을 출력하는 url 을 가진다. JSPJSP기술에서 웹애플리케이션을 구현할 때, 작성하는 코드 HTML문서의 사이에 JSP문법의 코드가 삽입되는 형태 웹 컨테이너는 JSP 페이지 전체를 서블릿 클래스의 소스 코드로 변환하고, 다음에 소스 코드를 컴파일 후 결과를 가지고 서블릿 객체를 만들고 서블릿 객체를 초기화해서 서블릿을 만든다. 웹 브라우저로부터 URL이 왔을 때 실행되는 것은 서블릿이다. 기초문법 JSP의 문법에는 세가지 형태가 있다. &lt;% %&gt; ${ } XML태그 형태 (ex : jsp:forward\\&lt;C:if>) 지시자 &lt;% %&gt;는 지시자와 스크립팅 요소로 나누어진다. 페이지 지시자 : &lt;%@ 사전에 설정해야 하는 부분%&gt; 스크립틀릿 : Java코드가 들어가는 부분 익스프레션-표현식(출력) : &lt;%= 출력되는부분 %&gt; 지시자의 종류 모두 &lt;%@ 으로 시작하고 %&gt;로 끝나야 한다. &lt;%@ 바로 다음에는 지시자 이름이 와야하고, 지시자 이름 다음에는 여러가지 애트리뷰트가 올 수 있다. page 지시자는 JSP페이지 전체에 적용되는 정보를 기술하기 위해 사용된다. Include 지시자include의 소스가 포함된다. 페이지를 모듈화 한다. Include 지시자는 다른 JSP페이지나 HTML 문서를 불러다가 현재 JSP 페이지의 일부로 만들기 위해 사용된다. 불러온대상은 file이라는 애트리뷰트를 이용해서 지정할 수 있으며 애트리뷰트의 값은 지시자가 속하는 JSP페이지르 기준으로 상대적인 URL로 해석된다. 예제 header, menu, footer 부분을 모두 include를 사용하여 기본 페이지의 레이아웃을 구성하였다. 각 부분의 수정이 필요할경우 해당 HTML파일 또는 jsp 파일을 수정 시 전체가 수정된다. Taglib 지시자 기존의 액션태그가 아닌 사용자가 지정한 태그를 사용한다. Taglib 지시자는 JSP문법 중 하나인 액션을 사용할 때 필요하다. Taglib 지시자는 액션이 속한 라이브러리를 설치해야만 사용할 수 있다. JSP 내장변수(객체) JSP 페이지의 내장변수는 선언하지 않고도 사용할 수 있는 변수이다. 예제 application은 내장객체 application.getRealPath(path)를 통해 path(/message/notice.txt) 절대적 주소를 fullpath변수에 저장한다. 해당 텍스트파일의 내용이 없을때까지 내용을 출력한다.","link":"/2018/12/27/JSP/JSP01/"},{"title":"JSP액션, useBean/setProperty, 한글처리, JDBC, DAO/DTO, mybatis","text":"KOSTA DAY39JSP JSP액션자바 코드에 의해 객체를 생성하고 사용하는 것이 아니라 태그를 이용하여 객체의 생성하고 사용하는 것 → JSP 태그 or JSP 액션 scope * 객체가 사용될 수 있는 범위(Life cycle) page : pageContext에 저장 request : HttpServletRequest에 저장 session : HttpSession에 저장 application : ServletContext에 저장 useBean/setProperty useBean : 자바빈 객체를 생성한다. setProperty : 자바빈에 속성값을 부여한다. name 속성에 기술된 이름이 jsp:useBean을 이용해서 먼저 정의해야한다. input 태그의 name 과 객체내 필드의 name과 동일 할 경우에만 사용 가능하다.J 예제 useBean 액션태그를 사용하여 register JavaBean객체를 생성 setProperty 태그를 사용하여 form으로부터 받은 내용들을 담는다.(form의 input_name과 객체의 name이 같아야한다.) RegisterDao클래스의 insertRegister 메소드를 호출하여 해당 객체의 내용들을 출력한다. 한글처리 get방식 → server.xml 의 Connector를 찾아서 해당 내용을 추가한다.&lt;Connector URIEncoding=”UTF-8”/&gt;서버에 publish to the server 버튼을 실행한다. post방식 → servlet에 해당 내용을 추가한다.request.setCharacterEncoding(“utf-8”); JDBC JDBC란, Java가 DB(data base)와 통신할 수 있게 해주는 API 이다. setting eclipse에서 Oracle의 API를 이용하기위해서 Oracle 라이브러리를 eclipse 복사한다.(해당 라이브러리는 oracle 홈페이지에서 다운로드 가능) JDBC실행 순서 driver 로딩 → connection연결 → Statement생성 → query문 작성 → query문 처리 예제 driver, url주소 설정 연결할 DB의 id, password 입력 executeUpdate() 문 사용하여 query문 처리executeUpdate → 생성,수정,삭제 / executeQuery → 읽기(select문) 역순으로 close(); PreparedStatement 앞서 statement를 사용한 방식과 유사하나 쿼리문을 ‘?’를 활용하여 그 후 PreparedStatement를 생성한다. 예제 추 후 선언할 내용들에대해 ‘?’를 활용하여 sql문을 작성한다. prepareStatement를 생성하고, 그후 setString메소드를 통해 ‘?’에 들어갈 값을 설정한다. 역순으로 close(); 내가 해당예제를 풀며 생각한 주의사항은 ?를 입력할 시 ‘ ’를 생략하고 넣어야한다는 것이다.나는 pstmt를 활용하여 sql문 작성 시, ‘?’ 로 작성하여 해결하기 위해 오랜시간을 소요했다.또한 connection, Statement(prepareStatement), resultset을 반드시 close()해야 한다는것을 주의하자.(역순으로) DAO/DTO DAO (Data Access Object) : DB에 접근(통신)하는 객체 DTO (Data Transfer Object) : DB의 data를 Java의 Data로 변환시키기 위한 객체 (VO라고도 부른다.) 예제 DTO → Board클래스 생성 DAO → 객체 생성시 오라클 드라이버 로딩insertBoard 메소드 해당 data를 추가하는 내용을 JDBC 활용하여 작성 제목/글쓴이/내용 작성한 내용을 form_action3.jsp에 넘겨준다. form_action3는 넘겨받은 내용을 useBean 액션태그를 사용해 bean객체를 생성하여 담는다. 담긴 객체를 파라미터 값으로 하여 insertBoard 메소드 호출 상기 예제를 보면 알 수 있듯이, 추 후에 사용자는 노란색 박스부분 처럼insertBoard메소드를 호출하는것으로 게시물들을 추가 할 수 있다 mybatis개발자가 지정한 SQL, 저장프로시저 그리고 몇가지 고급 매핑을 지원하는 퍼시스턴스 프레임워크 JDBC로 처리하는 상당부분의 코드와 파라미터 설정 및 결과 매핑을 대신해준다. 데이터베이스 레코드에 원시타입과 Map 인터페이스 그리고 자바 POJO를 설정해서 매핑하기 위해 XML과 애노테이션을 사용할 수 있다. XML에서 SqlSessionFactory 빌드하기 모든 마이바티스 애플리케이션은 SqlSessionFactory 인스턴스를 사용한다. SqlSessionFactory인스턴스는 SqlSessionFactoryBuilder를 사용하여 만들 수 있다. SqlSessionFactoryBuilder는 XML설정 파일에서 SqlSessionFactory인스턴스를 빌드 할 수 있다. 설정을 위해 클래스 패스 자원을 사용하는 것을 추천하나, 파일 경로나 file://URL 로부터 만들어진 InputStream인스턴스를 사용할 수도 있다. 마이바티스는 클래스패스와 다른위치에서 자원을 로드하는 것으로 좀 더 쉽게 해주는 Resources라는 유틸성 클래스를 가지고 있다. 상기 내용은 POOLED 타입으로 설정 된 mybatis-config.xml 이다.해당내용을 JNDI타입으로 변경하면 아래와 같이 가능하다. url, username, password등 DB연결을 위한 정보들을 server/context.xml의 태그 안에 추가한다. 추가한 Resource의 name을 mybatis-config.xml에 맞추어 준다. 작성된 xml은 상기예시와 같이 사용된다. xml파일의 내용을 가져올 InputStream 객체 생성 후 Resource내용을 가져온다. SqlSessionFactoryBuilder()함수를 호출하여 담은내용을 build한다. 이렇게 만들어진 SqlSessionFactory를 DB에 연결이 필요할때 마다, openSession()하여 사용하고, 사용을 마친후 close()해준다. tiptry($){내용} → $의 위치에 openSession해줄경우 자동으로 close된다. Mapping mapping을 위한 interface객체가 필요하다. 생성된 interface 객체의 주소를 참조하는 xml파일을 생성하고 DB에서 실행할 Query문들을 매핑한다. 인터페이스 객체는 리턴타입 및 파라미터값만 선언한다. xml파일에 매핑 #{}를 사용하여 파라미터값 or 파라미터 객체안의 값들을 사용 return 타입을 int로 선언한 이유는 DB수정 시, commit을 하기 위해서 이다. 상기예시와 같이 선언 및 매핑한 함수를 사용한다. SqlSession.getMapper(인터페이스객체.class).선언함수; int re 로 결과값을 받는다.if(re == 1) → 정상 구현실패시, 초기화값 re = -1 정상 구현 됬을 시, commit 아닐경우 rollback typeHandlerDB의 자료형을 적절한 Java 자료형으로 변화하기 위해 사용한다. CRUD타입내장메소드를 사용한다. selectone : 하나의 데이터를 가져온다. selectone(String queryid) → 쿼리문을 통해 데이터를 가져온다. selectone(String queryid, Object parameter) → 쿼리문에 파라미터값을 대입하여 데이터를 가져온다. selectlist : 하나이상의 데이터를 가져온다. update : 수정 delete : 삭제 insert : 삽입 DML(insert, update, delete) 사용 시, 트랜잭션 처리가 반드시 필요하다. SQL코드 재사용중복되는 query문을 include해서 사용 가능하다. Result 매핑DB컬럼과 객체필드의 name이 다를 때, resultMap을 사용하여 매핑할 수 있다.(아래 예시는 DB의 컬럼과 객체필드의 name이 같으므로 올바른 예제는 아니다.) 동적 Query문 (동적 SQL) DB에 전달할 파라미터값을 두개이상 넣어야할때는 객체화를 시키거나 hashmap을 만들어서 전달해야한다. area객체가 있다면 item에 area값을 담는다. open, close는 쿼리문의 양끝에 붙으며, item이 2개이상의 경우 separator로 구분한다. item에 담겨져있는 내용은 원래 literal(문자)형으로 나와야 하는 부분이기 때문에 #이 아닌 $을 사용하여 호출한다.상기 예시에 작성된 query문은 밑줄 친 부분의 sql query문과 같은 내용이다. getParameterValues(name) : 같은 name의 여러값들을 가져올때 사용한다. searchKey 양 끝에 %를 담은 이유는 query문의 일부를 String 으로 저장하기 위해서 이다.","link":"/2019/01/02/JSP/JSP02/"},{"title":"면접 예상질문_JSP","text":"KOSTA DAY38JSP 면접에 많이 나오는 질문WAS란 ? WAS(Web Application Server)웹 어플리케이션 서버 : 요청한 페이지의 로직이나 데이터베이스와의 연동을 처리하는 부분이다. 웹프로그램을 실행할 수 있는 기초적인 환경을 제공한다. JSP와 Servlet의 관계 같은 것이라고 봐도 무방하다.그러나, JSP는 마크업언어(html)에 Java코드가 포함되는것이고Servlet은 Java코드에 html언어가 포함된것으로Servlet은 요청과 비지니스 처리, JSP는 출력에 적합하다. Dispatcher 와 Redirect의 차이점 Dispatcher는 연장된 요청 Redirect는 새로운 요청 (새로운 request객체를 생성)","link":"/2018/12/28/JSP/JSP-Interview/"},{"title":"Cookie, Session,익스프레션, JSTL, 필터","text":"KOSTA DAY41JSP Cookie쿠키 기술은 전달한 데이터를 웹 브라우저로 보냈다가 웹 서버 쪽으로 되돌려 받는 방법을 사용한다. 첫 번째 웹 컴포넌트가 웹 브라우저로 HTML 문서를 보낼 때 전달한 데이터를 함께 보내며, 웹 브라우저는 데이터를 저장해 두었다가 두 번째 웹 컴포넌트를 호출할 때 URL과 함께 웹 서버로 보낸다. 새로운 쿠키 데이터를 저장하는 방법 Cookie 클래스의 객체를 만든다. addCookie 메서드를 호출해야 한다. Cookie 클래스는 javax.servlet.http 패키지에 속하며, 클래스의 객체를 만들 때는 쿠키의 이름과 값을 파라미터로 넘겨줘야 한다. 파라미터는 모두 String 타입이 되어야 하므로 쿠키의 값이 수치일 경우 문자 데이터로 만들어줘서 넘겨줘야 한다. addCookie 메서드를 호출할 때 웹 브라우저로 쿠키를 보내는 기능을 하며, JSP 페이지에서는 response 내장 객체애 대해, 서블릿 클래스에서는 doGet, doPost 메서드의 두 번째 파라미터에 대해 호출 한 후 Cookie 객체를 파라미터로 넘겨줘야 한다. 메서드를 통해 웹 브라우저로 전송된 쿠키를 실제로 저장하는 일은 웹 브라우저가 하도록 되어 있다. 웹 브라우저가 쿠키를 저장할 때 웹 서버의 주소도 함께 저장해 놓는다. 예제로그인 성공 시, 쿠키가 저장되는 과정을 보자. m_name(“홍길동”)을 쿠키에 담기위해 utf-8로 encode한다. new 연산자를 사용하여 쿠키를 생성하고 name값을 담는다. 저장된 쿠키를 활용하는 작업에 대해 보자. 저장된 쿠키를 쿠키배열(cookies)에 담는다. cookies에 담긴 쿠키의 값이 null일 경우 → loginform으로 다시 이동null이 아닌경우 → cookies에 담긴 쿠키의 값을 꺼내어 decode한 후, name에 담는다. null이 아닌경우에도 cookies에 담긴 값이 하나이거나, JSESSIONID인 경우에는 loginform으로 다시이동 로그아웃 시, 쿠키를 삭제하는 작업을 보자. cookies에 담긴 쿠키들의 setMaxAge를 0으로 세팅(쿠키 유지 시간) 세팅된 쿠키값으로 쿠키값을 덮어쓴다. Session세션 기술은 웹 브라우저를 거치지 않고 웹 서버에 있는 데이터 영역을 통해 데이터를 전달하는 방법이다. 세션과 쿠키의 차이점 쿠키 : 사용자의 정보를 클라이언트쪽에 저장 세션 : 사용자의 정보를 서버쪽에 저장 세션기술의 사용방법 getSession메서드가 리턴한 HttpSession 객체에 대해 setAttribute라는 메서드를 호출하면 세션 데이터 영역에 데이터를 저장할 수 있다. HttpSession 객체에 대해 getAttribute라는 메서드를 호출하면 세션 데이터 영역의 데이터를 가져올 수 있다. 메서드는 데이터 이름을 파라미터로 받고, 그에 해당하는 데이터 값을 리턴한다. 주의 할 점은 메서드의 리턴 타입은 java.lang.Object 이므로 데이터 값을 본래의 타입으로 사용하려면 다음과 같이 캐스트 연산을 해야 한다. 세션을 이용해서 할 일을 모두 마치고 나면 invalidate라는 메서드를 호출해서 세션을 끝낼 수 있으며, 메서드는 HttpSession 객체에 대해 호출해야 한다. 서블릿 클래스에서 세션을 시작하기 위해서는 doGet, doPost 메서드의 HttpServletRequest 파라미터에 대해 getSession이라는 메서드를 호출해야 한다. 메서드는 세션 정보를 포함하는 javax.servlet.http.HttpSession 타입의 객체를 리턴한다. JSP 페이지에서는 JSP 페이지가 서블릿 클래스로 변환될 때 메서드를 호출하는 코드가 자동으로 추가 되기 때문에 getSession 메서드를 호출 할 필요가 없다. 예제로그인 성공 시, 정보를 세션에 저장하는 작업을 보자. getParameter로 받은 데이터를 name이라는 이름을 가진 session에 저장 상기예시는 jsp 페이지 임으로 getSession작업이 필요하지 없다. session에 저장된 데이터 활용방법에 대해 보자. 저장한 session에서 값을 꺼내어 name변수에 담는다. 로그아웃 시, session끝내기 작업에 대하여 보자.(저장된 data삭제) invalidate함수를 호출하여 저장된 데이터들을 삭제한다. 익스프레션 언어익스프레션 언어는 JSP 규격서가 처음 만들어질 때부터 있던 문법이 아니라 새롭게 추가된 문법이며, 이 문법을 이용하면 데이터를 출력하는 코드를 함축적이고 간결하게 구사할 수 있어 코드의 가독성과 유지보수 용이성에 큰 도움이 된다. 익스프레션 언어(expression language)란 같은 식을 중심으로 코드를 기술하는 언어이다. 연산자와 피연산자의 조합을 ${와}로 둘러싸서 표현한다. 익스프레션 언어의 유일한 목적은 식을 계산해서 그 결과를 출력하는 것이기 때문에 하나의 문법으로 효현할 수 있으며 이 문법을 EL식이라고 부른다. ‘식’위치에는 데이터 이름 하나로만 구성된 식이 들어갈 수도 있고, 연산자를 포함하는 식이 들어 갈 수도 있으며, 자바의 정적 메서드를 호출하는 식이 들어갈 수도 있다. EL 식에 있는 데이터 이름을 해석하는 순서는 사용 범위가 좁은 애트리뷰트부터 점점 더 사용 범위가 넓은 애트리뷰트 순으로 진행 된다. 순서에 상관없이 특정한 종류의 애트리뷰트를 짚어서 출력하고 싶을 때는 다음과 같이 표시하면 된다.(거의 사용하지 않는다.) EL식 사용방법에 대해 예제로 알아보자. forward액션태그에 저장된 param값을 호출 form으로 넘긴 data를 가져오는 방법 또한 동일하다. request.setAttribute로 넘긴 data를 호출 request.setAttribute로 넘긴 객체의 data를 호출 request.setAttribute로 넘긴 Hashmap의 data를 호출 JSTL표준 태그 라이브러리(JSP Standard Tag Library)의 약어이다. JSTL을 가지고 할 수 있는일 간단한 프로그램 로직의 구사(자바의 변수 선언, if 문, for 문 등에 해당하는 로직) 다른 JSP 페이지 호출(&lt;\\c:redirect&gt;, &lt;\\c:import&gt;) 날짜, 시간, 숫자의 포맷 JSTL이란? JSP 페이지에서 접두어를 사용하기 위해서는 taglib 지시자를 이용해서 라이브러리의 URI 식별자와 접두어를 연결할 수 있다. Taglib* 지시자는 다른 지시자와 마찬가지로 &lt;%@으로 시작해서 %&gt;로 끝난다. 지시자에는 uri와 prefix라는 두 개의 애트리뷰트를 써야 하고 두 애트리뷰트에 각각 URI 식별자와 접두어를 값으로 주어야 한다. 속성설정JSTL은 커스텀라이브러리기 때문에 Taglib를 설정해야한다. 코어 라이브러리 포매팅 라이브러리 코어 라이브러리set/out foreach redirect redirect했던 orange라는 문자값을 fruit이라는 변수에 담는다. if choosewhen otherwise는 Java 언어 if문의 else와 같다고 보면 된다. 포매팅 라이브러리formatdate formatNumber type = “currency” currencySymbol = “$” →화폐단위로 변환 및 심벌입력 type = “percent” → 소수를 %값으로 변환 pattern = “#0.00” → 소수둘째자리에서 반올림 필터글자 그대로 여과기 역할을 하는 프로그램이다. 자바 클래스 형태로 구현해야 하며, 이 클래스를 필터 클래스(filter class)라고 한다. 초기화된 필터는 웹 브라우저와 웹 컴포넌트 사이에 위치하게 된다. 웹 브라우저가 웹 컴포넌트를 호출했을 때 대신 필터가 호출될 것이고, 필터는 필요한 사전작업을 수행한 다음에 웹 컴포넌트를 호출할 것이다. filter클래스는 filter인터페이스를 implemets 해야한다. 예제 /bean/* → bean폴더의 모든 페이지에 필터를 적용필터클래스 생성 → 클래스명 입력후 Next → Filter mappings 의 Add또는 Edit를 통해 필터를 적용할 페이지를 입력한다.(@(어노테이션)을 통해서도 매핑할 수 있다.) 한글처리를 doFilter에 함으로써 매핑된 페이지들은 모두 한글처리가 적용된다. getSession을 위한 request는 HttpServletRequest/Response객체 임으로 형변환 하였다. Servlet 페이지임으로, getSession메소드 호출과정이 없어서 직접 HttpSession객체를 만들고, getSession메소드를 호출하였다.","link":"/2019/01/03/JSP/JSP03/"},{"title":"설계모델, 모델1설계방식, 모델2설계방식(MVC패턴)","text":"KOSTA DAY42JSP 설계모델 애플리케이션을 설계할 때 가장 먼저 해야 할 일은 프로그램이 해야 할 일을 적당한 크기로 나누어서 모듈화하는 것이다. JSP 규격서의 초기 버전인 JavaServer Pages– Specification 0.92에서 소개하고 있는 설계 모델인 모델 1과 모델 2에서도 웹 애플리케이션이 해야 할 일을 데이터 입력, 데이터 처리, 데이터 출력으로 구분하여 모듈화하는 방법을 제시하고 있다. 모델 1은 비교적 간단한 웹 애플리케이션에 적합한 설계 모델이며, 이 모델에서는 애플리케이션을 두 종류의 모듈로 나누어서 각각 JSP 페이지와 자바빈 클래스로 구현하도록 제안하고 있다. 모델1 설계방식모델1 개요 JSP만 이용하여 개발하는 경우 JSP + Java Bean을 이용하여 개발하는 경우 Model2의 Controller 개념이 모호 장점 개발속도가 빠름 개발자의 기술적인 숙련도가 낮아도 배우기 쉬워 빠르게 적용가능 단점 JSP페이지에서 프레젠테이션 로직과 비지니스 로직이 혼재되어 복잡 로직의 혼재로 인해 개발자와 디자이너의 작업 분리가 어려움 JSP 코드의 복잡도로 인해 유지보수가 어려워짐 웹 애플리케이션이 복잡해지고 사용자 요구가 증가함에 따 라 새로운 개발방식을 요구 모델2 설계방식모델2 개요 GUI 개발모델인 MVC를 웹 애플리케이션에 적용하여 구현한 방식 Application의 역할을 Model — View — Controller로 분리 장점 비즈니스 로직과 프리젠테이션의 분리로 인해 어플리케이션이 명료해지며 유지보수와 확장이 용이함 디자이너와 개발자의 작업을 분리해 줌 단점 개발초기에아키텍처디자인을위한시간의소요로개발기간이늘어남(개발자가 설계할경우) ( 요즘에는 프레임워크 사용한다. -&gt; 틀이 짜여있음) MVC 구조에 대한 개발자들의 이해가 필요함 Model Business Logic을 담당한다. → Java Bean으로 구현 Business Service(Manager) →Business Logic의 workflow를 관리 DAO (Data Access Object) → Database와 연동하는 Business Logic을 처리. View Client에게 응답을 처리한다. → JSP로 구현 Controller 클라이언트의 요청을 받아 Model과 View사이에서 일의 흐름을 조정한다. Servlet Client의 요청을 받아 Client가 보낸 Data를 읽고 검사한다. Model에게 Business Logic을 요청한다. Model의 처리 결과에 맞는 View에게 응답을 요청한다. 코드진행 과정 요청 Controller(Servlet) url판별 action생성 → Model(dao) → mybatis → DB Model 호출(data를 입력) View data전달 타입 결정 View path 결정 View 화면에 data 출력 주의사항 sendRedirect 를 사용하는것은 mvc패턴 사용의 의미가 없다.모든요청은 Controller가 받아야한다. 어노테이션 or Servlet(Controller)생성시 설정ex) *.do → 페이지 내 모든 .do 호출 시 예제 페이지 로딩 시, → list.do로 이동 request.getRequestURI 를 통해 전체 URI호출→ /MVC/list.do getContextPath를 통해 프로젝트 네임→ /MVC requestURI.subString(ContextPath.length +1) → list.doContextPath.length +1 = 5 command가 list.do와 일치한다면, action클래스를 implemets하는 ListAction을 생성한 후, 오버라이딩한 execute함수를 호출한다. execute함수는 ActionForward를 리턴하는데 ActionForward객체는 전송타입을 결정할 boolean값과 이동될 경로를 결정하는 path값을 가진다. ListAction객체는 list라는 객체를 “list”에 담고 dispatcher방식으로 list.jsp로 이동한다.","link":"/2019/01/04/JSP/JSP04/"},{"title":"변수, 데이터 종류, 연산자, if/else, switch","text":"KOSTA DAY01Java 변수변수란?변수란 값을 저장할 수 있는 메모리 공간을 의미한다.(데이터를 담는 그릇) 변수의 선언데이터 타입 선언 후, 변수명 지정(ex) int n, String name, Double pi java 식별자 명명규칙명명규칙 : 변수의 이름을 정할 때, 자바언어에서 정해놓은 규칙식별자(identifier) : 클래스, 메소드, 변수 등 다양한 대상에 대해 이름이 붙어지는 경우, 그 이름을 식별자라고 한다.하나 이상의 글자로 이루어져야함.첫번째 글자는 문자이거나 ‘\\’ , ‘’ 이어야함.두번째 이후의 글자는 숫자, 문자, ‘\\’, ‘’ 이어야함.길이제한이 없음.키워드는 식별자로 사용할 수 없음.상수 값을 표현하는 단어 ‘true’, ‘false’, ‘null’은 식별자로 사용할 수 없음변수 명명 관례첫번째 문자가 소문자인 명사로 정함여러 단어로 구성된 이름의 경우 두번째 단어부터 첫글자를 대문자로 함‘_’을 쓰지 않음※관례는 지키지 않아도 컴파일에러가 발생하지 않으나, 약속이기 때문에 지 켜주는 것이 좋다. 데이터 종류기본형타입가장 기본이 되는 데이터 타입으로써 정수형, 실수형, 문자형, 불린형을 의미 정수형 : Byte, Short, int(4 byte), long(8 byte) 실수형 : Float(4 byte), double(8 byte) 문자형 : char (2 byte) boolean형 : true or false 중 한가지 값을 가질 수 있다. ( 1 byte)※String은 레퍼런스 타입 Byte → Short → int →long → float → double 우측으로 갈수록 큰범위를 가짐 형변환(Casting)을 통해 데이터 타입의 변경이 가능하다. 크기가 더 큰 타입을 작은 타입으로 바꿀 때에는 명시적으로 변환해야한다. 이것을 ‘강제형변환’ 이라고 한다. 연산자산술연산자산술을 연산할수 있는 연산자 +, -, *, /, % 증감연산자 1씩 증가 or 감소 시키는 연산자 위의 예제와 같이 전치, 후치 에 따라서 값이 달라질 수 있다. 삼항연산자 if/else조건식의 연산 결과에 따라 블록 내부 문자의 실행 여부를 결정 할 수 있다. if문 조건식이 true일 경우에만 실행문이 실행 {}를 생략가능하나, if문 다음 한 줄만 포함된다. if/else문 조건식이 true일 경우, if 블록의 실행문이 실행되고, false일 경우 else블록의 실행문이 실행된다. if/else if/else문 처음 if 문의 조건식의 조건문이 true일 경우 if문의 실행문이 실행 false일 경우 다음 조건식의 결과에 따라 실행블록이 달라진다. else if 문의 수는 제한이없으나, 많은 else if문은 속도를 저하시킴 마지막 else 블록은 생략가능 switch 어떤변수의 값에 따라서 문장을 실행할 수 있도록 하는 제어문","link":"/2018/10/29/Java/java01/"},{"title":"while, Do~while, for, 반복문","text":"KOSTA DAY02Java while 조건문의 실행결과가 true일 동안 반복해서 실행 Do while 명령문을 먼저 실행 후, 조건비교 후 반복 실행 while 문의 경우 조건을 불만족 시, 실행되지 않을 수 있다.반면 Do~while문의 경우 무조건 한번을 실행된다는 차이가 있다. for for반복문은 변수 초기화, 조건식, 증감식이 한줄에 모두 있다. 초기화식은 최초 한번만 수행 조건식을 수행하여 수행결과 false 시, for문 빠져나감 증감식 수행 ※무한루프 for, while문 반복문break문 while, for, do 문 안에서 사용되면 반복문을 빠져나가는 기능 switch문 안에서 사용되면 switch 문을 빠져나가는 기능 return 사용 시 메소드안을 나간다. for, while, Do 문 에서 사용시 반복문을 빠져나간다. 반복문을 여러개 사용 시, 바깥쪽 반복문을 빠져나가기 위해서는 상기 이미지와 같이 사용 가능(반복문 영역에 이름지정후 break 이름;) continue문 다음번 반복과정을 진행 continue문도 break문과 마찬가지로 중복되는 반복문에서 바깥쪽 반복문으로 진행을 원할 시, 하기 이미지와 같이 사용할 수 있다.","link":"/2018/10/30/Java/java02/"},{"title":"Method, 배열","text":"KOSTA DAY03Java Method필드가 물체의 상태라면, 물체의 행동에 해당하는게 메소드이다. 메소드는 입력값이 있고, 그 입력값을 받아서 무언가 한 다음 결과를 도출해 내는 수학의 함수와 비슷한 개념 이 때, 입력값을 매개변수(Parameter), 결과값을 리턴값 이라고 한다. 메소드란 클래스 가지고 있는 기능(클래스 안에서 선언됨.) 메소드화를 사용하는 이유는 중복 코드를 최소화 하고, 유지보수를 보다 용이하게 하기 위해서 이다. 배열배열은 같은 데이터 타입을 가진 연속된 메모리 공간으로 이루어진 자료구조이다. 주소값 사용(reference 타입) 같은 데이터 타입을 가진 여러개의 변수가 필요할 때 사용한다. 한 번 생성하면 배열의 크기 변경 불가 배열선언 및 생성 (상기이미지) 배열 선언과 생성을 동시 int[] arr = new int[5]; 배열 선언과 생성, 초기화를 동시 진행 int[] arr = {1, 2, 3, 4, 5};","link":"/2018/10/31/Java/java03/"},{"title":"객체지향, 필드, 생성자, Scanner 사용 시 오류해결","text":"KOSTA DAY05Java 객체지향객체지향이란? 프로그래밍 기술의 변천 기계어, 어셈블리어 사용 → 일상언어를 닮은 고급프로그래밍 언어 등장→구조적 프로그래밍 기법 등장 → 객체지향 프로그램밍 기법 등장 상호작용하는 객체들로 이루어진 현실세계를 모방 객체 상태와 행동으로 구분되어지며, 변수와 메소드로 표현될 수 있다. 객체는 클래스라는 설계도에 만들어진다. 클래스로 부터 만들어진 객체 = 인스턴스 객체를 만드는 과정 = 인스턴스화 클래스 클래스의 데이터 구조는 변수로 선언한다. 클래스의 기능은 메소드로 구현한다. new 연산자를 사용하여 객체를 생성한다. 생성된 객체는 heap영역에 생성된다.(완전히 독립된 객체) 객체명.~ : 저장된 주소값을 가져온다. 클래스는 객체의 모양을 갖춰야한다. 클래스는 객체를 무한대로 생성할 수 있다. 객체지향 프로그래밍특징 확장성 캡슐화 : 객체의 필드, 메소드를 하나로 묶고 실제 구현내용을 감춘다.(접근 지정자) 상속 : 상위객체가 하위객체에 필드와 메소드를 물려준다. 접근지정자private : 같은 클래스 내에서만 사용default : 같은 패키지 안에서만 사용protected : 같은 패키지 안에서만 사용가능하나, 그렇지 않아도 부모자식간에는 사용가능public : 누구나 사용가능 필드변수 : 생성자와 메소드 내에서만 사용, 생성자와 메소드 실행 종료 시, 자동 소멸필드 : 생성자와 메소드 전체에 사용되며, 객체가 소멸되지 않는 한 객체와 함께 존재 생성자라이브러리 클래스의 객체생성 방법 객체가 생성되고 나서 실행해야 할 명령문을 써두는 부분 클래스 안에 선언함 메소드처럼 파라미터값을 넘겨줄 수 있다. 객체를 효율적으로 초기화하는데 사용 new 연산자와 함께 자동으로 호출 객체 생성의 가이드 라인(타인이 만든 생성자 사용 시) 생성자와 메소드의 차이점 생성자는 반드시 자신의 클래스 이름과 동일 리턴형을 사용하지 않는다.(void 조차 사용 할 수 없다.) 메소드는 이름으로 호출, 생성자는 new 연산자와 함께 자동으로 호출 Overloading : 같은 이름의 메소드 또는 생성자를 파라미터값으로 구분 Scanner 사용 시, 오류 해결 scanner 사용 시, nextInt();를 통해 값을 받으면그 후, nextLine();에서 자동으론 빈 값이 입력되는것을 확인 이유 : 숫자값은 nextInt가 받으나, enter값을 그 다음 nextLine에서 처리함 해결 : 스캐너의 nextInt 사용 시, nextLine을 함께 사용","link":"/2018/11/05/Java/java05/"},{"title":"배열, 정렬, 배열복사","text":"KOSTA DAY04Java 배열 열의 생성과 선언에 관련하여 수강하였다. 향상된 for 문 123for(데이터타입 변수명 : 배열이름){ 실행문 변수명 일력시 배열값 순서대로 호출(배열의 크기만큼) } 향상된 for문 구현방법 length메소드 사용방법 배열의 index값은 0 부터 시작됨 정렬 swap 메소드를 생성하여 배열의 순서를 정렬 2차, 3차 배열도 생성이 가능하다. 3차이상의 경우 사용자가 사용하기 힘들어 거의 사용하지 않는다. 배열복사 System.arraycopy(복사할 배열, 복사시작index, 붙여넣기 배열, 붙여넣기 시작 index, 붙여넣기 끝 index)또는 for문 사용하여 복사","link":"/2018/11/02/Java/java04/"},{"title":"객체지향, 생성자, 객체 내 배열","text":"KOSTA DAY06Java 객체지향객체들간의 상호작용을 하는 현상 특징 확장성 상호작용 class가 필요하다. class는 객체의 모양을 갖추고 있어야 한다. new 연산자를 통하여 객체를 생성한다.생성자 new 연산자와 함께 자동으로 호출 객체를 초기화 하는데 사용 객체를 생성하는 가이드라인이 될 수 있다.특징 return, void를 사용하지 않는다. 자신의 class이름과 반드시 동일해야한다. public class_name () {} 를 사용하여 default오류를 대비 객체 내 배열객체 메소드 내에 배열을 생성 하는것 생성방법1class_name arr[] = {new class2_name(parameter1, parameter2)…};","link":"/2018/11/06/Java/java06/"},{"title":"접근제어자, Exception","text":"KOSTA DAY07Java 접근제어자멤버 또는 클래스에 사용되어 해당 멤버 및 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 함. 객체지향언어의 주요 특성중 하나인 캡슐화 및 정보숨김을 구현 public : 모든 클래스에 의해 접근 가능 protected : 동일 패키지 및 하위클래스 관계 접근 가능 private : 자기 자신 클래스 내에서만 접근가능 (default) : 동일 패키지 접근가능 접근제어자 설정X Exception자바에서 에러를 지칭하는 용어 try문 : Exception 처리에 사용되는 명령문 throw문 : 예외를 사용자가 고의로 발생시킨다.( ex) throw new Exception) throws문 : 발생된 예외를 처리하지 않고 상위 메소드로 전달","link":"/2018/11/07/Java/java07/"},{"title":"게시판 페이징처리, 파일 업로드/다운로드, 썸네일 이미지 게시판","text":"KOSTA DAY43JSP 게시판 페이징 처리mvc 패턴의 비지니스로직을 처리하기 위해 Service객체를 생성하여 Service 객체에서 비지니스로직을 처리하는 법에 대해 알아보자. 기존 : Client → Controller → Action → DAO → mybatis → DB Service 객체 추가 : Client → Controller → Action → Service → DAO →mybatis → DB Service 객체를 추가하여 페이징 처리 로직과 함께 게시판 리스트를 출력하는 예제를 살펴보자. 싱글톤방식을 사용하여 dao객체 및 Service 객체를 생성한다. pageSize = 게시글에 출력될 게시글의 수 countBoard메소드 실행하여 총 게시물의 갯수를 구한다. totalPageCount를 구한다.총갯수 / 출력될 게시글 → 나머지가 있을 시 +1 startPage/ endPage를 구한다.startPage : 현재페이지-(현재페이지-1)%페이징수 (1~5 →1, 6~10 →6..)(starPage +5)가 총페이지수 보다 크면 endPage = 총페이지수 startRow = 게시글의 시작 번호→ (현재페이지 -1) * 페이지당 글 갯수 listBoard메소드에 startRow값을 넣어 list를 구한다. RowBounds(int start, PAGE_SIZE) : 페이징처리 getMapper 메소드 검색된 결과에 관하여 페이징 처리를 위하여 다음과 같은 처리를 한다.searchKey(검색문자)가 null아 아니라면, search라는 값의 세션을 비운고 해당 조건 및 검색문을 set한다.serarchKey값이 null이지만 search라는 session이 존재할 경우, 생성한 search 객체에 session값을 넣어준다. 페이징처리 정보와 list객체를 필드로 가지는 listModel객체를 리턴한다.리턴한 값을 action에서 setAttribute 하고, path와 forward타입(dispatcher)을 정하여 컨트롤러에 리턴한다.컨트롤러에서 dispatcher한다. 이전아이콘 처리 다음아이콘 처리 페이지 넘버처리 현재페이지 &lt;b>태그 처리 파일 업로드 / 다운로드JSP 파일 업로드를 위한 기본적인 조건 파일을 업로드 할 때, form태그의 method = post 여야 한다. enctype : 데이터를 전송하게 될 타입을 지정하는 부분 form태그에 enctype이 명시되면 서블릿에서 request객체를 이용해서 값을 가져오지 못한다.(하나의 스트림을 통해 전송되기 때문에)스트림으로 넘어온 데이터를 getInputStream() 메소드를 사용해서 사용자가 전송한 스트림을 받아 각각 구분자를 이용하여 잘라내어 사용해야 하는데, 복잡하고 어렵다.→ MultipartRequest 를 사용한다. MultipartRequest cos.jar 라이브러리 추가가 필요하다. MultipartRequest 객체 알아보기 예제 form태그에 enctype=”multipart/form-data 설정 input type= “file”로 설정 Board객체에 filename이 들어가 변수를 추가한다. request.getRealPath(“upload”) 를 통해 저장될 경로지정upload의 절대경로 File size지정 MultipartRequst객체 multi 생성 DefaultFileRenamePolicy() : 같은 이름의 파일명 방지 처리 파일이 있으면 파일명을 보드에 담은 후 insert 다음은 다운로드 방법에 대해 알아보자. a태그를 통해 다운로드를 위한 페이지로 이동 filename을 get타입으로 가지고 간다. filename을 받아온 후 인코딩 한다. 경로를 지정한다. 다운로드 알림창이 뜨도록 하기 위해서 ContentType을 8비트 바이너리로 설정한다.response.setContentType(“application/octet-stream”); 저장파일이름을 설정한다.response.setHeader(“content-Disposition”, “attatchment;filename=\\“” + filename2 + “/””); no-cache 설정 JSP에서 No-Cache 설정하는 방법웹개발 하다보면 캐쉬된 페이지때문에 가끔 웹브라우저가 재시동하거나, 웹서버를 재시동하는 경우가 있었을 것이다. 그런 경우 캐쉬에서 불러오는 것이 아니라 항상 최신의 페이지를 보여주도록 하는 방법입니다. 데이터가 넘어가는 경우에만 ‘만료된 페이지입니다’ 라는 메시지를 보여주게 된다. 버퍼크기 설정byte[] data = new byte[8096]; 파일을 남아있으면 읽어서 data에 저장 is, os 닫아준다. 서블릿도 닫아준다. 썸네일 이미지 게시판 이미지 파일임을 파악하기 위해 fname으로부터 “.”을 기준으로 분리 uploadPath/fname 으로 경로지정 imagePath를 사용하여 File객체로 이미지를 저장 썸네일 이미지를 위해 썸네일이미지 파일을 위한 경로를 지정한다. 파일형식이 gif 일때 ImageUtil의 resize 메소드 실행 썸네일 이미지로 크기를 줄여 객체를 이미지파일을 저장한다. src파일객체를을 FileInputStream객체로 만든다. 오버로딩된 resize메소드 호출 썸네일 크기 지정 BufferedImage 객체를 사용하여 지정한 크기 및 이미지타입설정 생성한 BufferedImage 객체사용하여 2D graphics 생성 head = .jpg 등 형식을 제외한 파일명 pattern = 형식 (ex&gt; jpg, gif등) &lt;img src= “upload(파일위치)/썸네일 파일명>으로 썸네일 이미지 출력","link":"/2019/01/07/JSP/JSP05/"},{"title":"필드, 오버로딩, 오버라이딩, 상속","text":"KOSTA DAY08Java 필드정적필드 static 키워드가 붙은 필드 별도로 객체나 메소드를 생성하지 않아도 메모리가 생성된다. 클래스 이름.이름 으로 호출한다.(ex : math.random, Integer.parseInt) static 블록이나 메소드안에서 일반 멤버변수 사용할 수 없다.(메모리 생성시점이 다르다.) 상수필드 static, final 키워드가 모두 붙은 필드 상수를 구할 땐 final을 반드시 호출해야한다. 수정하지 않을 요소에 사용됨 멤버변수와 지역변수 차이점 멤버변수 → 객체가 소멸될 때 까지 사용 지역변수 → 해당 메소드 안에서만 사용 예제 grandTotal 은 정적필드 이고, total은 멤버변수이다. obj1, obj2 에 각각 accumulate시켰을 때, total의 경우 일반 멤버 변수이기때문에 서로 다른 객체인 obj1와 obj2 는 다른 total을 가진다. grandTotal은 정적필드로서 두값을 합친 30이 리턴된다. 오버로딩메소드의 이름, return값이 동일하지만 매개변수(파라미터)의데이터 타입 및 개수로 구분하는 메소드를 생성하는것을 말한다. 메소드 시그니처메소드 오버로딩의 핵심은 바로 메소드 시그니처에 있습니다.메소드 시그니처란, 메소드의 선언부에 명시되는 매개변수의 리스트를 가리킵니다.만약 두 메소드가 매개변수의 개수, 타입, 순서 까지 모두 같다면 이 두 메소드의 시그니처는 같다고 할 수 있습니다. 오버라이딩부모 클래스의 메소드를 호출하여 사용할 때, 사용자의 필요에 따라서 수정하는것을 말한다. object객체는 모든 데이터를 가질 수 있다. Java의 다형성을 표현한다. 메소드의 이름, 매개변수, 리턴타입이 같아야 한다.상속 기존 클래스와 유사한 클래스를 만들어야 하는 경우 사용된다.(확장성 용이) extends 함수를 사용하여 상속한다.(final함수를 사용한 클래스는 상속불가, 메소드 앞에 사용 시 오버라이딩이 불가능하다.) 자식을 생성하면 부모도 생성된다.(new 자식 → 자동으로 new 부모) super 함수가 없을 시, 부모의 default생성자를 생성해야한다.(default생성자를 생성하지 않으면 상속 시, 에러가 발생한다.) 초기화할 내용이 부모에게 있을 시, super 함수를 사용하여 초기화 한다. 상속관계에서 자식은 부모로 형변환이 가능하다.(즉, 부모 &gt; 자식) 상속 후, 부모로 형변환 된 자식은 오버라이딩한 메소드만 호출 가능하다. ( 부모로 형변환 되었기 때문에) 부모로 형변환 된 자식은 이미 크기가 커져서 자식안으로 들어갈 수 없다. 강제 캐스팅이 필요하다.(자식만 가지고 있는 클래스를 호출하기 위한 목적)","link":"/2018/11/08/Java/java08/"},{"title":"reference타입, instanceof, 추상클래스, 객체와 인스턴스의 차이","text":"KOSTA DAY09Java reference타입메모리상에 할당되는 각각의 공간에 참조를 위한 주소값이 들어가는 타입 String 은 reference타입 아무값도 가지지 않는 reference 와 null 값을 가지는 reference는 다르다. call by reference : 값에 의한 호출이 아닌 주소값에 의한 호출 추상클래스abstract 키워드가 붙은 클래스 인스턴스 화를 할 수 없다. (생성자가 없음 → 객체생성의 목적이 없음) 추상 클래스는 상속 시, 자식에게 반드시 오버라이딩 하도록 한다. 추상 메소드 : 메소드 본체가 없는 메소드 메소드 호출의 목적이 아닌 오버라이딩을 하기위해서 생성한다. 인스턴스객체가 실질적으로 메모리를 차지하는것객체 생성 → 인스턴스화 한다. instanceof 인스턴스의 실제 타입을 알아보기 위해서 사용된다. 형변환 가능성을 검사하는 키워드 주로 조건문에 사용된다. 객체와 인스턴스의 차이","link":"/2018/11/09/Java/java09/"},{"title":"Calendar, GregorianCalandar, Random","text":"KOSTA DAY11Java Calendar 클래스 날짜와 시간에 관련된 클래스로서, 시스템 시계로 부터 시간을 가져오는 클래스 GregorianCalendar도 사용되지만 보편적으로는 Calendar가 사용된다. 생성자가 proteted로 new를 통해 객체 생성이 불가(Calendar = 추상클래스) → getInstance() 메소드를 통해 객체를 생성한다. 주로 상수와 메소드를 활용하여 다양한 기능을 사용한다. Gregorian Calendar 클래스 Calendar 클래스의 후손 클래스로 년, 월, 일, 시, 분, 초 정보를 필드를 통해 사용가능 Calendar class와 차이점 Date 클래스 시스템으로부터 현재 날짜, 시간 정보를 가져와서 다루도록 만들어진 클래스 생성자 2개만 사용 가능 Date(long n)클래스 정수값을 가지고 날짜 및 시간을 계산 내장 메소드 Random난수를 보다 편하게 사용할 수 있도록 한다.1234Random r = new Random();int num = r.nextInt(9); // 0 &lt;= numm &lt; 9 난수 추출int num2 = r.nextInt(9)+1 // 1 &lt;= num &lt; 9 난수 추 Random의 객체를 new로 생성한 후 생성된 객체를 nextInt(); 로 사용한다.","link":"/2018/11/13/Java/java11/"},{"title":"인터페이스, Object class, Wrapper class, Inner class, Anonymous class, String API, Boxing/Unboxing","text":"KOSTA DAY10Java 인터페이스개발코드와 객체가 서로 통신하는 접점 인터페이스 안의 모든 메소드는 추상메소드이다.(굳이 abstarct 키워드를 사용하지 않아도 된다.) 인터페이스를 implements하는 클래스는 인터페이스 안의 추상메소드들을 모두 오버라이딩 해야한다. 추상클래스와 유사한 기능을 하며 자식메소드를 구현하는데 사용된다. 인터페이스를 implements한 클래스는 인터페이스에 선언한 메소드를 오버라이딩하여 사용가능하다. 인터페이스 끼리 상속가능 → 실제로는 거의 사용하지 않으나 Java API중 이러한 형택가 있다. 인터페이스를 사용하는 이유 자바에서는 다중 상속을 허용하지 않는다. 상속할 수 없는 상황에서 공통된 기능을 사용하기위해 코드의 독립성 추상클래스와 인터페이스의 공통점과 차이점 공통점 코드의 독립성 차이점 추상클래스는 일반 메소드가 있을 수 있기 때문에 추상메소드에 abstract 키워드를 사용한다. Object class 최상위 클래스 Object class의 toString 메소드는 주소값을 호출한다. → toString 메소드를 생성하여 오버라이딩 가능 Object class의 equals 메소드는 주소값을 비교한다. → 원하느 값을 비교하기 위해서는 equals메소드를 오버라이딩하여 재정의 해야한다. Wrapper classWrapper class란 상호전환 시 , 사용하는 클래스 위의 기본형 data외에는 모두 reference 타입 기본형 ← → reference 타입 상호전환이 필요할 수 있다. Boxing기본 자료형을 Wrapper 클래스의 객체로 변경하는 과정1Integer age = new Integer(30); Unboxing각각의 객체를 기본 자료형으로 변경하여 사용하는 과정1int age2 = age.intValue(); Nested Class 클래스안의 클래스라는 의미 소스의 가독성을 높이고 유지보수를 용이하게 하기위해 사용 Inner Class(내부 클래스) 클래스안에 클래스를 생성하는 것 Anonymous Class(익명 내부 클래스) 클래스를 한번만 사용하고 구현할 때, 추상클래스 및 상속없이 일회성으로 구현하기위해서 사용한다. String API 불변성을 가진다. 연산자를 통해 추가가능 StringBuffer 클래스는 append로 추가가능 .indexof(“”) : 이 몇번째인지 찾는다. (시작 = 0) .substring(n1, n2) : n1 ~ n2 까지 추출 trim() : 앞뒤 공백제거 split(“”) : 이 들어간 부분을 찾아서 *로 나누어 배열에 저장 숫자를 String으로 변환 → n + “”; endsWith() / startWith() : ~시작 or 끝나는지 체크 valueof : 형변환 시, 사용","link":"/2018/11/12/Java/java10/"},{"title":"배열정렬, 스트림","text":"KOSTA DAY13Java 배열정렬 대부분은 데이터베이스에서 정렬된 데이터를 조회하여 ArrayList에 담아서 사용하므로 ArrayList 자체를 정렬할 일이 잘 없지만 ]가끔씩 리스트를 직접 정렬해야 할일이 생긴다. 정렬하는데에는 Collections.sort(); 메소드를 사용한다. Comparable : 최초 정렬기준 된 내용을 작성한다. compareTo()를 오버라이딩한다. Comparator : 정렬된 내용을 변경하기 위해 사용한다. compare()을 오버라이딩한다. 예제1234567891011121314151617public Class Person implements Comparable&lt;Person&gt;{ private String name; private int age; //생성자, set, get 생략 @Override public int compareTo(Person p){ //p가 이후에 들어온 person if(age &gt; p.age){ return 1; 자리변경 }else if(age &lt; p.age){ return -1; } return 0; }} Person객체에 최초 정렬에 대해 오버라이딩하여 정의한다. 해당 Person객체는 오름차순으로 정렬된다. 123456789101112131415161718List&lt;Person&gt; list = new ArrayList&lt;&gt;();list.add(new Person(&quot;김자바&quot;, 10));list.add(new Person(&quot;이자바&quot;, 20));list.add(new Person(&quot;박자바&quot;, 30));list.add(new Person(&quot;최자바&quot;, 40));Collections.sort(list, Comparator&lt;person&gt;(){ @Override public int Compare(Person o1, Person o2){ if(o1.getAge() &lt; o2.getAge()){ return 1; // 자리 변경 }else if(o1.getAge() &gt; o2.getAge()){ return -1; // 자리 유지 } return 0; }}); 나이 내림차순으로 재정렬 한다. 정석은 또 하나의 클래스를 생성하여 implements comparator 해야하지만 더 쉬운 익명내부클래스로 생성이 가능하다. Stream 일차원적인 데이터의 흐름 입출력 스트림의 메소드 종류가 많은 이유 → 스트림의 종류가 여러가지이기 때문에 ( 데이터 타입 , 객체 등등) 데이터 형태에 따른 분류 문자 스트림(character stream) : reader / writer 바이트 스트림(byte stream) : inputstream / outputstream 파일 입출력의 과정 파일열기 – 파일의 데이터 읽기,쓰기 – 파일을 닫는다. java.io는 예외처리를 하지 않으면 무조건 예외 발생 시킴 node Stream : outputstream, inputstream, reader, writer 등 기초 스트림 filterstream : 입출력 기능 성능을 향상시키위해 노드스트림에 연결 직렬화 : 객체를 스트림으로 만드는 작업 역 직렬화 : 스트림을 객체로 만드는 작업 java.io.serializable 인터페이스 구현하는 클래스만 직렬화가능 (직렬화 시, 관련 객체 또한 serializable 되야한다.) transient : 직렬화해도 null값으로 연결됨 PrintStream 클래스 : 데이터를 포맷해서 파일로 출력하는 클래스 예제 reader writer Bufferd Serializable","link":"/2018/11/15/Java/java13/"},{"title":"File Class, Thread","text":"KOSTA DAY14Java File Class File 클래스 (파일의 내용이 아니라) 파일 자체를 관리하는 클래스 파일 정보를 가져오는 메소드 파일 정보를 수정하는 메소드 파일을 생성/삭제하는 메소드 디렉토리 관리에도 사용됨(디렉토리도 파일 객체) 배열로 저장 가능예제 File 디렉토리 복사 Thread(스레드) 프로그램의 실행 흐름 싱글스레드 : 스레드가 하나뿐인 프로그램 멀티스레드 프로그램 : 스레드가 둘 이상인 프로그램(멀티스레드프로그램은 어떤 스레드를 먼저 실행할지 모른다. ) Thread 클래스를 이용한 멀티스레드 프로그램 스레드로 실행 할 클래스의 선언방법 스레드 클래스를 상속받아 run 메소드를 오버라이딩한다. 스레드를 시작하기 위해서 start 메소드를 호출 (thread.start();) 멀티스레드 프로그램은 실행은 하나씩 실행된다.(아주짧은시간) sleep메소드 : 일정시간이 경과 되기를 기다리는 메소드 (예외발생이 가능하여, 반드시 예외처리르 해줘야한다.) Critical section : 스레드 실행 중 다른 스레드로 제어가 넘어가면 문제를 일으킨다.그래서 동기화를 진행하여 공유데이터를 사용하지 않게끔 해줘야 한다. implement runnable 로도 thread를 생성할 수 있다. (자바에서 상속은 하나밖에 안되기때문에 다른 클래스를 상속하는 스레드를 만들기위해서) 프로세스와 스레드의 차이점 프로세스 : 프로그램의 단위 스레드 : 프로그램 내의 실행 흐름","link":"/2018/11/16/Java/java14/"},{"title":"정규표현식, 자료구조 클래스","text":"KOSTA DAY12Java 정규표현식특정한 규칙(패턴)을 가진 문자열의 집합을 표현하는데 사용하는 표현식 언어 예제 자료구조 클래스자료구조 : 데이터를 효율적으로 사용할 수 있도록 구조를 만들어서 저장해둔 것 종류 list(리스트) stack(스택) : 제일 처음에 넣은것이 제일 나중에 나옴 queue(큐) : 처음넣은것이 처음 나옴 hashtabel(해쉬테이블) : 맵 자료구조 set(집합) : 엄밀히 말하면 자료구조가 아 ArrayList배열을 list형으로 구현하는 것 데이터 타입이 필요 → 제네릭 선언 : 코드의 일관성/사용 용이 크기는 사용에 따라 증가 삭제 시, 알아서 자리 채움 전체를 순서대로 출력할 때 가장 용이 명령어 추가 : .add(‘’) / .add(index, ‘’) 크기 : .size() 검색 : indexof(‘’) 정렬 : Collections.sort(list) Comparable : 기본 정렬기준 구현 Comparator : 다른 기준을 정의하고 구현 LinkedList인접데이터를 가르키는 식으로 구현 이웃해서 저장하지 않고 참조하여 사용하여 연결되어 있다. 주소값으로 연결 자료의 수정 삭제 시, 용이 Stack ‘후입선출’방식으로 나중에 저장된 데이터가 가장 빨리 인출된다.12345678910Linkedlist&lt;Integer&gt; stack = new LinkedList&lt;&gt;();stack.addLast(new Integer(10));stack.addLast(new Integer(20));stack.addLast(new Integer(30));while(!stack.isEmpty()){ Integer num = stack.removeLast(); System.out.prinln(num);}// 결과 : 30 → 20 → 10 Queue ‘선입선출’방식으로 가장 먼저 삽입된 데이터가 가장 먼저 제거된다. 12345678910LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();queue.offer(10);queue.offer(20);queue.offer(30);while(!stack.isEmpty()){ Integer num = queue.poll(); System.out.prinln(num);}// 결과 : 10 → 20 → 30 poll 대신 peak을 사용하면 Linkedlist의 인자는 그대로 남아있는다. Hash(Map)자료형으로서 대응관계를 쉽게 표현할 수 있도록 해준다. Key와 Value라는 것을 한 쌍으로 가진다. 순차적으로 해당 요소 값을 구하지 않고 Key를 통하여 Value를 얻는다.12345678910111213141516171819202122Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(1, &quot;SK&quot;);map.put(2, &quot;두산&quot;);map.put(3, &quot;넥센&quot;);//크기System.out.println(&quot;요소 개수 : &quot; + map.size());//제거if(map.containValue(&quot;두산&quot;){ map.remove(2);}//전체출력 (Map → Set → Iterator)Set set = map.entrySet();Iterator iter = set.iterator();while(iter.hasNext()){ Map.Entry&lt;String, String&gt; e = (Map.Entry&lt;String, String&gt;)iter.next(); //Map.Entry : 내부인터페이스 System.out.prinln(e.getKey() + e.getValue());} 참고자료 생활코딩 - Java Collections Framework 공대인들이 직접쓰는 컴퓨터 공부방 - Collections 이해","link":"/2018/11/14/Java/java12/"},{"title":"난수 생성","text":"Java난수생성 RandomStringUtils org.apache.commons.lang3.RandomStringUtils 임의의 문자 생성1RandomStringUtils.random(int count); 임의의 문자를 count 만큼 랜덤으로 생성해준다. count : 문자열의 길이 1RandomStringsUtils.random(int count, int start, int end, boolean letters, boolean number) start부터 end까지의 아스키코드 문자를 사용하여 count만큼 랜덤으로 생성해준다. count : 문자열의 길이 start : 아스키코드 처음 end : 아스키코드 마지막 letters : true 문자만 생성 numbers : true 숫자만 생성 영문 대소문자 랜덤 문자열 생성1RandomStringUtils.randomAlphabetic(int count); 영문 대소문자를 count만큼 랜덤으로 생성한다. 숫자 랜덤 문자열 생성1RandomStringUtils.randomNumeric(int count); 숫자를 count 만큼 랜덤으로 생성한다. 영문 대소문자 + 숫자 랜덤 문자열 생성1RandomStringUtils.randomAlphanumeric(int count); 대소문자, 숫자를 사용하여 count만큼 랜덤으로 생성한다. 아스키코드 문자열 생성1RandomStringUtils.randomAscii(int count); 아스키코드 32(“”) ~ 126(~)사이의 코드를 count만큼 랜덤으로 생성한다.","link":"/2019/10/26/Java/randomstringutils/"},{"title":"JSON, JunitTest","text":"KOSTA DAY15Java JSONJavascript 객체 문법을 따르는 문자 기반의 데이터 포맷 JSON은 경량의 data 교환 형식 Javascript에서 객체를 만들 때, 사용하는 표현식 문자열 형태로 존재 JSON표현식은 사람과 기계 모두 이해하기 쉬우며 용량이 작아서, 최근에는 XML을 대체해서 데이터 전송등에 많이 쓰임 특정 언어에 종속되지 않으며, 대부분의 프로그래밍 언어에서 JSON포맷의 데이터를 핸들링 할 수 있는 라이브러리를 제공 JSON라이브러리 추가 SON라이브러리 다운로드 추가할 프로젝트에서 우클릭 → Build path → Configure Build Path… JavaBuildPath → Add Library ||Add External JARs → JSON라이러리추가 ❖Maven, gradle을 통해서도 라이브러리를 추가 할 수 있다. JSON 사용법 JSONObject 객체생성 JSONArray에 JSONObject객체 담기 JSONArray → JSONcode List → JSONcode JSONArray 생성 및 추가시 simple라이브러리를 사용했으나, List에서 JSONcode로 변환 시, net 라이브러리 사용 Junit Test xUnit이란?자바만 단위 테스팅 프레임 워크인 JUnit만 있는게 아니다. 다른 언어도 단위 테스트를 위한 프레임워크가 존재하며 보통 이름을 xUnit이라 칭한다.ex) JUnit → java, CUnit → C ,CppUnit →c++ 해당프로젝트 우클릭 → new Source Folder → 생성된 폴더 → new package → 생성된 패키지→ new JUNIT Test Case assertNotNull(~) : ~ 는 null값이 나오면 비정상 assertEquals(, ~) : 과 ~의 값이 같지 않으면 비정상 정상 : 초록색 비정상 : 빨간색","link":"/2018/11/19/Java/java15/"},{"title":"JavaScript, 문법, 변수, 함수, 객체, Prototype","text":"KOSTA DAY30JavaScript JavaScript 브라우저 환경에서 사용하기 위해 나온 언어 Java와 문맥이 비슷한 프로그래밍 언어 그러나 엄연히 다른 언어이다. 서버의 영역까지 확대되었다. 비동기식 구현 동기식 : 요청과 결과가 동시에 일어남비동기식 : 요청과 결과가 동시에 일어나지 않음 장점 플랫폼에 독립적임 완벽하게는 아니지만 객체지향적임 컴파일 언어가 아닌 인터프리터 언어로 컴파일과정이 없어 신속한 개발이가능현재는 JIT컴파일 방식을 도입하였다. (컴파일 방식이 인터프리터 방식보다 빠르다.) 컴파일 언어전체를 기계언어로 변환 후 진행소스코드 → 목적코드(기계언어로 번역) → 목적프로그램(바이너리파일) → 실행즉, 번역과 실행이 따로 이루어짐 인터프리터(해석기) 언어소스코드를 바로 실행소스코드를 한줄 한줄 읽어들이면서 실행하는 프로그램 HTML문서 내에서 JS의 위치 어느부분에 삽입해도 가능함 &lt;head>, &lt;body>에 주로 위치 script HTML내부 스트립트 외부 스크립트 불러오기 특징 자바스크립트는 변수에 함수를 넣을수 있다. (그 변수는 함수가 됨) 형변환 함수 eval, parseInt (eval, parseInt : 문자열 → 정수형)eval : 자동 형변환 xparseInt : 자동형변환(가능한부분처리) 기본문법 기본적인 문법은 Java 와 크게 다르지 않다. 데이터 타입을 미리 지정하지 않고 사용한다. (자동으로 데이터타입 지정됨) null과 undifiend는 다르다.null : 초기화는 했지만 데이터 없음undifiend : 초기화되지 않음 내장함수 연산자 증감연산자 지역변수/전역변수 변수 지역변수 function 기능함수 외부에서 선언된 변수 문서의 전 영역에서 변수에 접근 및 수정이 가능하다. 전역변수 function 기능함수 내에서 선언된 변수 선언된 함수 내에서만 변수의 접근 및 수정이 가능하다. 함수 내장함수 선언적함수 / 익명함수 선언적 함수는 메모리에 먼저 올린다.때문에 인터프리터 형식인 자바스크립트에서도 함수가 나중에 선언되어있어도 사용이 가능하다. 익명함수는 인터프리터 형식인 자바스크립트의 특징이 적용되어, 순차적으로 메모리에 올라간다.때문에 호출문이 익명함수 선언 보다 먼저 나오면 호출되어질 수 없다. 익명함수 사용 시 , ()의 유무에 주의하여야 한다.()가 없을 시, 주소값 입력()있을 시, 함수 호출 함수의 매개변수로 함수가 가능하다. 클로저 함수를 호출할 경우, 생성되는 실행 컨텍스트 영역 예시2의 경우 printValue를 이미 실행한 값을 콘솔에 출력하는 것이기 때문에 printFunc의 지역변수는 해당되지 않는다. 이부분을 이해하고 넘어가야 클로저를 이해할수있다. 클로저내부함수는 외부함수의 지역변수에 접근 할 수 있는데 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근 할 수 있다. 예시 상기 예시와 같이 outerFunc의 함수실행이 끝나며, x변수의 값은 사라져야 하지만 return값을 내부함수 innerFunc로 줌으로써 innerFunc(outerFunc의 함수 실행값)를 통해 x변수에 접근할수 있도록 하였다. 상기 예시2의 exam은 함수 inner(outer(16,14)의값)가 된다.즉, ‘function inner(innerArg){ console.log((16+14)/(innerArg + 8)} 이된다.따라서 exam(2)는 3이라는 결과가 호출된다.여기서 local값인 8은 outer함수의 실행이 끝나면 소멸되야 하지만 inner함수의 인자로 사용되어 inner함수를 통해 접근이 가능하다. 객체 자바스크립트 내에 수많은 객체가 이미 정의되있다. 브라우저 객체 : window, document, location등 (DOM객체) 자바스크립트 내장 객체 : Date, Math, Array 등 사용자 정의 객체가 있다. 자바스크립트에서는 클래스라는 개념이 없다. 함수자체가 객체이기도 하다. DOM html문서 생성 시, 자동으로 DOM 트리구조로 생성됨 속성 객체 생성방법 자바스크립트는 여러가지 객체 생성방법을 제공한다. new Object() 사용 필요에 의해 속성 추가가 가능하다. 객체를 하나 생성할 경우 사용하기 좋다. Litral Notation(문자형표기) {} : 객체 / [] : 배열 객체를 소량 (1~2개) 생성하기 좋음 생성자 함수에 의한 객체생성 new 연산자 사용하여 객체생성 객체를 대량 생성해야 할 경우 사용하기 좋음 프로토타입 다같이 함께 사용할 수 있는 공통의 메모리 공간을 가지고 있는 개념 객체지향 언어인 자바스크립트는 객체지향언어의 중요한 요소인 클래스가 없다. (ECMA6에 클래스문법이 추가됨) 대신에 프로토타입(prototype)이란것이 존재한다. 클래스가 없는 자바스크립트는 new 연산자와 함수를 통해 클래스 역할을 대체한다. 클래스가 없기 때문에 상속기능도 없다. 때문에 프로토 타입으로 상속을 흉내내도록 구현해서 사용하기도 한다. 객체 생성시 생성자와 프로토타입 링크가 함께 생성된다. 공통된 내용을 프로토타입에 저장하여 공유한다. 참조 블로그 : [Javascript] 프로토타입 이해하기 by 오승환 만약 상기 예시에서 프로토 타입을 사용하지 않았다면,모든 student객체에 getSum, getAverage, toString 을 가져야 한다.(너무 많은 메모리 중복된 내용이 담김) 프로토타입을 사용 시, 중복된 내용을 프로토 타입에 담는다.그리고 각각의 객체들은 프로토타입을 참조한다. 캡슐화 캡슐화란, 객체의 필드, 메소드를 하나로 묶고 실제 구현내용을 감추는것을 말한다. (보안상의 이유로 사용된다.) 자바에서는 접근지정자/클래스와 get,set메소드를 통해 사용하였으나, 클래스가 없는 자바스크립트에서는 함수내에 지역변수를 사용하고 get, set 함수를 내부함수로 선언하여 캡슐화를 할 수 있다.","link":"/2018/12/11/JavaScript/JS01/"},{"title":"개발프로세스","text":"KOSTA DAY17Process 개발 프로세스1.주제 2.Usecase 3.요구분석 정의서 4.요구분석 명세서 5.도메인 설계 6.구현 7.보고서 8.클래스 다이어그램 UseCase 사용자의 상호작용을 다이어그램으로 표현한 것으로 사용자의 관점에서 시스템의 서비스 혹은 기능 및 그와 관련된 외부 요소를 보여주는것이다. 한마디로 사용자와 시스템 사이의 관계를 나타냄작성순서 액터 식별 → 유스케이스 식별 → 관계정의 액터식별 : 정보제공자, 사용자, 삭제자, 유지보수자, 상호작용 하드웨어 or 소프트웨어 유스케이스 식별 : 액터가 원하는 시스템 제공 기능, 모든 요구사항 만족 기능유무 관계정의 연관관계 : 액터 ↔ 유스케이스 (상호작용) 포함관계 : 반드시 실행되어야 하는 유스케이스 확장관계 : 실행 시, 선택적으로 실행되는 유스케이스 일반화 관계 : 다른 액터 또는 유스케이스를 요구분석 정의서 요구분석 명세서 도메인설계 도메인 : 소프트웨어로 해결하고자 하는 문제영역 도메인을 이해하기 위한 개념 모델 주로 간소화 된 클래스 다이어그램으로 나타냄 (이해하기 좋은 형식으로 표현) 클래스 다이어그램 시간에 따라 변하지 않는 시스템의 정적인 면을 보여주는 대표적인 UML 시스템을 구성하는 클래스들 사이의 관계를 표현한다.","link":"/2018/11/21/Process/Process01/"},{"title":"this., 브라우저 내장객체(BOM), 문서 내장객체(DOM), Ajax","text":"KOSTA DAY32JavaScript This 일반함수 안에서 this는 밖의변수(전역변수)를 가르킨다. 생성자함수 안에서 this는 객체의속성을 가르킨다. 이벤트리스터 안에서 this(event.target)는 해당 객체를 가르킴 this값은 call함수를 사용하여 변경할 수 있다. 브라우저 내장객체(BOM) 현재 브라우저가 보여주고 있는 문서에 관한 여러가지 정보 뿐만 아니라 윈도우 정보, 히스토리정보, 문서가 존재하고 있는 위치정보들을 포함 브라우저 내장객체는 계층구조로 이루어진다.상위객체에서 하위객체의 이름을 .을 이용하여 구분하며 연속적으로 나열하여 사용한다. Window, Frame, Document, History, Link, Anchor, Navigator, Image 객체가 들어있다. Window 객체JS브라우저 내장 객체의 최상위 객체이다.-전체 윈도우에 적용될 내용들을 가지고 있다. 최상위 객체인 Window는 생략이 가능함 예제 open을 통해 팝업창을 연다. open(‘새창으로 열 페이지 주소’, ‘새창의 이름’, ‘옵션’); 문서 내장객체(DOM)(X)HTML 문서의 구조를 가리켜 문서객체모델(DOM : Document Object Model)이라고 한다. 각 태그마다 기능과 속성이 있다. IE8이하 및 표준모델들간 호환성이 떨어진다.JQuery에서 이 단점을 모두 해결함 선택자 HTML내에서 작성된 스타일(css)은 어떠한 동작을 취했을 때 지정한 요소에 스타일을 적용시킬 수 없다. 동작의 스타일은 자바스크립트에서 적용HTML내 작성된 스타일 : 정적 / 자바스크립트내 작성된 스타일 : 동적 직접선택자 : id, class, Form name, Element Name먼거리에 있는 요소를 선택해오는 원거리 선택자 인접관계 선택자 : parentNode, childNodes, firstChild, children, previousSibling, nextSibling선택한요소를 기준으로 가까운 거리에 있는 요소를 선택하는 근거리 선택자 참고블로그 : 별의블로그 AJAX(Asynchronous Javascript And XML)비동기적인 웹 애플리케이션의 제작을 위해 아래와 같은 조합을 이용하는 웹 개발 기법 비동기식서버에 요청한 일에대해 응답을 기다리지 않고 다른작업을 하는것.동기식서버에 요펑한 일의 응답을 기다리고 다음작업을 하는것 비동기식의 장점 페이지를 리로딩을 하지 않는다. 한 페이지 안에서 모든일을 한다.(SAP) ajax프로그래밍 순서 사용자에의한 요청 이벤트 발생 XMLHttpRequest (xhr) 객체 생성(xhr : 서버와 통신을 담당) 웹서버에 요청 전송하기(응답이 어떤 타입으로 오는지 확인 필요하다.) 서버로 부터 응답을 받을 콜백함수를 지정한다.(응답시 자동으로 처리하도록)","link":"/2018/12/13/JavaScript/JS03/"},{"title":"jQuery, 선택자, 이벤트, 스타일, 효과, DOM구현","text":"KOSTA DAY33JavaScript JQueryjQuery는 자바스크립트의 생산성을 향상시켜주는 자바스크립트 라이브러리 입니다. 라이브러리 : 자주 사용되는 로직들을 재활용,유통 가능하도록 만든 로직들의 묶음을 의미한다. JS로 코딩하는것보다 10배 이상의 생산성을 높일 수 있다. RIA 기반 웹 웹표준 HTML5 RIA웹 애플리케이션의 장점은 유지하면서 기존 웹 브라우저 기반 인터페이스의 단점인 늦은 응답 속도, 데스크톱 애플리케이션에 비해 떨어지는 조작성 등을 개선하기 위한 기술의 통칭 예제 선택자(selector) $(‘’) 팩토리함수 : JQuery 객체를 생성한다. JQuery 함수를 사용하려면 JQuery 객체가 필요하다. 선택자는 항상 집합으로 표현된다. size() : 선택자 집합의 갯수 호출 get(index) : JQuery객체 → JS객체 변환index값을 안넣으면 배열로 변환된다. $() : 팩토리함수, JS → JQuery객체 변환 확장집합에서 엘리먼트 획득toArray() 도 JQuery객체를 JS배열 객체로 변환 add()함수를 사용하여 많은 선택자를 체인으로 연결가능 확장집합 다듬기not() 함수를 사용하여 체인으로 연결해 논리부정 관계 구성 filter() : 표현식 매개변수의 값에 따라서 일치하지 않는 엘리먼트를 새로운 집합에서 제거한다. has() : test 표현식과 일치하는 자손을 가진 엘리먼트를 포함한 새로운 확장 집합을 생성 JQuery 체인 관리하기 end() : 이전 확장집합으로 돌아간다. find() : 어떤 요소의 하위 요소(자식) 중 특정 요소를 찾는다. andself() : 두집합의 합집을 생성한다. each() : 선택한 요소가 여러 개일 때 각각에 대하여 반복하여 함수를 실행. 다른 HTML DOM 엘리먼트의 관계를 통해 새로운 확장집단을 얻는 메소드 속성선택자val(매개변수) : value속성을 매개변수로 지정.매개변수값이 없으면, value값을 불러온다. 배열관리 JQuery 함수를 사용하기 위해 $.을 붙였다. item은 해당 array[index]값 이벤트 이벤트 핸들러를 할당할 수있는 통합 메소드 제공 표준 이벤트 타입명 사용 엘리먼트의 이벤트 타입 마다 여러 핸들러 할당 핸들러의 매개변수로 사용할 수 잇는 event 인스턴스 제공 이벤트의 해제와 기본동작을 막는 통합메소드 제공 캡쳐 지원하지않음 , 크로스브라우징 지원 예제 이벤트 핸들러의 this는 이벤트 객체이다.(event.target) remove(‘class_name’) : 클래스제거, 매개변수값이 없으면 전체 제거 addClass함수를 통해서 css스타일을 변경 또는 추가한다. on함수에 이벤트이름을 넣어서 적용할 수 있다. toggleClass() : 설정된 클래스명을 해당하는 요소가 가지고 있는지 판단하여 해당 요소가 있으면 이를 제거합니다. 반대로 해당 요소가 없다면 이를 부여하는 메소드 trigger() : 시작시 해당 메소드 실행 event.stopPropagation() : 버블링방지 hover(func1(), func2()) : 마우스 올려놨을때, func1 실행마우스 떨어졌을때, func2 실행 효과스타일css(name) : 첫번째 엘리먼트에서 name으로 명시한 css 프로퍼티값css(name, value) : css스타일 name 프로퍼티를 value값으로 설정파라미터값에 따라서 다른 메소드 기본시각효과JQuery는 기본적으로 세가지 효과를 제공한다. 아래표를 살펴보자.6개의 함수 외에도 위의 표의 같은 효과메소드를 묶은 toggle 메소드가 있다. 아래 표를 살펴보자. 애니메이션(사용자 정의 효과)모든 집합의 엘리먼트에 properties와 easing 매개변수에 명시된 대로 애니메이션을 수행한다. 애니메이션 수행이 완료된 뒤 호출될 콜백함수를 선택적으로 명시 할 수 있다. animate(properties, duration, easing, callback) properties : 마지막에 도달해야 하는 값을 명시하는 객체 duration : 선택 사항으로 효과가 지속되는 시간을 1/1000초 단위로 설정 easing : 선택사항으로 애니메이션을 미묘하게 바꿀 때 사용 callback : 선택사항으로 애니메이션이 완료된 뒤 호출 예제 more클래스의 a태그 하위의 모든 p태그의 스타일중 display : none;으로 설정하여 사라지게 만들었다. more클래스의 a태그를 클릭시, slideDown되며 해당 p태그들이 보여지며, a태그의 text를 read less로 바꾸었다. read less를 클릭시, slideUp되며 p태그들이 감춰진다. 기본시각효과 및 애니메이션 이벤트 모든 내용들을 종합적으로 활용한예이다. DOM(JQuery 활용)JQuery를 활용하여 DOM)(문서 객체 모델)을 다루는법에 대해 알아보자. 속성, 엘리먼트 attr(name) : 일치하는 집합에서 첫번째 엘리먼트(선택자의 여러 대상들이 있을때)속성값을 얻는다.일치하는 집합이 없거나 속성이 없으면 undifiend attr(name, value) or attr ( attributes) : 속성의 값을 부여 엘리먼트 조작 엘리먼트 복사, 이동(부모,자식관계) 엘리먼트 복사, 이동(형제 관계)뒤에 오는것이 이동되는것으로 보여진다. 엘리먼트 감싸기 예제 innsertBefore()을 통해 생성한 ol문을 footer(id)의 앞에 삽입 footnote의 span태그를 선택(3개) 각각의 객체를 다음과 같이 실행한다. 먼저 this(해당 index span태그)의 뒤에 a태그를 작성하여 삽입 this는 notes(id)의 자식으로 맨뒤에 입력된다. this안에 아까작성한 a태그와 같은 a태그를 맨뒤에 삽입한다. this전체를 태그로 감싼다. &nspb; : 공백(스페이스 한 칸)을 의미.띄어쓰기를 할 때는 키보드의 스페이스키(가장 길쭉한 키)를 한 번 눌러 “공백 문자” 즉 빈 칸을 한 개 삽입합니다.그런데 HTML 문법에서는, 일반 텍스트 편집에서와 달리, 공백 2개를 연속으로 사용해도 2칸을 띄어쓸 수 없습니다.공백을 아무리 많이 삽입해도 공백 1개로 간주됩니다. 그래서 공백을 여러 개 사용해야 할 때는, 빈 칸을 &nbsp; 이렇게 표현해 줍니다.그러면 브라우저가 &amp;nbsp\\; 기호를 빈 칸으로 표시해 줍니다.","link":"/2018/12/14/JavaScript/JS04/"},{"title":"agile(애자일) 프로세스","text":"KOSTA DAY44Process 프로세스일을 처리하는 과정 또는 순서 소프트웨어 개발에서의 주먹구구식 모델 공식적인 가이드라인이나 프로세스가 없는 개발방식 요구분석 명세서나 설계단계없이 간단한 기능만을 정리하여 개발하는 형태 일단 코드를 작성하여 제품을 만들어본 후에 요구분석, 설계, 유지보수에 대해 생각 주먹구구식 모델의 단점 정해진 개발 순서나 각 단계별로 문서화된 산출물이 없어 관리 및 유지보수가 어렵다. 프로젝트 전체 범위를 알 수 없을 뿐더러 좋은 아키텍처를 만들 수도 없다. 일을 효과적으로 나눠 개발할 수도 없으며, 프로젝트 진척 상황을 파악할 수 없다. 계속적 수정으로 인해 프로그램의 구조가 나빠져 수정이 매우 어려워진다. 선형 순차적 모델(water fall) 폭포수 모델의 장점 관리의 용이 체계적인 문서화요구사항의 변화가 적은 프로젝트에 적합 폭포수 모델의 단점 각 단계는 앞 단계가 완료되어야 수행할 수 있다. 각 단계의 결과물이 완벽한 수준으로 작성되어야 다음 단계에 오류를 넘겨주지 않는다. 사용자가 중간에 가시적인 결과를 볼 수 없어 답답해할 수 있다. V모델 폭포수 모델 + 테스트 단계 추가 확장 산출물 중심 vs 각 개발 단계를 검증하는데 초점 테스트단계에서 정확한 니즈가 확인이 안되며, 지나간 단계의 수정이 어려움 프로토 타입미리 제작해보는 시제품, 제작물의 모형 정식 절차에 따라 완전한 소프트웨어를 만들기 전에 사용자의 요구를 받아 일단 모형을 만들고 이 모형을 사용자와 의사소통 하는 도구로 활용 비용 및 시간의 측면에서 부적합 통합 프로세스 모델(UP) 애자일 프로세스 모델 애자일(agile) : 날렵한, 민첩한 고객의 요구에 민첨하게 대응하고 그때그때 주어지는 문제를 풀어나가는 방법론 애자일의 기본가치(애자일 선언문) 프로세스와 도구 중심이 아닌, 개개인과의 상호 소통 중시 문서 중심이 아닌, 실행 가능한 소프트웨어 중시 계약과 협상 중심이 아닌, 고객과의 협력 중시 계획 중심이 아닌, 변화에 대한 민첩한 대응 중시→ 본질로 돌아가자. 애자일 개발 방법론(스크럼) 소프트웨어 개발보다는 팀의 개선과 프로젝트 관리를 위한 애자일 방법 경험적 관리 기법 중 하나 구체적인 프로세스를 명확하게 제시하지 않음 개발 팀(조직)을 운영하는 효율적인 운영 방식(지침)","link":"/2019/01/09/Process/Process02/"},{"title":"Java 면접질문1, KOSTA 필기시험","text":"KOSTA DAY17Java Jav 면접 예상 질문kosta 필기 시험을 토대로 예상 면접질문을 뽑아보았다. 객체지향 언어가 가지고 있는 장점 들어갈 단어확장성, 수정용이, 디버깅 쉬움 자바의 기본형 데이터와 오브젝트 데이터형의 차이점기본형 : 메모리에 직접저장오브젝트 : 주소값 저장 객체는 ☐와 ☐으로 구분되고 프로그램상에서 ☐와 ☐로 표현된다.객체는 상태와 행동으로 구분되고 프로그램상에서 변수와 메소드로 표현된다. 인터페이스와 추상클래스의 차이점과 공통점추상클래스는 일반 메소드가 있을 수 있기때문에 abstract 키워드를 사용공통점 : 자바의 독립성, 선언만 있고 구현내용은 없음 arraylist / linkedlist class 사용법과 차이점arraylist : index값으로 저장 전체리스트 출력에 용이linkedlist : 전후 노드의 주소값과 연결되어저장 리스트 추가 삭제에 용이 instanceof 의미~ instance of - : ~가 –로 형변환 가능한가 String class equals 사용내용~.equals() : ~와 ()가 같은가 true false 출력 익명클래스를 사용하는 목적과 사용예클래스를 단 한번만 사용하고 구현할때, 추상클래스 및 상속 없이 일회성으로 구현하기 위해서 사용 프로세스와 쓰레드의 차이프로세스 : 프로그램단위스레드 : 프로그램 내의 실행흐름 멀티 쓰레드 생성 방법1.runnable 인터페이스 implement2.extends thread클래스 KOSTA 필기시험전일 Java 진도를 모두 끝내 금일 오전수업은 필기시험을 진행하였다.","link":"/2018/11/21/Java/java16/"},{"title":"배열, 자바스크립트 내장객체, 이벤트","text":"KOSTA DAY31JavaScript 예제 생성한 객체에 cals 함수안에서 태그 안의 f1 폼에 있는 값을 속성 num1, num2에 넣었다.여기서 this는 객체안의 속성 num1, num2를 가르킨다. &lt;\\input type=”button”&gt;의 id를 받아 plus / minus 를 판단한다.여기서 this는 객체안의 속성값인 아닌 객체밖의 window를 가르킨다. sum을 계산하여 출력한다. 배열 []배열생성 new 연산자로 배열생성 new연산자 및 배열값으로 배열생성 배열문자열 변환join(“-”) : -값으로 배열 나열 시, 분류 concat() slice()slice(a, b); : arr[a] ≤ arr[] &lt; arr[b] splice()splice(a, b); : a=index , b=갯수 배열정렬 : sort(); 내림차순 String 객체 문자열을 사용하거나 조작을 지원하느 객체 new 연산자를 사용하지 않음 예제 Date 객체날짜와 시간을 처리할 수 있도록 지원하는 객체 Date(); : 현재 시간을 불러온다. 변수를 생성하여 다중실행 되는것을 방지 정규표현식 객체 문자열.match(/정규표현식/) → 매칭된 결과(문자열) i : 대소문자 구분Xg: 전역검사 문자열 변환(replace) 이벤트이벤트 관련용어 정리 이벤트 연결 = 윈도우 객체에 onload 속성에 함수 자료형을 할당window.onload = function(){} load : 이벤트이름 , 이벤트타입 onload : 이벤트 속성 이벤트 속성에 할당한 함수 : 리스너(Event Listener or Event handler) 고전이벤트모델 하나의 이벤트에 하나의 리스너만 연결 가능 인라인 이벤트 인라인 태그에 이벤트 속성을 부여한다. Default 이벤트 제거 html태그는 이미 이벤트 리스너가 있다. 대표적으로 default 이벤트제거 방법은 이벤트 리스너에 false 를 리턴한다. 크로스 브라우징이벤트모델은 구IE(인터넷익스플로러8이하) 와 표준모델로 나누어진다. 그렇기 때문에 이벤트 등록을 위해서는 두가지 모두가 호환가능하도록 해야한다. jquery에서는 알아서 해주는 부분 표준모델 여러개의 이벤트리스너 등록이 가능하다. IE8 이하모델 이벤트 이름에 반드시 on을 넣어야한다.현재 내 노트북은 IE8이하 버젼이 아니기 때문에 확인할 수 없었다.이제 이 두가지를 모두 호환 가능하도록 크로스 브라우징 하는 방법에 대해알아보자. if문을 사용하여 addEventListener에 값이 있는지 확인 값이 있으면 addEventListenr 활용하여 이벤트 추가 값이 없으면 구버젼 IE 이므로, attachEvent 활용하여 이벤트 추가 이벤트 전달 이벤트 버블링 : 자식노드에서 부모노드순으로 이벤트를 실행 이벤트 캡쳐링 : 버블링과 반대되는 개념으로 부모노드에서 자식노드 순으로 실행( 익스플로러에서 캡쳐링을 지원하지 않아 사용할 일 없다.) bb는 aa의 자식이므로, bb를 클릭시 bProcess를 실행한 후, aProcess가 실행된다. 쉽게 말하자면, bb를 클릭한것은 aa를 클릭한것이기도 하기때문에 둘다 실행된다는것이다. 이러한 버블링을 막기위해 하기 예시와 같이 진행할 수 있다. stopPropagation() 을 활용하여 이벤트 전달을 멈춘다.그러나, IE8이하는 stopPropagation을 사용할 수 없기때문에 크로스 브라우징을 해줘야 한다.그 방법을 알아보자. 구IE 에는 event를 바로 사용호출 못하고 window.event로 가능하다. 따라서 event라는 변수에 e와 window.event 중 가능 한것을 담는다.(두 모델 모두 event변수안에 event가 담김) stopBubble 함수 내용에 따라 각 모델 방식별로 버블링을 제어한다.표준모델 → event.stopPropagation();구모델 → event.cancelBubble = true;","link":"/2018/12/12/JavaScript/JS02/"},{"title":"실전 데이터 모델링&데이터베이스 설계와 구축","text":"KOSTA DAY25DataBase 실전 데이터 모델링 &amp; 데이터 베이스 설계와 구축 우리나라는 데이터 위주의 설계를 하기 때문에 ERP 다이어그램 위주로 설계를 한다. 데이터 모델링정보화 시스템을 구축하기 위해 , 어떤 데이터가 존재하는지 또는 업무가 필요로 하는 정보가 무엇인지를 분석하는 방법 프로젝트에 참여한 모든 사람은 데이터모델링에 참여하거나, 모델내용을 이해해야한다. 업무가 관여하는 어떤것(THING) 업무가 관여하는 어떤것간의 관계(RELATIONSHIPS) 어떤 것이 가지는 성격(ATTRIBUTES) 엔티티 타입 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한것 영속적으로 존재하는 단위 엔티티 타입이 생성되는 의미대로 명명한다. 엔티티타입의 특징 업무에 필요하고 관리하고자 하는 정보필요없는관계X 식별자에 의해 실별이 가능ex) PRIMARY KEY와 같이 주키가 있어 식별이 가능해야 한다. 영속적으로 존재하는 엔티티의 집합엔티티의 수가 1개가 아니라 2개이상이어야 한다. 업무 프로세스에 이용되어야 한다. 반드시 속성이 있어야 한다. 최소한개이상의 관계가 있어야 한다.예외가 있을 수 있다. ex) GRADE table 엔티티 타입의 분류 기본 : 해당업무에 기본적으로 존재하는 정보 중심 : 업무에 핵심적인 역할을 하는 정보 행위 : 기본과 중심 엔티티타입을 근간으로 업무가 흘러가면서 발생되는 엔티티타입 식별자 엔티티 타입내에서 엔티티들을 구분할 수 있는 구분자이다. 주로 PRIMARY KEY라고 생각할 수 있다. 대리식별자 주식별자의 속성이 복합식별자일 경우 여러 개의 속성을 묶어 하나의 속성으로 만들어 주식별자로 활용하는 경우 대리식별자라 한다. 주키(식별자)가 많으면 작업이 용이하지 않기때문에 사용 주키로 사용할 것이 마땅치 않을때, 주키가 많을때 대리식별자 사용을 고려해봐야 한다. 관계두개의 엔티티타입 사이의 논리적인 관계(서로에게 영향을 주는 형태) 존재에 의한 관계 / 행위에 의한 관계 관계의 카디넬러티 1:1(ONE TO ONE) 1:M (ONE TO MANY) M:M (MANY TO MANY) 관계의 종류주식별자 / 비식별자 주식별자 : 부모의 주식별자 = 자식의 주식별자 비식별자 : 부모의 주식별자 = 자식의 일반속성 업무의 로직에 따라서 선택한다.결합력이 강하며, 제한적으로 사용되는 경우에만 주식별자를 사용하는것이 좋다. 속성업무에 필요한 엔티티에서 관리하고자 하는 더 이상 분리되지 않는 최소의 데이터 단위 정규화다양한 유형의 검사를 통해 데이터 모델을 더 구조화 하고 개선시켜 나가는 절차에 관련된 이론이다. 오류를 최소화 시키는 것. 중복된 데이터가 없도록 하는것이 기본원칙 함수의 종속성 정규화 제1차 정규화 : 중복된 속성값을 갖는 속성을 분리 제2차 정규화 : 주식별자에 종속적이지 않은 속성을 분리 제3차 정규화 : 일반속성인데 주키 역할을 하는것과 그것을 종속하는 속성들을 분리","link":"/2018/12/04/OracleDB/DBmodeling01/"},{"title":"JQuery UI, JQuery plugin","text":"KOSTA DAY34JavaScript JQuery UI JQuery 공식 홈페이지 → 왼쪽상단 JQuery ui 선택 → 여러가지 ui들을 사용가능 JQuery pluginsjquery 사용자들이 원하는 기능을 추가한것. JQuery 공식 홈페이지 → plugins 클릭 → 원하는 플러그인 소스 다운 → import 후 사용 플러그인 제작 $.fn.myPluginMethod = function(options){};","link":"/2018/12/19/JavaScript/JS06/"},{"title":"JQuery 활용 Ajax, 슬라이드쇼","text":"KOSTA DAY34JavaScript Ajax(JQuery 활용)Ajax : 비동기적인 웹 애플리케이션의 제작을 위해 아래와 같은 조합을 이용하는 웹 개발 기법 앞서 xhr을 활용한 ajax에 대해서 앞서 다룬적이 있었다. JQuery를 활용하여 보다 편하게 ajax 사용하는법에 대해 알아보자. Ajax 관련 JQuery 커맨드 html타입 결과 불러오기 load(url, parameters, callback) url : 요청주소 parameters : 전달 data callback : load 된 이후 호출되는 함수 load함수의 경우에는 callback함수를 사용하지 않아도 된다. JSON 타입 결과 불러오기 get JSON(url, parameters, callback) : 응답이 json문자열로 해석되며 결과는 callback 함수에 전달된다. getJSON 함수를 통해서 url 주소 안의 데이터값을 function의 매개변수값으로 사용하게 된다. javascript 타입 결과 불러오기 getScript(url) : javascript를 불러온다. xml 타입 결과 불러오기 xml 타입 전용 방식은 없다. get or post 메소드를 통해 적용가능 대부분 get 방식 (파라미터 값이 없으면 무조건 get 방식) get함수를 사용하여 xml파일을 받는다. $(data).find(‘entry’) → xml파일안의 모든 entry → each함수를 통해 하나씩 대입한다. $entry.attr(‘term’) = entry태그안의 term 속성값 만들어진 html을 dictionary의 자식으로 삽입한다. JSP 타입 파일 불러오기 jsp파일의 term값에 클릭한 a태그의 속성 term의 값을 넣는다. 나온값들이 function의 매개변수인 data에 담긴다. 담긴 data들이 id=”dictionary”의 html값으로 들어간다. return false; 를 통해 a태그의 defualt이벤트를 제거 Ajax 전역함수 전역 이벤트가 발생시 어떠한 DOM엘리먼트에도 핸들러가 할당됨 함수는 ajax요청이 처리되는 각 단계나 요청성공 혹은 실패시 수행한다. success 이벤트를 성공 시 실행 (항상 필요) serialize() : 데이터를 보내기 위해 폼 요소 집합을 문자열로 인코딩한다.선택되지 않은 체크박스나 라디오 버튼, 선택된 옵션이 없는 드롭다운, 비활성화 된 컨트롤은 변회시 무시(form 안의 submit 이벤트에만 사용가능) id=”letter-f”의 form의 입력된 text가 data에 담긴다. 담긴데이터가 success 함수에 의해 dictionary의 html 들어간다. 예제 입력버튼 클릭 시, json타입으로 form의 값들을 jsp에 담는다. 모두수행되면 , successHandler 실행 담긴 내용들로 div 태그를 작성한다. List에 자식으로 귀속하여 게시한다. $(.quantity input)의 value가 변하면 메소드를 실행한다. replace(/^[^\\d.]/ , ‘’) : 숫자로 시작하지 않으면 ‘’(삭제함) quantity or cost에 parseInt로 변환하여 값을 저장한다. 해당값을 계산하여 total_cost, total_quantity값에 넣어준다. total_cost, total_quantity 의 변수 선언 위치에 주의해야한다. 슬라이드쇼","link":"/2018/12/17/JavaScript/JS05/"},{"title":"데이터베이스, Oracle , SELECT","text":"KOSTA DAY20DataBase 데이터베이스서로 연관성을 가지며, 중복없이 지속적으로 유지 관리해야 할 유용한 데이터들의 집합 데이터 베이스 이전에 데이터 저장을 위해서 파일시스템을 사용했으나, 많은 문제점이 있었다. 중복 데이터 저장 문제 발생 대용량 데이터 관리 역부족 데이터 공유 어려움 (다중 사용자) 보안 취약 상기와 같은 문제점을 극복하고 대량의 데이터를 체계적으로 저장 및 관리하기위해 만들어졌다. DBMSDatabase Management System(데이터베이스 관리시스템)대용량 데이터를 쉽게 저장하고, 효율적으로 CRUD(Create Read Update Delete)할 수 있는 환경을 제공해주는 소프트웨어 대표적인 DBMS로는 Oracle, mySQL, MS-SQL, Informix, DB2가 있다. 관계형 DBMS 가장대표적인 DBMS로 실세계 데이터들을 2차원적인 표(table)형식으로 표현 데이터 무결성, 트래잭션 처리 등 기본적 기능이 우수 질의어(Query Language)를 사용한 데이터 접근 정형화된 DATA를 다룸 비정형화된 DATA는 No-SQL에서 다룸(빅데이터에서 사용) Oracle가장 대표적인 관계형 DBMS중의 하나이다.(회사명 과 DBMS 제품명 동일) KOSTA 교육 중에는 무료 버젼인 XE버젼을 사용 할 것이다. Oracle xe 설치 및 데이터 접속/설 windows : medium 최용락 macOS기준 (참고블로그 : 맥(osx)에서 oracle DB 사용하기) docker 가입 및 설치 sql developer 다운로드 도커허브를 통해서 원하는 프로그램을 검색한다.(oracle12c) 1docker pull sath89/oracle-12c 위의 명령어를 입력한다. 1docker run --name oracle12c -d -p 8080:8080 -p 1521:1521 -v ~/my/oracle/data:/u01/app/oracle sath89/oracle-12c -v옵션을 주어 저장될 위치를 설정해준다. (-v옵션이 없을경우, 컨테이너를 중지하는순간 데이터가 삭제 된다.)데이터는 ‘~/my/oracle/data’경로에 저장된다. 1docker rm oracle12c 위의 명령어는 컨테이너를 삭제하는 명령어이다.(컨테이너 저장으로 인한 오류 발생 시, 삭제 후 다시 진행요함) 1docker logs -f oracle12c 위의 명령어를 입력할 시, 로그를 출력하여 초기화 진행상황을 알 수 있다. 100% 완료 될때까지 기다리기. 터미널 재시작 sql 접속 docker exec -it oracle12c sqlplusID : systemPW : oracle sql developer 계정 생성사용자이름 : systempw : oracle kosta192 계정 생성 1234create user kosta192 identified by 1234conn sys as sysdba (pw : oracle)grant connect, resource, dba to kosta192;conn kosta 192/1234 scott 계정확인 12conn sys as sysdba; //(pw : oracle)SELECT username, account_status FROM dba_users WHERE username=&apos;SCOTT&apos;; scott계정 잠금해제 (참고블로그 : Oracle 에서 scott 계정 락해제 방법) 12alter user scott account unlock;ALTER user scott IDENTIFIED BY tiger; SELECT employees 테이블의 전체 데이터를 불러오기 1SELECT * FROM employees 중복된 데이터 제거 1SELECT DISTINCT job_id FROM employees; 정렬 묶음 검색(ORDER BY 절) 12SELECT ENO, ENAME, SAL FROM EMPORDER BY SAL DESC, ENO; 조건에 맞는 일부데이터(ROW) 불러오기 (WHERE절) 12SELECT DEMPLOYEE_ID, LAST_NAME, HIRE_DATE FROM EMPLOYEESWHERE LAST NAME = ‘King’; BETWEEN AND 연산자 12SELECT employee_id, last_name, salary FROM employeeswhere salary BETWEEN 5000 AND 10000; OR 연산자 12SELECT employee_id, last_name, job_id FROM employeesWHERE job_id = ‘FI_MGR’ OR job_id = ‘FI_ACCOUNT’; IN연산자 12SELECT employee_id, last_name, job_id FROM employeesWHERE job_id IN (‘FI_MGR’, ‘FI_ACCOUNT’; NOT 연산자 12345SELECT department_id, department_name FROM departementsWHERE NOT department_id = 10;SELECT department_id, department_name FROM departementsWHERE department_id &lt;&gt; 10; IS NOT NULL 연산자 12SELECT employee_id, last_name, commission_pct FROM employeesWHERE commission_pct IS NOT NULL; LIKE 연산자 (%연산자와 함께 잘사용) ‘김%’ = ‘김’으로 시작하는 모든 문자열 ‘%과% = ‘과’로끝나는 모든 문자열 ‘%김%’ = ‘김’이라는 문자를 포함하는 모든 문자열 ‘화_’ =’화’로 시작하는 2글자 문자열 ‘_등_’ = ‘등’이 가운데 들어간 3글자 문자열 그룹함수 sum(), avg(), max(), count() SELECT sum(salary) FROM employees; =인건비 총합 GROUP BY절 부서별 평균 급여를 검색하라.123SELECT department_id, avg(salary) FROM employeesGROUP BY department_id;GROUP BY 절 사용시 컬럼값은 그룹함수 및 GROUP BY절 인자만 들어갈 수 있다.","link":"/2018/11/26/OracleDB/oracle01/"},{"title":"ANSI JOIN, INNER JOIN, OUTER JOIN, SELF JOIN, 서브쿼리","text":"KOSTA DAY22DataBase ANSI JOIN FROM절에서 INNER JOIN 구문 사용 조인조건은 ON절에 명시 조인조건 외 조건은 기존대로 WHERE절에 명시 3개이상 조인1234테이블1 JOIN 테이블2ON 공통컬럼1 = 공통컬럼1JOIN 테이블3ON 공통컬럼2 = 공통컬럼2 예제 기존 1234SELECT e.employee_id, e.department_id, d.department_nameFROM employees e, departments dWHERE e.department_id = d.department_idAND last_name = ‘King’; ANSI JOIN 1234SELECT e.employee_id, e.department_id, d.department_nameFROM employees e INNER JOIN departments dON e.department_id = d.department_idWHERE last_name = ‘King’; INNER JOIN 교집합에 해당한다고 볼 수 있다. SELF JOINTABLE을 자기 자신과 조인시키는 것 예제 ‘seattle’ (city)에 근무하는 사원의 이름, 부서번호 직종번호, 직종이름, 도시이름 출력1234SELECT e.last_name || ‘의 매니저는’ || m.last_name || ‘이다.’FROM employees e INNER JOIN employees mON e.manager_id = m.employee_idWHERE e.last_name = ‘King’; OUTER JOIN조인을 생성하려 하는 두개의 테이블의 두개 컬럼에서 공통된 값이 없을때 사용 예제12345SELECT * FROM employees; //=&gt; 107rowSELECT e.employee_id, e.department_id, d.department_nameFROM employees e, departments dWHERE e.department_id = d.department_id; //=&gt; 106row 부서배치 받지 않은 사원이 있을 수 있다. 이럴 때, OUTER JOIN 사용 123456789101112SELECT e.employee_id, e.department_id, d.department_nameFROM employees e, departments dWHERE e.department_id = d.department_id(+);/* 누락된 곳 반대편에 (+) */ORANSI JOINSELECT e.employee_id, e.department_id, d.department_nameFROM employees e LEFT JOIN departments dON e.department_id = d.department_id/* 누락된 곳으로 방향설정 */ 서브쿼리하나의 SQL문 안에 포함되어 있는 또 다른 SQL 문 서브쿼리 작성 순서 서브쿼리문 먼저 작성 메인쿼리 작성 메인쿼리 필요 위치에 서브쿼리문 삽입 WHERE절 서브쿼리 WHERE절에 서브 쿼리를 사용 예제 Chen’ 보다 salary를 많이 받는 직원의 내역을 출력하라.123SELECT last_name, salaryFROM employeesWHERE salary &gt; (SELECT salary FROM employees WHERE last_name = ‘Chen’); 문제 학생중 기말고사 성적이 가장 낮은 학생의 정보를 검색하라 12345SELECT s.sname, s.sno, s.major FROM student s, score rWHERE s.SNO = r.SNOGROUP BY s.sname, s.sno, s.majorHAVING sum(result) = (SELECT min(sum(result)) FROM score GROUP BY sno); 화학과 1학년 학생중에 평점이 평균이하인 학생을 검색하라. 12345678SELECT sname, sno, avr FROM studentWHERE major = ‘화학’AND syear = 1GROUP BY sname, sno, avrHAVING avr &lt;= (SELECT avg(sum(avr)) FROM student WHERE MAJOR = ‘화학’ AND SYEAR = 1 GROUP BY sno);","link":"/2018/11/28/OracleDB/oracle03/"},{"title":"KOSTA 필기시험(Oracle DB)","text":"KOSTA DAY28DataBase DB진도를 마치며 Java때와 마찬가지로 필기시험을 진행하였다. 필기시험 체크를 한 부분이 틀리거나, 정답은 썼지만 확실하지 않은 부분 정리 인덱스를 사용하는 목적과 인덱스 생성과정을 서술하시오. 목적 일정한 검색 속도 유지 데이터량이 많은 경우 검색속도 향상 (WHERE절 및 JOIN조건이 많이 들어가는 경우에 사용) 생성과정 인덱스 생성 → 테이블의 데이터에 대한 Indexing → B-tree구조로 형성 생성방법 12CREATE INDEX index_nameON table_name(column_name); 뷰를 사용하는 목적과 용도를 서술하시오. 목적 반본적으로 사용되는 문을 뷰로 생성하여 테이블처럼 사용가능하게 만듬 용도 보안적인 내용을 다룰때 사용ex) 부서에 테이블 제공시 보안사항을 제외한 뷰를 생성하여 제공 생성방법 1234CREATE OR REPLACE VIEW view_name AS뷰내용;DESC view_name; → 뷰의 컬럼 내용보기 정규화 3가지 서술하시오. 1차 정규화 : 복수의 속성값을 가진 속성을 분리 2차 정규화 : 주식별자에 종속적이지 않은 속성을 분리 3차 정규화 : 일반속성에 종속적인 속성을 분리 emp_empno_seq 시퀀스를 생성하였다. 시퀀스를 증가시키기 위한 sql을 작성하여라. 시퀀스 사용 목적 PRIMARY KEY 값을 입력 시, 시퀀스를 입력하면 사용자가 보다 편하게 작업이 가능하다. 시퀀스 사용방법 123CREATE SEQUENCE seq_nameSTART WITH 시작번호INCREMENT BY 증가량; 사용 12/*seq_name.nextval*/INSERT INTO board VALUES (seq_seq.NEXTVAL, ‘a1’, ‘a’, ‘a’, sysdate, 0); 엔티티타입 추출 원칙 업무에 필요/관리항목 식별자에의해 식별가능 영속적으로 존재하는 엔티티의 집합(엔티티(행?)가 두개이상) 업무 프로세스에 이용 반드시 속성이 있어야한다. 최소 한개이상의 관계필요 (예외가 있을 수 있음 )","link":"/2018/12/04/OracleDB/oracletest/"},{"title":"Project_Kogile_JSP","text":"ProjectKOSTA 중간 프로젝트KogileProject github : https://github.com/cyr9210/JSP_Project_kogile 주제선정우리 조의 중간 프로젝트 주제는 업무협업서비스를 선택하였다.우리조가 생각한 협업서비스란 업무의 완료 여부 및 상태와 진행률등 여러 정보들을 한눈에 보기 쉽게 표현해주며 앞으로의 업무파악을 보다 쉽게해주기 위해서 제공하는 서비스이다. 주제를 협업서비스로 정한 이유는 많지는 않지만 미니 프로젝트를 진행하면서, 협업의 중요성을 깨달았으며 서로간의 커뮤니케이션 및 정보 전달들이 힘들었다는 생각이들었고 우리가 힘들었던 이 점을 우리가 프로젝트를 통해 해결 방안을 만들어보자는 생각에 선정하였다. 요구분석 UseCase 명명법 레이아웃 아키텍쳐 구조 ER다이어그램 회고ajax success를 대신하여 promise 사용→ .then(function(res){ 성공시 실행내용})res = response로 받아온 객체→ .catch(function(err){ 실패시 실행내용})err = error내용 console.log(res)를 통해 데이터 타입을 확인하는것이 추 후 실행내용을 작성시 편리하였다. const data = {} 으로 전달 data를 미리 선언해주는것이 파악하기 좋다. dataType 대소문자 주의 다중 insertinsert all을 통해 데이터를 한번에 여러개를 삽입하였다. 한번실행에 한번의 seq만 실행됨으로 INCREMENT BY 4; 를 설정 view에서 this를 사용하여 값 가져오기 클릭한 태그의 자식 중 select_pno 클래스의 value 값을 가져온다. form 데이터를 ajax로 넘기기 쌍따옴표 사용 $(“”) serialize(); 를 통해 json 객체화 날짜 및 날짜계산 두가지 방법이 있다. jsp → useBean 액션태그로 Date객체 생성/ formatDate 선택 js → new Date 객체생성 및 set 느낀점너무 빠르고 힘든 2주일이 지났다.Spring을 제외하고 배웠던 모든것들을 활용하여 프로젝트다운 프로젝트를 진행햐였다.Git Master를 맡아 git을 통해 팀원들과 내용을 공유하고, 버전관리를 하였는데 잘 되지않아 작업내용을 날려서백업내용을 불러오기도 했고 git 때문에 정신적으로 너무나 힘들었다. 최종프로젝트에는 반드시 git을 제대로 배워서 관리해야겠다는 생각을 했다. (터미널로 하고싶다.)조장으로서 팀원들과 의사소통이 부족했던것 같다.전공자 또는 경력자들이 조장인 다른조에 비해 너무 부족했기 때문에, 팀원들이 많이 고생한 것 같다. 이런 프로젝트를 해본 경험이 없었기때문에 무엇을 해야할지 잘 몰랐고, 자신있게 의견을 제시하거나, 업무분담을 제대로 해주지 못한것 같고, 때문에 많이 진행이 늦었던 것 같다.최종프로젝트에 들어가게 되면 spring을 적용하여 이번 중간프로젝트에 진행한 내용들을 완성시켜야 한다. 지금은 다른조들에 비해 많이 부족하지만 그때는 다른조들 보다 더 좋은 결과물들을 만들어 내고 싶다.","link":"/2019/01/23/Project/Kogile-Intermediate/"},{"title":"Reference 형 데이터, ROWTYPE, 제어문, 반복문, 예외처리, Cursor, for문, Procedure","text":"KOSTA DAY24DataBase Reference형 데이터 타입 선언방법 1[변수명] [ ] [해당데이터가 받을 컬럼명]%TYPE; 상기 이미지와 같이 해당 데이터의 데이터타입을 컬럼으로 설정 예제 사원테이블에서 201번 사원의 이름과 이메일을 출력하라.(레퍼런스형) 찾을 사원번호를 v_search에 선언 후, 출력할 내용들을 reference 타입으로 선언 후, where문을 사용하여 각각의 내용들을 변수에 넣어 호출하였다. employees 테이블에서 사원번호가 큰 사원을 찾은후 사원번호 +1 구해서 사원을 추가하라.(insert)사원명(last_name) = &gt; hong gil dong이메일 =&gt; aa@aa.com입사일자 =&gt; sysdatejob_id =&gt; ad_vp 사원번호가 가장 최근(가장높은)번호를 찾은 후, 최고값에 +1에 넣어 다른값들을 INSERT 하였다. ROWTYPE 1개의 행값을 갖는다.(선언) 선언방법1수명][ ][테이블명]%ROWTYPE 예제 제어문예시10~120 중 임의이 부서 버호를 받아서 해당부서의 평균 급여에 따라서 등급이 출력되도록 하자.1~3000 낮음3000~ 6000 적정6000이상 우수 ROUND(DBMS_RANDOM.VALUE(10, 120), -1); 랜덤함수 IF문 IF, ELSIF, ELSE문 CASE WHEN 문 반복문 LOOP문 WHILE문 for문 예외처리 PL/SQL의 오류를 예외라고 한다.(컴파일시 문접적 오류: 실행시 발생하는 오류) 미리 정의 된 오라클 서버 예외 : 선언할 필요도 없고, 예외 발생 시, 예외절로 자동이용 사용자 예외 강제 발생 : 선어부에서 예외를 정의 실행부에서 RAISE문 사용하여 예외발생 예시 미리 정의 된 오라클 서버 예외 사용자 강제 예외 발생 예제신입사원 입력 시 잘못된 부서번호에 대해서 사용자 예외 처리를 하시오(오류남) 먼저 예외발생을 위해 예외를 선언(ex_invalid_dept_id) count 함수를 사용해 해당부서의 인원을 검색하여 그 값을 v_cnt에 대입 v_cnt 값이 0이면 해당부서가 없는것이므로, RAISE문 사용하여 예외발생 CURSOR SELECT문 결과 집합이 다중로우일 경우 반드시 커서를 이용하여 처리(RAWTYPE과 함께 사용) 예시 예제서를 이용하여 사원의 정보를 출력하세요(사원번호, 사원이름, 급여, 급여누계) total salary 선언 CURSOR 선언 CURSOR를 받을 데이터 선언 루프문을 사용해 삽입(FETCH, INTO, EXIT WHEN)#%NOTFOUND : 더이상 없을때 LOOP문은 for문을 대체 가능 하기 이미지 참고 프로시저(Procedure)자주 사용되는 PL/SQL 블록을 재사용하기 위해 모듈화 하는 것. 선언방법 1CREATE OR REPLACE PROCEDURE [프로시저명][(변수명 IN 받을 데이터타입 컬럼명)]IS 실행방법 1EXECUTE [프로시저명][입력값]; 예시부서번호를 받아 사원리스트를 출력하라. 부서번호를 입력받는 프로시저 생성 (listbyDept) 부서사람이 여러명이기 때문에 다중행 입력받기위해 CURSOR사용 EXECUTE 사용하여 실행","link":"/2018/12/03/OracleDB/oracle05/"},{"title":"HAVING, 함수, DDL, DML, 제약조건, JOIN","text":"KOSTA DAY21DataBase HAVING 조건 전체 그룹에서 일부의 그룹만 추출하기 위해 사용된다. WHERE와 비슷하게 사용된다. 예제 WHERE절 사용 123SELECT department_id, avg(salary) FROM employeesGROUP BY department_idWHERE avg(salary) &lt; 5000; HAVING절 사용 123SELECT department_id, avg(salary) FROM employeesGROUP BY department_idHAVING avg(salary) &lt; 5000; 함수문자함수 LOWER() : 소문자 문자 변환 UPPER() : 대문자 문자 변환 SUBSTR(index, n) : 부분 문자열 추출(INDEX 1부터시작, 문자갯수) 예제 숫자함수 MOD : 나머지값 변환 ROUND(n1, n2) : 반올림 값 리턴 (숫자, 소수자리수 -1 = 1의자리) CEIL() : 올림 FLOOR() : 내림 날짜함수 SYSDATE : 현재 날짜를 출력하는 함수 1SELECT sysdate-1 “어제”, sysdate “오늘”, sysdate+1 “내일” FROM dual; &lt;퀴즈&gt;신입사원의 근속년을 출력하라. 1SELECT first_name, last_name, hire_date “입사일”, round((SYSDATE-HIRE_DATE)/365) “근속년수” FROM employees; &lt;퀴즈&gt; 07년에 입사한 사원의 목록을 출력하라. TO_CHAR 사용 1234567//(LIKE 함수 사용)SELECT hire_date FROM employeesWHERE hire_date LIKE ‘07%’;//(TO_CHAR사용)SELECT hire_date FROM employeesWHERE TO_CHAR(hire_date, ‘YYYY’) = ‘2007’; NVL()NULL을 0 또는 다른 값으로 반환 퀴즈&gt; 사원의 연봉을 출력하라.(월급여 12) + (월급여12*커미션)1SELECT last_name, salary, nvl(commission_pct, 0), salary+salary*nvl(commission_pct, 0) “실연봉” from employees; DECODE()괄호 안의 값을 변환1SELECT job_id, DECODE(job_id, ‘SH_CLERK’, ‘Sales Dept’,’SA_MAN’, ‘Sales Dept’, ‘Another’) FROM employees; CASEWHENWHEN뒤의 값을 THEN뒤의 값으로 변환 DECODE와 비슷한 역할을 한다.1234567SELECT job_id, CASE job_idWHEN ‘SA_MAN’ THEN ‘Sales Dept’WHEN ‘SH_CLERK’ THEN ‘Sales Dept’ ELSE ‘Another2’ENDFrom employees; DDLData Definition Language 데이터 정의어 테이블 생성1234CREATE TABLE 테이블명(컬럼명 데이터형,컬러명 데이터형) 데이터형문자형 : CHAR(size), VARCHAR2(size) 가변형(사이즈 알아서 수정)숫자형 : NUMBER날짜형 : DATE, TIMESTAMP(좀 더 디테일한 시간)대용량(이미지, 파일) : LOB(문자데이터), BLOB(이진형데이터, ~4GB) 테이블복사 12CREATE TALBE emp01AS SELECT * FROM employees; 테이블 구조 복사 12CREATE TABLE emp02AS SELECT * FROM employees WHERE 1=0; 테이블 구조 수정 컬럼추가 12ALTER TABLE emp02ADD(job VARCHAR2(50); 컬럼수정 12ALTER TABLE emp02MODIFY(job VARCHAR2(100)); 컬럼삭제 12ALTER TABLE emp02DROP COLUMN job; 테이블 삭제 1DROP TABLE emp02 PURGE; 테이블 이름 변경 1RENAME emp01 TO emp00; 테이블 데이터만 삭제 123TRUNCATE TABLE emp00; // → DCL(트랙잭션 적용 불가, 복구불가)DELETE FROM emp00; // → DML(트랙잭션 적용 가능)// ※트랜잭션 : 상호작용 단위 DML(INSERT, UPDATE, DELETE) INSERT문1234INSERT INTO dept01 VALUES(300, ‘DEVELOPER’, 100, 10);INSERT INTO dept01(department_id, department_name)VALUES(310, ‘Innovation’); UPDATE문12UPDATE 테이블명 SET 컬럼명 = 수정값, 컬럼명=수정값WHERE 수정대상; DELETE문12DLETE FROM 테이블명WHERE 삭제대상; 제약조건데이터를 추가,삭제,수정 하는 가운데 데이터의 무결성을 유지하기위해 사용 NOT NULL NULL값 입력 시 에러발생 UNIQUE 같은값 입력 불가 PRIMARY KEY UNIQUE + NOT NULL 주키역할 하나 이상 존재해야 TABLE의 역할을 한다. CHECK() 괄호안의 보기중 입력하지 않으면 에러발생123456CREATE TABLE emp08(empno NUMBER,ename VARCHAR2(20) NOT NULL,job VARCHAR2(20),deptno NUMBER,gender char(1) CHECK(gender IN(‘M’, ‘F’)); FOREIGN KEY 다른 테이블을 참조값으로 가져옴 예제 테이블 생성 동시 조건 12345CREATE TABLE emp03(empno NUMBER PRIMARY KEY,ename VARCHAR2(20) NOT NULL,job VARCHAR2(20),deptno NUMBER REFERENCES departments(department_id)); 테이블 레벨방식 123456789CREATE TABLE emp06(empno NUMBER,ename VARCHAR2(20) NOT NULL,job VARCHAR2(20),deptno NUMBER,CONSTRAINT emp06_empno_pk PRIMARY KEY(empno),CONSTRAINT emp06_deptno_fkFOREIGN KEY(deptno)REFERENCES departments(department_id)); 테이블 수정방식 12345678CREATE TABLE emp07(empno NUMBER,ename VARCHAR2(20) NOT NULL,job VARCHAR2(20),deptno NUMBER);ALTER TABLE emp07ADD CONSTRAINT emp07_empno_pk PRIMARY KEY(empno); JOIN2개 이상의 테이블에서 데이터를 검색하기 위해서 사용 INNER JOIN : 같은 컬럼 값에 관하여 JOIN 사용방법 내가 원하는 데이터가 무엇인가?(컬럼목록작성) 원하는 데이터가 어느 테이블에 있는가? 여러테이블에 있다면 각각의 테이블에 공통된 컬럼이 무엇인가? 예제 ‘송강’ 교수가 강의하는 과목을 검색해라 교수번호(pno), 교수이름(pname), 과목명(cname) professor, course pno1234SELECT p.pno, p.pname, c.cnameFROM professor p,course cWHERE p.pno = c.pnoAND pname = ‘송강’;","link":"/2018/11/27/OracleDB/oracle02/"},{"title":"다중컬럼 다중로우, FROM절 서브쿼리, 인덱스, 시퀀스, 뷰, PLSQL","text":"KOSTA DAY23DataBase 다중컬럼 다중로우 서브쿼리서브쿼리의 결과가 여러 컬럼 및 여러 행인 서브쿼리 예제 직무별 최대 급여자의 사원내역을 출력하라. 상기 이미지와 같이 IN을 사용하여 직무별 최대급여를 포함하는 모든 사원의 정보를 호출하였다.그러나, 타직무의 최대값과 같은 급여를 받는 사람도 호출되었다. 그 문제를 해결하기위해 job_id라는 컬럼을 추가로 호출하고 메인쿼리에서도 받을 수 있도록 하였다. 01번 부서원들과 보너스가 같은 사원을 검색하라. 부서번호 30번 최대급여자 보다 높은 사원을 출력하라. IN, ANY, ALL IN : 검색된 값 중에 하나만 일치하면 참 ANY : 검색된 값 중에 조건에 맞는 것이 하나 이상 있으면 참 ALL : 검색된 값과 조건에 모두 일치해야함 컬럼 &gt; ANY(서브쿼리) : 컬럼 &gt; MAX : 가장큰값 보다 크다. 컬럼 &lt; ALL(서브쿼리) : 컬럼 &lt; MIN : 가장 작은값 보다 작다. 컬럼 &gt; ANY(서브쿼리) : 컬럼 &gt; MIN : 가장 작은값 보다 크다. 컬럼 &lt; ANY(서브쿼리) : 컬럼 &lt; MIN : 가장 큰값 보다 작다. 예제 10번 부서에 가장 작은 급여자보다 작게 받는 급여자를 출력하라 FROM절 서브쿼리(TOP-N SQL)FROM절에서 사용되는 서브쿼리를 인라인 뷰(Inline View) 라고 한다. 예제 서브쿼리안에서 정렬시킨 후, ROWNUM 값으로 호출 ROWNUM값으로 정렬된 서브쿼리의 값 중, 중간에 위치한 값을 호출하기 위해서는 ROWNUM으로 정렬 된 서브쿼리가 필요하다.이해를 돕기 위해 아래 예시를 보자. BETWEEN AND 함수를 써서 5~9 번째 행을 호출하려 했지만 아무값도 나오지 않았다. ROWNUM 값과 함께 호출하는 서브쿼리를 만든후에 BETWEEN AND 함수를 사용하여 호출할 수 있다. 인덱스어떤 데이터가 어디에 있다는 위치정보를 가진 주소록 인덱스 생성 → 테이블의 데이터에 대한 Indexing → B-tree구조로 형성 B-tree 란?B-트리(B-tree)는 데이터베이스와 파일 시스템에서 널리 사용되는 트리 자료구조의 일종으로, 이진 트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다. 인덱스를 사용하는 이유 일정한 검색 속도를 유지 할 수 있다. 데이터량이 많은 경우, 검색속도를 향상 시킬 수 있다. WHERE절이나 JOIN 조건으로 자주 되는 컬럼에 사용 됨 인덱스 생성방법 Index의 이름은 관례적으로 talbe명_컬럼명_idx 로 생성한다. B_tree형성의 기준이되는 컬럼값은 보통 PRIMARY KEY값을 사용 시퀀스(SEQUENCE)테이블 내의 유일한 숫자를 자동으로 생성하는 자동번호 발생기 시퀀스를 사용하는 이유 오라클에서 데이터 베이스의 무결성을 위해 제약 조건을 설정하고, 그 중 행을 구분하기 위해 기본 키(PRIMARY KEY)를 설정한다.이때 데이터가 입력되는 순서를 기본키로 지정한다고 하였을 때, 사용자가 직접 입력해야 한다면 어려움이 있을 것이다.이 때, 시퀀스를 사용하요 키값을 설정한다면 사용자는 보다 편하게 작업이 가능하다. 시퀀스 사용 시, 주의사항 시퀀스는 이전단계로 돌아올 방법이 없음. 생성에 실수가 있어도 돌이킬 수 없다. 때문에 개발단계에서는 일단생성을 하고 추후 수정을 위해서는 DROP 후, 다시 생성해야한다. 시퀀스 사용방법12345CREATE SEQUENCE 시퀀스 이름;/*sequence.CURRVAL =&gt; dual테이블.=&gt;sequence로 생성된 번호가 몇 번까지 있는지 알려줌*//*시퀀스 사용*/INSERT INTO board VALUES (seq_seq.NEXTVAL, ‘a1’, ‘a’, ‘a’, sysdate, 0); 뷰반복적으로 쓰이는 문을 뷰로 생성하여 테이블처럼 사용 가능하게 만든 것 보안적인 내용을 다룸ex) 부서에 테이블을 제공할때, 급여 및 주민등록번호 등 보안관련 컬럼은 빼고 뷰로 생성하여 뷰를 제공 생성방법 1CREATE OR REPLACE VIEW [뷰명] AS 쿼리; PL/SQLProcedural Language Extension to Structured Query LanguageSQL에 프로그래밍 언어기능을 위해 절차적으로 확장한 언어 output에서 출력하기 위해 set serveroutput on; 설정필요 1234567891011121314set serveroutput on;DECLARE/*변수선언( — : 주석처리)*/v_no NUMBER(3) := 10;v_hiredate VARCHAR(30) := TO_CHAR(sysdate, ‘YYYY/MM/DD’);/*상수선언*/c_message CONSTANT VARCHAR(50) := ‘안녕하세요. PL/SQL’;/*실행부*/BEGIN/*DBMS_OUTPUT패키지 PUT_LINE 프로시저를 이용하여 결과 출력*/dbms_output.put_line(‘오늘부터 pl/sql 수업’);dbms_output.put_line(c_message);dbms_output.put_line(v_hiredate);END; 예제 사원번호 100번에 해당하는 사원이름과 부서명을 출력하세요.","link":"/2018/11/29/OracleDB/oracle04/"},{"title":"Notice-Project","text":"Project공지사항 웹 어플리케이션 사용스택 Java Spring(Boot) jQuery DB - h2(embedded DB) JPA SpringSecurity Oauth2(구글 로그인) 템플릿 엔진 - thymeleaf 디자인 - 부트스트랩 템플릿 활용 maven 프로젝트 빌드 및 실행방법 zip파일 다운 또는 clone 후에 아래와 같은 방법으로 실행합니다. IDE툴 사용하여 Application.class 실행 jar 파일로 실행 메이블 플러그인을 통해 jar파일 생성 clone 또는 압축푼 폴더의 위치를 찾아 아래 명령어 입력 mvn clean target폴더 아래 파일들 삭제 mvn package -DskipTests test제외하고 실행 target폴더 아래 jar파일 하나를 생성한다. 실행 java -jar (target아래 생성된 .jar파일명) 접속url : http://localhost:8080 (http://localhost:8080/notice/0 로 이동됩니다.) 기능 구현 메인화면, 로그인, 회원가입페이지를 제외하고 모두 로그인 되어야 서비스 이용이 가능하다.(로그인 되어있지 않을 시, 로그인 페이지로 이동된다.) 구글 로그인이 가능하다. 일반 회원가입 및 로그인이 가능하다. 사용자는 텍스트로 된 공지를 추가할 수 있다. 사용자는 공지를 수정/삭제할 수 있다. 사용자는 공지목록을 조회할 수 있다. 조회시 제목, 작성일, 작성자, 최종수정일, 내용이 조회 가능하다. 목록은 페이징 기능이 있다. 제목/글쓴이로 검색이 가능하다. 구현결과 회고로그인 google 로그인 및 자체 회원가입 및 로그인 기능을 구현을 목표하였다. Oauth2를 사용한 구글 로그인을 구현하고 블로깅했던 경험이 있으나, 자체 로그인을 동시구현해본적은 없었다. Oauth2 - 구글 로그인 회고내용 Security설정 시, form 로그인 및 구글로그인 동시 적용 web.ignoring().antMatchers()을 적용하여 security인증을 원하지 않는 페이지 주소를 지정한다. js, css등 정적 리소스에 관하여도 path를 지정해주어야한다. 스프링부트에서 정적 리소스 path는 /resources/static을 생략하고 지정해준다. 1&lt;link href=&quot;/css/sb-admin-2.min.css&quot; rel=&quot;stylesheet&quot;&gt; formLogin()을 사용하여, 뷰페이지 지정(없을 시, 스프링 시큐리티 에서 만든 페이지 적용) PasswordEncoder를 빈으로 등록하였다.(굳이 security 설정 class에서 등록할 필요는 없다.) UserDetailsService 구현 내가 구현한 회원 객체의 Service 클래스를 UserDetails를 implements한다. loadUserByUsername를 구현한다. return User객체는 스프링 시큐리티에서 만들어 주는 객체이다. authorities()는 권한과 관련되었는데 “ROLE_USER”라는 권한을 가지도록 한다. 자세한 내용은 잘모르겠습니다. 추후에 공부하여 다시 블로깅할 예정입니다. 로그인 유저 정보 처리 이전에 로그인 기록이 없는 구글 로그인 발생 시, setAuthenticationSuccessHandler를 다음과 같이 하여 정보를 DB에 저장하였다. 일반 로그인 시, UserDetailsServie에서 Session에 정보를 저장하여 사용할 수 있도록 한다.(구글 로그인 session처리는 이미 적용하였다.) 어려움 및 주의사항 로그인 폼 name=”username” 으로 줘야한다. 보완해야 할 점 로그인 정보를 같은 table에 넣어, 구글 로그인 후에 기본 로그인이 가능하다.. 개선이 필요.. 권한 분리 및 적용 thymeleaf 활용 타임리프를 처음 사용하여 어려움이 많았습니다. 사용 내용들을 정리 해보도록 하겠습니다. 활용내용 th:each, th:with, th:text, index 활용 123456789&lt;tbody th:with=&quot;offset=${list.getPageable().getOffset()}&quot;&gt; &lt;tr th:each=&quot;notice, index : ${list}&quot;&gt; &lt;td th:text=&quot;${list.getTotalElements() - (index.index + list.getPageable().getOffset())}&quot;&gt;1&lt;/td&gt; &lt;td&gt;&lt;a th:text=&quot;${notice.getTitle()}&quot; th:href=&quot;@{&apos;/notice/read/&apos; + ${notice.getId()}}&quot; class=&quot;readNoticeBtn&quot;&gt;New York&lt;/a&gt;&lt;/td&gt; &lt;td th:text=&quot;${notice.getWriter().getName()}&quot;&gt;Customer Support&lt;/td&gt; &lt;td th:text=&quot;${notice.getCreated()}&quot;&gt;2011/01/25&lt;/td&gt; &lt;td th:text=&quot;${notice.getModified()}&quot;&gt;2011/01/25&lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; th:with 지역변수를 설정하여 사용 할 수 있다. 지역변수이다. 위의 예는 tbody태그 밖에서는 사용할 수 없다.(동일레벨 태그도 불가능하다.) 자동완성으로 인해 th:width를 사용하여 오랜시간동안 오류를 찾지 못했습니다… 주의하세요.. th:text 에 지정한 값이 있으면, 해당 내용으로 text값이 출력된다. th:value또한 같은 기능이나, value을 설정 th:each를 사용하면 위와같이 collection객체를 받아 그안의 객체들을 없을 때 까지 꺼낼 수 있다. index를 같이 명명 해주면, index 값을 사용할 수 있다. index.index, count, size등을 사용할 수 있다.(index는 0부터 시작, count는 1부터 시작) th:if, th:unless, th:block, th:href 활용 1234567891011121314&lt;th:block th:unless=&quot;${first == 0}&quot;&gt; &lt;li class=&quot;paginate_button page-item previous&quot;&gt;&lt;a th:href=&quot;@{${first - 1}}&quot; class=&quot;page-link&quot;&gt;Previous&lt;/a&gt;&lt;/li&gt;&lt;/th:block&gt;&lt;th:block th:each=&quot;i : ${#numbers.sequence(first, last)}&quot;&gt; &lt;li class=&quot;paginate_button page-item&quot; th:unless=&quot;${i &gt;= list.getTotalPages() || i == list.getNumber()}&quot;&gt; &lt;a class=&quot;page-link&quot; th:text=&quot;${i + 1}&quot; th:href=&quot;@{${i}}&quot;&gt;1&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;paginate_button page-item active&quot; th:if=&quot;${i == list.getNumber() &amp;&amp; i &lt; list.getTotalPages()}&quot;&gt; &lt;a class=&quot;page-link&quot; th:text=&quot;${i + 1}&quot; th:href=&quot;@{${i}}&quot;&gt;1&lt;/a&gt; &lt;/li&gt;&lt;/th:block&gt;&lt;th:block th:if=&quot;${last+1 &lt; list.getTotalPages()}&quot;&gt; &lt;li class=&quot;paginate_button page-item next&quot;&gt;&lt;a th:href=&quot;@{${last + 1}}&quot; class=&quot;page-link&quot;&gt;Next&lt;/a&gt;&lt;/li&gt;&lt;/th:block&gt; 위의 예는 타임리프를 사용하여 페이징 처리를 한 것이다. th:block 타임리프 스코프 지정 th:if 값이 참일 때, 실행 th:unless 값이 거짓일 때, 실행 th:href @, $를 사용하여 url을 지정할 수 있다. 참고 블로그 : strongstar-스프링부트:타임리프 Page offset() 현재 페이지 시작 엘리먼트 인덱스 검색내용 저장 및 사용 검색 내용 페이징 처리 시, 처음 검색내용을 파라미터로 가지는 컨트롤러에서 NullPointException이 발생한다.이를 해결하기 위해 Session 또는 쿠키를 사용하여 값을 저장하려고 하였다. Cookie VS Session 쿠키는 클라이언트 쪽에 저장되어, 보안이 취약하다. 세션은 보안에 강하지만, 세션은 서버에 저장되어 메모리를 차지하기 때문에 많은 자료가 쌓이면 문제가 생길 수 있다. 검색내용은 로그인 정보와 같은 보안이 중요한 사항이 아니라고 판단하여 쿠키를 사용하기로 결정하였다. 쿠키저장 키워드를 쿠키에 저장 후, checkbox 체크값에 따라 제목, 글쓴이, 제목/글쓴이로 검색하는 컨트롤러로 매핑 @CookieValue HTTP쿠키 값을 HttpServletRequest등을 통해 읽을 필요없이 스프링 컨트롤러에서 파라미터로 전달 받을 수 있게해준다. required 속성 값을 이용해 필수여부 설정 (기본값은 true: 쿠키값없을 시, 에러발생) defaultValue 속성 값을 이용해서 기본값을 지정 Js cookie 자바스크립트에서 쿠키를 보다 편하게 사용할 수 있도록 도와주는 라이브러리 https://github.com/js-cookie/js-cookie 쿠키 저장 쿠키 사용","link":"/2019/05/24/Project/Notice-Project/"},{"title":"HotelReservation-System(DB Mini project)","text":"ProjectDataBase Mini ProjectHotelReservation-SystemProject github : https://github.com/cyr9210/Hotel-Reservation_System 구현내용 저희팀의 DB 실기평가를 위한 미니프로젝트의 주제로 숙박어플 여기어때를 벤치마킹한 숙박업소 예약 DB를 선택하였습니다. 각자 스마트폰에 어플을 설치하여 요구사항분석을 진행하였습니다. 최초의 요구사항분석은 보다 많이 나열하였으나, 2일이라는 짧은 시간과 현재 우리가 만들 수 있을 내용들을 선택하여 재구성하였습니다. 중복된 속성값들을 분류 ‘예약번호’ 를 주식별자로 가지지 않는 속성들을 분리 회원등급이라는 일반속성과 그 속성을 키값으로 가지고 분류될수 있는 적립률을 분리 데이터를 입력하기 위해 각 엔티티들의 관계를 설정하여 E-R Diagram 을 작성하였습니다. ‘예약목록’ 테이블의 경우, 숙소의 방번호 와 입실날짜가 중복되어 예약될 수 없기 때문에 PRIMARY KEY의 인자로 방번호와 입실일을 선택 SELECT문을 활용하여 회원명 및 회원등급을 조회 회원 측에서 요청될 수 있는 회원번호로 예약현황 조회를 구현(JOIN활용) 서브쿼리문을 활용하여 가장 싼 숙소 TOP3를 조회(FROM절 서브쿼리문 활용) 호텔 전체 평균 평점보다 평점이 높은 숙소 검색(서브쿼리문 활용) PL/SQL을 활용하여 SQL내에서 예약기능을 구현(DUP_VAL_ON_INDEX(무결성위배) 예외발생 시, ROLLBACK 하도록 예외처리 하였습니다.) 앞서 만들었던 PL/SQL을 PROCEDURE로 만들어 EXECUTE문 활용하여 실행 느낀점2일동안 조원들과 고민하고 고민하여 미니프로젝트를 완성하였다.프로젝트를 진행하며 앞서 배웠던 내용들을 복습할 수 있는 시간이되어 좋았다.데이터모델링을 하는 부분이 가장 어려웠는데, 각 엔티티들의 관계설정이 가장 어려웠다. 진행하면서 데이터 모델링 부분이 정말 어렵고 현 실무자들은 데이터들의 검색속도 및 성능들까지 정말 대단하고 어서 빨리 취업하여 배우고 싶다는 생각을 하였다.부족한 결과물이지만, 나는 개인적으로 부족한 부분을 복습도 할 수 있었고, E-R Diagram을 작성하며 관계부분을 이해하는데 도움이되어 만족스러웠다.","link":"/2018/12/07/Project/Hotel-Reservation-System/"},{"title":"TradeFruit_System(Web Mini Project)","text":"ProjectWeb Mini ProjectTradeFruit_System 개선사항이 필요한 웹페이지를 찾아서 배운내용을 토대로 리뉴얼(시간 관계상 전체 페이지가 아닌 3~4페이지) 대상 페이지 : 농산물직거래장터 Project github : https://github.com/cyr9210/Trade_Fruit_Project 구현내용 농산물 직거래 장터는 보다시피 오래전에 제작된 웹페이지로 모든 레이아웃이 테이블 단위로 되어있으며, 모든 기능들을 구현 시, 페이지 리로딩이 된다. 이 페이지를 ajax를 활용하여 비동기식으로 구현하고, 부트스트랩 레이아웃를 활용해 보다 한눈에 들어오도록 리뉴얼을 해보고자 하였다. 전체적인 레이아웃을 부트스트랩을 활용하여 구성하였다. 하기 프로젝트 설명 주제에서 부트스트랩 활용방법에 대해 알아보자. 상단에 위치한 네비게이션 바를 클릭하였을때, 해당 버튼에 대하여 css가 변경되고, 하단에 위치한 현재위치탭에 현재클릭한 메뉴의 이름이 적용되는 모습을 구현하였다. 부트스트랩의 ‘active’ 클래스를 활용하여 네비게이션 바 클릭 시, 전체 버튼에 active 클래스를 제거(removeClass), 클릭한 버튼에 active클래스를 추가(addClass)한다. 전체판매메뉴를 클릭 시, 홈화면의 메뉴들을 hide시키고, 전체판매의 메뉴들을 화면에 명시하도록 구성하였다. 아직 jsp 배우지는 않았지만 수업시간중 샘플로 보여주신 jsp파일을 활용하여 묻고답하기에 방명록형식으로 게시판을 구현하였다.(Ajax함수 활용) JQuery plugin ui를 사용하여 로그인 버튼 및 회원가입 버튼을 클릭 시 , 흔들리는 이벤트를 구현하였다. 부트스트랩 활용 부트스트랩 공식홈폐이지 → 부트스트랩 다운css/js파일 및 image 파일이 있다.(.min : 최소화 한것) 링크다운받은 css파일 및 js 파일 연결 느낀점이번 프로젝트가 여태껏한 프로젝트들 중 가장 힘들었다.부트스트랩 사용방법을 배우지 않았기에 찾아보면서 하는게 쉽지 않앗다.css가 맘처럼 구현되지 않는 답답함과 함께 이벤트들을 구현할 때 마다, 너무 많은 에러들 몸과 마음이 지쳤다.기한내에 완성하기가 쉽지 않았고 발표 바로 직전까지 작업을 하였다.이런 힘든사항들이 있었던 만큼 결과물이 만족스럽지 못했고, 다른조들의 발표를 보면서 많이 반성했다. 이번 프로젝트 중 내가 부족하다고 느낀 파트JQuery 활용 Ajax구현 / Java → Json, Json → Java","link":"/2018/12/19/Project/TradeFruit-System/"},{"title":"MenuList System(Java Mini Project)","text":"ProjectJava Mini Project MenuList_SystemProject github : https://github.com/cyr9210/Menu-List-System 구현내용 상세설명 Customer(고객) 와 Admin(관리자)는 추상 클래스 User를 상속받는다. User는 추상메소드 showMenu를 가지고, Customer 및 Admin은 showMenu를 오버라이딩 한다. Customer 와 Admin에는 각각의 기능들을 구현할 수 있는 일반 메소드를 가진다. MenuManager 클래스는 Menu객체를 ArrayList&lt;menu>를 담는다. Menu는 4개의 String 변수를 갖는다. Manager 클래스는 생성한 클래스들을 객체화한다. 생성한 객체들을 상호작용하여 요구하는 기능들을 구현하는 메소드를 가진다. Main클래스는 Manager클래스에서 구현한 메소드 기능들을 불러온다. 느낀점우리조도 나름 잘 구현했다고 생각했는데, 다른 조들의 발표내용들을 보고 너무 잘해서 놀랐다.이번 프로젝트의 가장 아쉬운점은 접근제어자를 사용하지 않고 대부분 default 상태로 접근을 제어하였다는것이다.get /set 메소드를 많이 사용한만큼 해당변수들에 대해 private 접근제어자를 설정했어야 됬다고 생각한다.시간이 많이 없었던 탓인지 정신없이 하다보니 놓친것 같다.이번 프로젝트를 통해 정말 많이 부족함을 느끼고 더 열심히 배우고 많은 반복 복습이 필요할 것 같다.","link":"/2018/11/23/Project/MenuList-System/"},{"title":"section, article, css, 선택자, float, 박스모델, 포지셔닝","text":"KOSTA DAY29Web sectionHTML을 만들때 주의할점 웹표준을 지켜야 한다. 시멘틱한 웹이어야 한다. (메타태그 및 헤드태그를 사용) 시멘틱태그 좀 더 문서의 의미를 강조 div태그 만으로 분류하는 것은 의미 부여가 약함 section : 제목과 단락으로 나누어질 수 있는 경우 사용 article : 독립적인 내용을 가지고 있을 경우 사용 (예를들어 댓글, 기사 등) 주관적으로 나누어질 수 있기 때문에 사용자의 마음 &lt;div>는 여전히 많이 사용됨 예제 section태그를 사용하여 분류하였다. article 태그 사용하여 분류 CSS 인라인 스타일 적용 내부스타일 적용 외부링크 스타일적용(가장많이쓰임) 외부 스타일 적용 (import) 선택자일반선택자/복합선택자 클래스 선택자, ID선택자 많이 활용됨 하위선택자, 자식선택자 많이 활용됨(하위는 자손까지/자식선택자 자식까지만 선택된다.) 빨간박스의 내용은 JQUERY에서도 사용됨으로 잘 숙지하는것이 좋다. 속성선택자 font속성 text속성 인터페이스 속성 display : none; → 화면에서 안보이도록 한다. float박스가 화면의 어느 위치에 배치할 것인지 설정하기 위해 사용한다. 이미지를 인라인 형식처럼 한쪽으로 보냄 clear : 제외시킴 margin등의 조건 시, 주의(float대상 크기도 고려해야한다.) 박스모델 box : width, height 여백 : padding, margin 성질 : display, float, position 포지셔닝 static : 기본값으로 일반적인 내용물의 흐름 상단과 좌측에서의 거리를 지정할 수 없다. relative : 상대적인 top, left 거리를 지정(원래있어야할 위치 기준) absolute : 자신의 상위 box속에서 top, left, right, bottom등의 절대적인 위치를 지정(전체를 기준) relative는 다른 박스에 영향을 끼치지 않고, absolute는 영향을 끼친다. 예제","link":"/2018/12/10/Web/Web02/"},{"title":"Project_kogile","text":"ProjectKOSTA 최종프로젝트KogileProject github : https://github.com/cyr9210/Project_kogile_Final 구현내용로그인, 회원가입 카카오 로그인 및 회원가입이 가능하다. 프로젝트 로그인된 아이디가 참가하고 있는 프로젝트 목록을 보여준다. 생성할 수 있다. 프로젝트의 정보를 확인, 수정, 삭제할 수 있다. 포스트 이동 해당 작업을 이동할 수 있다. DB에도 반영된다. 체크리스트 상세보기에서 체크리스트를 추가할 수 있다. 체크리스트에 리스트를 추가 할 수 있다. 체크된 작업을 계산하여 완성률을 보여준다.(모달창과 상세보기 페이지 모두에서 확인 가능하다.) 라벨 프로젝트 생성 시, 각 칼라별 라벨이 기본적으로 생성된다.(4개) 라벨을 추가할 수 있다.(프로젝트 별) 라벨을 클릭 시, 라벨을 가시적으로 표현할 수 있다.(모달창과 상세보기 페이지 모두에서 확인 가능하다.) 마감일 마감일을 등록할 수 있다. 삭제, 수정이 가능하다. 메인 화면에서 D-day까지 남은일을 확인 할 수 있다. 공지사항 기본적인 게시판을 구현하였다. (프로젝트 별 소유) 검색 프로젝트 및 회원을 검색할 수 있다. 프로젝트를 클릭 시, 해당 프로젝트로 이동한다. 회원을 클릭 시, 해당 회원을 현재 프로젝트에 초대한다. 초대된 회원은 알림이 발생한다. 댓글(태그) 및 알림 댓글 등록 후, 태그 input란에 현 프로젝트원을 입력 시, 자동완성이 된다. 태그된 회원은 알림이 발생한다. 확인한 알림은 확인상태로 변경된다. 회고gitignoreProject에 원하지 않는 Backup File이나 LogFile, 혹은 컴파일 된 파일들을 Git에서 제외시킬수 있는 설정 File이다. gitignore파일 생성 1touch .gitignore gitignore.io에 접속하여, 언어 및 IDE등을 입력하면 자동으로 파일내용을 만들어준다. 만약 git 사용도중에 gitignore설정 시, 아래와 같이 실행한다. 전체 내용 및 캐쉬삭제 후, 다시 업로드1234git rm -r --cachedgit add .git commit -m &quot;commit message&quot;git push origin &lt;branch_name&gt; OS 및 툴을 다양하게 사용하고 있던 우리조는 gitignore를 설정하지 않아 어려움을 겪었다.각자의 브랜치를 만들어서 작업도중에 이러한 사실을 알게되어, 모든 조원의 브랜치를 merge한 후, gitignore를 설정해줌으로써 해결하였다. UNION 쿼리문 활용 union : 합집합 중복된 행은 제거 union all : 합집합 중복된 행까지 포함 union 쿼리문을 사용하여 일반가입회원과 카카오톡으로 가입한 회원을 합하여 사용하였다. Oracle Hint 여러개의 테이블을 join하여 사용 시, Hint절에 alias 이름을 사용해야 한다. 원하는 순서대로 정렬하기 위해서는 메인 테이블을 기준으로 여러개의 hint를 줘야 한다. 참고 블로그 : 양군의 놀이터 한글처리 필터 매핑을 반드시 해줘야한다. focus 이벤트버블링 발생안함 focus : 포커스 될 때, 이벤트 실행 blur : 포커스에서 벗어날 때, 이벤트 실행 버블링 발생 focusin : 포커스 될 때, 이벤트 실행 focusout : 포커스에서 벗어날 때, 이벤트 실행 예제 동적 생성된 tag에 대한 이벤트 동적으로 생성된 tag들은 이벤트가 먹지 않는 경우가 있다. document 객체를 기준으로 이벤트를 줄 경우 해결이 가능하다. .closest() vs .parents() .closest() 현재 요소부터 시작 제공된 선택자와 일치하는 요소를 찾을 때까지 DOM트리를 탐색 없거나 하나의 요소(zero or one)를 포함한 jQuery객체를 반환 .parents() 부모 요소부터 시작 문서의 root요소부터 DOM트리를 탐색 각 부모 요소들로 임시 집합을 구성하고 제공된 선택자에 의해 임시 집합에서 추출 없거나 하나 이상의 요소(zero or multiple elements)를 포함한 jQuery객체를 반환 문자 date 타입변환 String to Date 123String fromString = &quot;2013-04-08 10:10:10&quot;;SimpleDateFormat transFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);Date toDate = transFormat.parse(fromString); Date to String 123Date fromDate = new Date();SimpleDateFormat transFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);String toString = transFormat.format(fromDate); JsonFormat 어노테이션 활용하면 해당 객체로 들어오는 Json객체에 대하여 형변환을 해준다. (양방향, String ↔︎ Date) timezone으로 현재 위치 설정 빽팁(`)활용 url, tag 등을 작성시 빽팁(`)을 활용하면 jQuery문법처럼 편하게 사용이 가능하다. explorer는 지원하지 않는다. Json객체 변환 ajax 시, 해당 설정 반드시 해주어야 한다. 이벤트 적용 팁포스테 제목 변경에 관한 이벤트 적용을 좋은예로 볼 수 있다. isUpdate라는 상태값을 선언 클릭 시, 상태값을 true로 변경 focusout 또는 keyCode13(enter)을 눌렀다가 뗄 때 false로 다시 변경 상태가 true일 때, 실행되는 메소드를 정의하고 focusout, 13keyup에 메소드를 실행하도록 한다. form태그의 serialize serializeObject 함수 정의 json객체로 serialize해준다. 사용 auto complete 사용 시, 모달창에 가려져 안나올 경우 해결방법 appendTo 사용하여 autoComplete를 앞으로 불러온다. SessionAttributesSession 저장 Session 사용 ResponseBody 한글처리1234@RequestMapping(value=&quot;/add&quot;, produces=&quot;application/text; charset=utf8&quot;)public @ResponseBody String add(){ return &quot;성공&quot;;} produces를 활용하여 명시적으로 인코딩 느낀점kosta의 교육이 끝났다.4개월이란 짧은 시간동안 많은 것을 배웠고, 최종 프로젝트를 통해서 활용해 볼 수 있었다.처음엔 어떻게 해야하나, 감도 잡히지 않았는데.. 조원들도 잘 참여해주고, 의견도 많이 내줘서 나름 괜찮은 결과물을 만들 수 있었던 것 같다. (프로젝트 우수상도 받았다.)교육을 통해서 배운것도 많지만, 좋아하는 일을 찾게 된 것 같아 값진 교육이었다고 생각한다.😀이제 교육이 끝났지만 앞으로가 더 중요하다고 생각한다.공부할게 너무 너무 많이 남아있다. 끝났다고 게을리하지않고 매일 꾸준히 노력할 것이다.좋아하는 일을 찾은 만큼 노력해서 좋은 결실을 맺을 것이다.","link":"/2019/02/27/Project/kogile/"},{"title":"Web, HTML","text":"KOSTA DAY28Web WEB비지니스 로직 처리→ Java비지니스의 데이터값 저장 및 구조적인 관리 → RDB비지니스 모델 → web UI적인 부분들을 웹이라는 환경을 통해 사용할 수 있도록 한다. Java SE를 이용해서 서버로 이용할수 없다. → 서블릿 / JSP 로 구현 필요 서블릿(servlet) 웹프로그래밍에서 클라이언트의 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바 프로그래밍 기술 간단히 말하자면, 자바를 사용하여 웹을 만들기위해 필요한 기술이며 클라이언트의 요청을 처리하고 그결과를 다시 전송하는 역할을 하는 자바 프로그램 CSS 종속형 시트 (Cascading Style Sheet)마크업 언어가 실제 표시되는 방법을 기술하는 언어로 HTML과 XHTML에 주로 쓰이며, XML에서도 사용할 수 있다. W3C의 표준이며, 레이아웃과 스타일을 정의할 때의 자유도가 높다. 언어가 웹사이트의 몸체를 담당한다면 CSS는 옷과 액세서리 같은 꾸미는 역할을 담당한다고 할 수 있다. 즉, HTML 구조는 그대로 두고 CSS 파일만 변경해도 전혀 다른 웹사이트처럼 꾸밀 수 있다. HTML , CSS 레이아웃 화면 구성 웹의 필요성 마케팅 , 홍보 효과로서의 웹 정보교환의 수단 인터넷 문화자체 웹 서비스 웹 플랫폼의 구성요소클라이언트 기술 RIA(Rich Internet Application) 기술의 등장 RIA웹 애플리케이션의 장점은 유지하면서 기존 웹 브라우저 기반 인터페이스의 단점인 늦은 응답 속도, 데스크톱 애플리케이션에 비해 떨어지는 조작성 등을 개선하기 위한 기술의 통칭이다. 즉, 별도의 설치가 필요 없는 웹 브라우저 기반의 애플리케이션 배포 장점과 서버 측 웹 서비스와의 연동, 마크업 언어 기반의 선언적 애플리케이션 구성 등은 유지하면 서 데스크톱 애플리케이션과 대등한 사용자 경험을 주는 것을 목표로 하는 기술이다.동적인 기능과 화려한 UI를 웹에서 구현 컨텐츠 기술 기존의 웹서비스는 내부 DB에 국한 많은 웹 서비스들은 자신의 DATA를 공유(Open API) 웹전체를 하나의 DATA로 볼 수 있게 됨 서버기술 다양한 웹개발 언어 및 프레임워크 등장 표준기술 웹표준 준수의 확장 기존 explorer 구버전의 경우 웹표준을 지키지 않음 웹의 접근성 W3C 표준 준수 반응형 웹 시각장애인 접근 가능하도록 웹표준 W3C토론을 통해 나온 권고안 목표 웹표준스펙 웹페이지 내용, 구성 = HTML 디자인 = CSS 이기종간 데이터 전달 = XML 자바스크립트, JQUEARY, REACT, VIEW HTML : 화면구성, 내용 XML : 주고 받을수 있는 정보 위의 내용으로 만으로는 기능구현 부족이벤트 기능 : JavaScript Java script 의 할일이 늘어남 ( 과거 오류창 띄우기 정도.. 현재 결재 및 여러기능 구현)→ JQUEARY 등장 자바스크립트의 라이브러리 기능들이 점차 늘어나 포화상태가됨→REACT, VIEW (프레임워크) 등이 나타났다. HTMLHyper Text Mark up Language 역사 과거 구버젼 HTML의 경우, 플러그인 기술 사용ex) 웹어플리케이션 별 Active X 설치 필요 HTML5 자체 브라우저 기능만으로 구현(플러그인 기술 대체) 최근 웹브라우저는 모두 HTML 5를 지원 구조 DOCTYPE : 문서타입정의(HTML버젼의미) head : 필요한걸 불러오는 작업, 사전에 선언되야하는 부분\u001f, setting, 리소스불러오기 등 화면에 보여지는것과 상관 없다. body : 문서의 내용을 표시한다. 구동원리 서버는 클라이언트의 요청을 분석하여 결과값을 HTML로 전송한다. 서버는 결과값을 전송 후 클라이언트와 접속을 끊는다. 클라이언트는 서버로부터 전달받은 HTML을 웹브라우저에서 표시한다. 각 웹브라우저는 브라우저 엔진이 내장되어 있고, 이 엔진이 태그를 해석하여 화면을 표시한다. 마크업작성 태그는 브라우저에 의해 해석되며, 각 태그의 의미는 모두 다르다. 태그내용이 화면에 표시되지 않음 Body, Title, BR 등과 같은 텍스트는 화면에 표시하지 않음 태그사이에 입력된 텍스트를 브라우저에 보여줌 &lt;h2>태그를 사용하여 제목을 입력 &lt;br>태그를 사용하여 줄바꿈 &lt;strong> 태그를 사용하여 강조 &lt;mark>태그를 사용하여 강조 DOCTYPE브라우저는 현재 문서가 어떤형태의 문서인지 판단하는 목적으로 DOCTYPE을 확인한다. 선언되지 않을 경우, HTML을 해석하고 출력하는데 많은 시간 소요 HTML5에서는 &lt;!DOCTYPE html&gt;로 간소화 하였다. Tag 구조와 의미를 브라우저로 전달한다. 대소문자 구별 없음 시작태그(&lt;&gt;)와 종료태그(&lt;/&gt;)로 쌍을 이루며 중첩되지 않도록 한다. head &lt;head>태그는 부라우저에게 html문서의 머리부분임을 알려준다. &lt;title>, &lt;meta>, &lt;style>, &lt;script>, &lt;link>태그를 포홈할수 있다. &lt;title> : 문서의 제목을 의미, 브라우저 제목표시줄에 태그내용이 표시 &lt;title>태그 외 다른태그로 표현한 정보는 화면에 나타나지 않는다. &lt;style> , &lt;link> : 스타일을 입힌다.(css) &lt;script> : 자바 스크립트를 불러올 수 있다. &lt;meta> : 문서에대한 일반 정보 name , content 속성을 이용하여 다양한 정보를 나타낸다. 현재 html5는 &lt;meta>만 이용하여도 시메틱한 웹으로 바꾼다. Body문서의 내용을 작성하는 부분 에 위치하며 내부 태그 및 을 제외한 모든 태그를 포함한다. id속성을 이용, 문서 내에서 유일하게 태그를 식별한다.(id 속성 중복 X) class 속성을 이용하여 여러태그에 공톡적인 특성을 부여 가능(중복가능) h태그(heading) 문단의 제목을 지정할때 사용 &lt;h1> ~ &lt;h6>으로 구성 ( 숫자가 커질수록 크기가 작아진다.) 단순히 문자가 크고작음을 표현하는것이 아니고, 문서의 구조를 표현하기위 사용한다. 범위에 따른 태그 분류블럭레벨, 인라인 으로 나눌 수 있다. 블럭레벨 줄바꿈이 일어나며, 너비가 전체너비가 되는 형태이다. 종류 : h, div, ul, ol, li, p 등이 있다. 인라인 줄바꿈이 일어나지 않는다. 종류 : a, img, span 등이 있다. 목록형 태그 : 폐이지로 이동하는 명령어 href 는 문서내 특정지점으로 이동 가능 예시 테이블요소 colspan : 열병합 rowspan : 행병합 예제 오브젝트 ,이미지요소 alt : 간단한 그림의 설명을 툴팁으로 보여줌, 이미지가 나타날 수 없는 경우 대체 텍스트를 설정함 src : 이미지 자원의 위치를 지정함 alt는 웹접근성을 위해서 사용된다.(시각장애인) 예제 FORM 요소 사용자로부터 데이터를 입력받아 서버에서 처리하기 위한 용도로 사용 사용자의 요청에 따라 서버는 html폼을 전달(회원가입 양식, 검색양식 등) submit : 사용자가 html폼에 적절한 데이터를 입력한 후, 서버로 전송 서버는 사용자의 요청을 분석한 후, 데이터 등록 or 조회 후 결과 반환 사용자가 입력하기 위한 컨트롤 요소들은 모두 &lt;form>태그 하위에 위치해야함 action 속성 : 데이터를 전송할 URL을 지정 method속성 : 데이터 전송방식을 지정(GET, POST) form 컨트롤 요소 예제 input 태그안의 text, email, date, color, range, checkbox, radio 활용 및 select , feild 태그 활용","link":"/2018/12/07/Web/Web01/"},{"title":"스프링 기반 REST API 개발03 - HATEOAS와 Self-Describtive Message 적용 (HATEOAS-Resource, REST Docs, 테스트용 DB와 설정 분리, API 인덱스)","text":"스프링 기반 REST API 개발(inflearn)3 - 백기선HATEOAS와 Self-Describtive Messgae 적용스프링 HATEOAS 소개 api를 만들 때, REST하게 resource를 보다 쉽게 제공해주는 라이브러리 reference문서 링크 만드는 기능 문자열 가지고 만들기 컨트롤러와 메소드로 만들기 리소스 만드는 기능 리소스: 데이터 + 링크 링크 찾아주는 기능 Traverson LinkDiscoverers 강좌에서는 다루지 않는다.. 링크 HREF : URL, URI등을 설정 REL : 현재 리소스와의 관계를 설정해준다. self profile update-events query-events … 스프링 HATEOAS 적용EventResource 만들기 extends ResourceSupport 의 문제 data resource가 Json으로 감싸져 있다. 해결방안 @JsonUnwrapped extends Resource @JsonUnwrapped가 포함되어 있다. 링크정보도 추가 할 수 있다. test 결과 링크정보를 포함하고 있기 때문에 response의 content Type은 hal+json 스프링 REST Docs 소개 reference문서 스프링 MVC test를 사용하여 rest api문서의 일부분들을 생성하는데 유용한 기능을 제공해주는 라이브러리 test를 실행하면서 요청과 응답 헤더등의 정보들을 가지고 문서의 조각(snipet)을 생성한다. 만들어진 문서의 조각을 사용하여 REST API 문서를 만들 수 있다. Ascidockor라는 툴을 사용하여 Aschidoc문법에 맞춘 snipet을 html문서로 만들어준다. MockMVC, WebTestClient, RESTAssured 등을 사용하여 만든 테스트에 적용할 수 있다. 스프링 버전5, Java8 이상 지원 스프링 REST Docs 적용REST Docs 자동설정12@AutoConfigureRestDocspublic class EventControllerTest { } RestDocs 사용 RestDocMockMvc 커스터마이징 RestDcosMockMvcConfigurationCustomizer 구현한 빈 등록 다른 기능을 적용하고 싶다면, processors 목록 을 확인하고 적용시키면 된다. 설정을 적용시키기 위해서는 TestClass에서 Import해주어야한다. 스프링 REST Docs - 각종 문서 조각 생성하기요청 필드 문서화 requestFields() + fieldWithPath() responseFields() + fieldWithPath() requestHeaders() + headerWithName() responseHedaers() + headerWithName() links() + linkWithRel() Relaxed 접두어 ResponseFields에 링크 정보가 포함되기 때문에 링크정보를 문서화 했음에도 불구하고, 에러가 발생한다 이러한 문제는 Relaxed라는 prefix를 붙여줌으로서 해결 할 수 있다. 장점: 문서 일부분만 테스트 할 수 있다. 단점: 정확한 문서를 생성하지 못한다. Relaxed를 쓰는거 보다는 ResponseFields에 링크정보를 중복으로 포함시키는 것을 추천한다. (변경사항이 있을 시, 반영을 위해서) 스프링 REST Docs - 문서빌드 reference 문서 Maven 플러그인 설정 pom.xml에 설정 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt; &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;generate-docs&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;process-asciidoc&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;backend&gt;html&lt;/backend&gt; &lt;doctype&gt;book&lt;/doctype&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt; &lt;artifactId&gt;spring-restdocs-asciidoctor&lt;/artifactId&gt; &lt;version&gt;${spring-restdocs.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-resources&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt; ${project.build.outputDirectory}/static/docs &lt;/outputDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt; ${project.build.directory}/generated-docs &lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; Gradle 플러그인 설정 build.gradle에 설정 12345678910111213141516171819202122232425262728plugins { id &quot;org.asciidoctor.convert&quot; version &quot;1.5.3&quot;}dependencies { asciidoctor &apos;org.springframework.restdocs:spring-restdocs-asciidoctor:2.0.2.RELEASE&apos; testCompile &apos;org.springframework.restdocs:spring-restdocs-mockmvc:2.0.2.RELEASE&apos; }ext { snippetsDir = file(&apos;build/generated-snippets&apos;)}test { outputs.dir snippetsDir}asciidoctor { inputs.dir snippetsDir dependsOn test }bootJar { dependsOn asciidoctor from (&quot;${asciidoctor.outputDir}/html5&quot;) { into &apos;static/docs&apos; }} 템플릿 파일 추가 src/main/asciidoc/index.adoc을 만들고 asciidoc 문법에 맞추어 작성한다. Maven 프로젝트 target/generated-docs target/classes/docs 상기 두개의 디렉토리에 index.html이 생성되며 해당 파일을 실행하거나 어플리케이션 실행 시, /docs/index.html에서 확인할 수 있다. Gradle 프로젝트 build/asciidoc/html5 Maven과 마찬가지이다. 작동내용 prepare-package :: process-asciidoc package할때 prepare-package 과정에서 asciidoc을 처리하라는 process-ascidoc기능을 실행하는것이다. src안의 모든 asciidoc문서를 html로 만들어준다. (generated-docs위치로) prepare-package :: copy-resources generated-docs에서 classes/docs/static으로 복사한다. asciidoc을 먼저 처리하고 후에 복사하기 때문에, 순서가 중요하다. (process-asciidoc -&gt; copy-resources) profile 링크 추가 REST의 조건인 Self-description을 만족하기 위해 생성한 문서의 링크를 profile이란 이름으로 추가해준다. RESTdocs문서 추가를 위해 테스트를 추가해준다. Controller에서 profile 링크 정보를 추가해준다. 테스트용 DB와 설정 분리하기 테스트 할 때는 H2 애플리케이션 서버를 실행할 때는 PostgreSQL을 사용하도록 변경 의존성 추가 및 수정1234567891011&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; H2 의존성은 scope를 test로 변경 PostgreSQL 의존성을 추가한다. 참고 : 스프링 부트 활용 -스프링 데이터 - PostgreSQL 설정 DB 설정(application.properties) 1234spring.datasource.username=postgresspring.datasource.password=passspring.datasource.url=jdbc:postgresql://localhost:5432/postgresspring.datasource.driver-class-name=org.postgresql.Driver 하이버네이트 설정(application.properties) 123456spring.jpa.hibernate.ddl-auto=create-dropspring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=truespring.jpa.properties.hibernate.format_sql=truelogging.level.org.hibernate.SQL=DEBUGlogging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE Profile 활용하여 Test 설정 application-test.properties 파일을 test - resources 디렉토리에 생성 및 오라이딩할 내용만 작성한다. 1234567spring.datasource.username=saspring.datasource.password=spring.datasource.url=jdbc:h2:mem:testdbspring.datasource.driver-class-name=org.h2.Driverspring.datasource.hikari.jdbc-url=jdbc:h2:mem:testdbspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect 테스트 클래스에서 @ActivePorfile(“test”) 적용 실행 시, profile = test로 실행된다. 인덱스 핸들러 만들기인덱스 핸들러123456@Getmapping(\"/api\")public void ResourceSupport root() { ResourceSupport index = new ResourceSupport(); index.add(linkTo(EventController.class).withRel(\"evnets\")); return index;} 다른 리소스에 대한 링크 제공 문서화 에러 리소스 에러 발생 시, 돌아갈 수 있는 api는 index 이다.그에 따라서 인덱스로 가는 링크를 제공한다. ErrorsResouce 생성 (extends Resouce) 123456public class ErrorsResource extends Resource&lt;Errors&gt; { public ErrorsResource(Errors content, Link... links) { super(content, links); add(linkTo(methodOn(IndexController.class).index()).withRel(\"index\")); }} Errors 사용하던 부분 ErrorsResouce로 변경 문제점 @JsonUnwrapped JSON arrays는 unwrap이 되지 않는다. Serializer를 재정의 하거나 Content로 wrapped 되어있는 상태로 쓴다.(여기서는 wrapped되어있는 상태로 쓰기위해서 TestCase를 수정했다.)","link":"/2019/08/08/RestAPI/restapi03/"},{"title":"예상 면접 질문","text":"면접 대비 - 예상 면접 질문개발상식 객체지향 프로그래밍(Object Oriented Programming) 이전의 프로그래밍이 컴퓨터 중심이었다면, 인간 중심적 프로그래밍 패러다임이라고 할 수 있다. 현실세계를 프로그래밍으로 옮겨와 프로그래밍 하는것. 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다. 이것을 추상화라한다. 장점 코드에 대한 재사용성이 높다. 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 있으므로 버그 발생이 줄어든다. 내부적으로 어떻게 동작하는지 몰라도 개발자는 라이브러리가 제공하는 기능들을 사용할 수 있기 때문에 생산성이 높아지게 된다. 객체 단위로 코드가 나눠져 작성되기 때문에 디버깅이 쉽고 유지보수에 용이하다. 데이터 모델링을 할 때 객체와 매핑하는 것이 수월하기 때문에 요구사항을 보다 명확하게 파악하여 프로그래밍 할 수 있다. 단점 객체가 상태를 갖는다. 변수가 존재하고, 이 변수를 통해 객체가 예측할 수 없는 상태를 갖으며, 애플리케이션에 버그를 발생시킬 수 있다. 설계원칙 SRP(단일 책임 원칙) 클래스는 단 하나의 책임을 가져야한다. 클래스를 변경하는 이유는 오직 하나의 이유여야한다. OCP(Open-Closed Principle)개방 폐쇠 원칙 확장에는 열려있어야하고, 변경에는 닫혀 있어야한다. LSP(리스코프 치환 원칙) 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위타입을 사용하는 프로그램을 정상 동작해야한다. ISP(인터페이스 분리 원칙) 인터페이스는 인터페이스를 사용하는 클라이언트 기준으로 분리해야한다. DIP(의존 역전 원칙) 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. RESTfulAPI REST : REpresentational State Transfer 분산 하이퍼미디어 시스템(예: 웹)을 위한 아키텍쳐 스타일 API 설계 중심에 자원(Resource)이 있고, HTTP method를 통해 자원을 처리하도록 하는것. 6가지 원칙아키텍쳐는 제약조건의 집합 아래 6가지 원칙을 지켜야한다. Uniform Interface Stateless Caching Client-Server Hierarchical system Code on demand(optional) http만 잘 따라도 Uniform Interface조건을 제외한 나머지 조건은 만족한다. Uniform Interface의 제약조건 identification of resource 리소스가 URI로 식별되면 된다. mainpulation of resources through representations 리소스 생성/변경/삭제 등의 일을 할때 http메세지에 표현을 담아서 전송해야한다. self-descriptive 메세지는 스스로 설명해야 한다. 목적지를 추가해야한다. ContentType 헤드가 필요하다. 해석에 필요한 명세를 넣어줘야한다. hypermedia as the engine of application state(HATEOAS) 애플리케이션에 상태가 항상 Hyperlink를 이용해 전이 되어야 한다. 링크정보를 포함해야 한다.(link헤더를 통해서..) 장점 독립적 진화 서버와 클라이언트가 각각 독립적으로 진화한다. 서버의 기능이 변경되어도 클라이언트 업데이트가 필요없다. Open API를 제공하기 쉽다. 원하는 타입으로 데이터를 주고 받을 수 있다. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다. 단점 사용할 수 있는 메소드가 4가지 밖에 없다. 분산 환경에는 부적합하다. HTTP통신 모델에 대해서만 지원한다. TDD(Test-Driven Development) 말 그대로 테스트가 코드 작성을 주도하는 개발방식 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스 요구되는 새로운 기능에 대한 테스트 케이스를 작성하고, 통과하기위한 가장 간단한 코드를 작성한 후, 상황에 맞게 리팩토링한다. 단점 빠른 생산성이 요구되는 시점에서 TDD 는 큰 걸림돌이 될 수 있다. MVC 자료구조Array VS LinkedListArray 논리적 저장 순서와 물리적 저장순서가 일치한다. 인덱스로 해당 원소에 접근이 가능 삽입 또는 삭제시 인덱스값을 shift 해야하는 비용이 생긴다. LinkedList 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있다. Search과정에 있어 첫번째 원소부터 전부확인해야 한다. Tree구조의 근간이 되는 자료구조이다. Stack and QueueStack 선형 자료구조의 일종으로 Last In First Out(즉, 나중에 들어간 원소가 먼저 나온다) Queue 선형 자료구조의 일종으로 First In First Out (FIFO)(먼저 들어간 놈이 먼저 나온다.) 참고로 Java Collection 에서 Queue 는 인터페이스이다. Tree 비선형 자료구조 트리는 계층적 관계를 표현하는 자료구조 구성요소 Node(노드) : 트리를 구성하고 있는 각각의 요소 Edge(간선) : 트리를 구성하기 위해 노드와 노드를 연결하는 선 Root Node(루트 노드) : 트리 구조에서 최상위에 있는 노드 Terminal Node(=leaf Node, 단말 노드) : 하위에 다른 노드가 연결되어 있지 않은 노드 internal Node(내부노드, 비단말노드) : 단말노드를 제외한 모든 노드 Binary Tree(이진트리) 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어 진다. 나누어진 두 서브 트리도 모두 이진트리이다. 트리에서 각 층별로 숫자를 매겨서 이를 트리의 level이라고 한다.(0부터 시작) 트리의 최고레벨을 high라고 한다. Full Binary Tree(포화 이진 트리), Complete Binary Tree(완전 이진 트리) 모든 레벨이 꽉 찬 이진 트리를 가리켜 포화 이진 트리 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리를 가리켜 완전 이진 트리 Full Binary Tree와 Complete binary tree는 노드의 개수가 n 개 일 때, i 번째 노드에 대해서 parent(i) = i/2 , left_child(i) = 2i , right_child(i) = 2i + 1 의 index 값을 갖는다. BST(Binary Search Tree, 이진 탐색 트리) 이진 트리의 일종 단 이진 탐색 트리에는 데이터를 저장하는 규칙이 있다. 그리고 그 규칙은 특정 데이터의 위치를 찾는데 사용할 수 있다. 규칙 노드에 저장된 키는 유일하다. 루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떠한 노드의 키보다 크다. 루트 노드의 키가 오른쪽 서브 트리를 구성하는 어떠한 노드의 키보다 작다. 왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다. 단점 배열보다 많은 메모리를 사용하며 데이터를 저장했지만 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생할 수 있다. Rebalancing 기법이 등장(균형을 잡기 위한 트리 구조의 재조정, 편향 트리가 될 수 있기 때문에)Binary Heap 자료구조의 일종 Tree형식(Complete Binary Tree) 배열에 트리의 값들을 넣어줄 때, 0 번째는 건너뛰고 1 번 index 부터 루트노드가 시작된다. 노드의 고유번호 값과 배열의 index 를 일치시켜 혼동을 줄이기 위함 최대힙(max heap), 최소힙(min heap) 두 종류가 있다. Max Heap이란, 각 노드의 값이 해당 children 의 값보다 크거나 같은 complete binary tree를 말한다.(Min heap 은 그 반대이다.) 장점 Max heap에서는 Root node 에 있는 값이 제일 크므로, 최대값을 찾는데 소요되는 연산의 time complexity 이 O(1)이다. 배열을 사용하여 효율적으로 관리할 수 있다. 단점 heap구조를 계속 유지하기 위해 제거된 노드에 대한 대체 노드가 필요하다. 여기서 heap 은 맨 마지막 노드를 루트 노드로 대체시킨 후, 다시 heapify 과정을 거쳐 heap 구조를 유지한다. 이런 경우에는 결국 O(log n)의 시간복잡도로 최대값 또는 최소값에 접근할 수 있게 된다. 네트워크GET, POST방식 둘 다 HTTP 프로토콜을 이용해서 서버에 무언가를 요청할 때 사용하는 방식 GET 요청하는 데이터가 HTTP Request Message의 Header 부분의 url에 담겨서 전송 ?뒤에 데이터가 붙어 request를 보내는 것. url이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다. 보안이 필요한 데이터에 대해서는 url에 노출됨으로 부적절하다. SELECT적인 성향을 가지고 있다. 서버의 값이나 상태를 변경하지 않는다. 브라우저에서 Caching 할 수 있다. 기존에 Caching되었던 데이터가 응답할 가능성이 존재한다. POST HTTP Message Body 부분에 데이터가 담겨서 전송된다. 데이터가 바이너리 데이터를 요청하는 경우 POST로 보내야한다. GET방식보다 데이터의 크기가 크고 보안면에서 낫다. TCP와 UDP 비교","link":"/2019/05/27/interview/interview01/"},{"title":"스프링 기반 REST API 개발02 - 이벤트 생성 API 개발 (@MockBean, ModelMapper, ErrorSerializer, JUnitParams)","text":"스프링 기반 REST API 개발(inflearn)2 - 백기선이벤트 생성 API 개발이벤트 API 테스트 클래스 생성스프링 부트 슬라이스 테스트 @WebMvcTest MockMvc 빈을 자동 설정 해준다. 따라서 그냥 가져와서 쓰면 됨. 웹 관련 빈만 등록해 준다. (슬라이스) MockMvc 스프링 MVC 테스트 핵심 클래스 웹 서버를 띄우지 않고도 스프링 MVC (DispatcherServlet)가 요청을 처리하는 과정을 확인할 수 있기 때문에 컨트롤러 테스트용으로 자주 쓰임. 테스트 할 것 입력값들을 전달하면 JSON 응답으로 201이 나오는지 확인. Location 헤더에 생성된 이벤트를 조회할 수 있는 URI 담겨 있는지 확인. id는 DB에 들어갈 때 자동생성된 값으로 나오는지 확인 입력값으로 누가 id나 eventStatus, offline, free 이런 데이터까지 같이 주면? Bad_Request로 응답 vs 받기로 한 값 이외는 무시 입력 데이터가 이상한 경우 Bad_Request로 응답 입력값이 이상한 경우 에러 비즈니스 로직으로 검사할 수 있는 에러 에러 응답 메시지에 에러에 대한 정보가 있어야 한다. 비즈니스 로직 적용 됐는지 응답 메시지 확인 offline과 free 값 확인 응답에 HATEOAS와 profile 관련 링크가 있는지 확인. self (view) update (만든 사람은 수정할 수 있으니까) events (목록으로 가는 링크) API 문서 만들기 요청 문서화 응답 문서화 링크 문서화 profile 링크 추가 Event 생성 API 구현 - 201 응답 받기 @RestController @ResponseBody를 모든 메소드에 적용한 것과 동일하다. ResponseEntity를 사용하는 이유 응답 코드, 헤더, 본문 모두 다루기 편한 API Location URI 만들기 HATEOS가 제공하는 linkTo(), methodOn() 사용 객체를 JSON으로 변환 ObjectMapper 사용 테스트 할 것 입력값들을 전달하면 JSON 응답으로 201이 나오는지 확인. Location 헤더에 생성된 이벤트를 조회할 수 있는 URI 담겨 있는지 확인. id는 DB에 들어갈 때 자동생성된 값으로 나오는지 확인 Event 생성 API - EventRepository 구현스프링 데이터 JPA JpaRepository 상속 받아 만들기 Enum을 JPA 맵핑시 주의할 것 기본값인 ORDINAL은 숫자로 저장되는데 데이터가 꼬일 수 있다. @Enumerated(EnumType.STRING) @MockBean Mockito를 사용해서 mock 객체를 만들고 빈으로 등록해 줌. 하지않으면 Repository는 Mock 객체기 때문에 save나 무엇을 하더라도 return 값은 null이 나온다. (주의) 기존 빈을 테스트용 빈이 대체 한다. 테스트 할 것 입력값들을 전달하면 JSON 응답으로 201이 나오는지 확인. Location 헤더에 생성된 이벤트를 조회할 수 있는 URI 담겨 있는지 확인. id는 DB에 들어갈 때 자동생성된 값으로 나오는지 확인 입력값 제한하기입력값 제한 id 또는 입력 받은 데이터로 계산해야 하는 값들은 입력을 받지 않아야 한다. EventDto 적용 DTO -&gt; 도메인 객체로 값 복사 ModelMapper 사용 (DTO를 도메인으로 convert) 12345&lt;dependency&gt; &lt;groupId&gt;org.modelmapper&lt;/groupId&gt; &lt;artifactId&gt;modelmapper&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; 빈으로 등록후 사용해야한다. 참고 - ModelMapper Customizing 통합 테스트로 전환 @WebMvcTest 빼고 다음 애노테이션 추가 @SpringBootTest @AutoConfigureMockMvc Repository @MockBean 코드 제거 테스트 할 것 입력값으로 누가 id나 eventStatus, offline, free 이런 데이터까지 같이 주면? Bad_Request로 응답 vs 받기로 한 값 이외는 무시 (선택) 입력값 이외에 에러 발생ObjectMapper 커스터마이징 spring.jackson.deserialization.fail-on-unknown-properties=true springboot에서 제공한다. Bad Request 처리하기@valid 와 BindingResult (또는 Errors) BindingResult는 항상 @Valid 바로 다음 인자로 사용해야 함. (스프링 MVC) @NotNull, @NotEmpty, @Min, @Max, … 사용해서 입력값 바인딩할 때 에러 확인할 수 있음 도메인 Validator 만들기 Validator 인터페이스 없이 만들어도 상관없음 빈으로 등록 후, 사용 테스트 설명 용 애노테이션 만들기 Bad Request 응답 본문 만들기 errors 객체를 JSON으로 serialization이 안되기 때문에 body에 담아도 에러가 발생한다. errors는 자바빈 스펙을 준수하고 있는 객체가 아니다… -&gt; beanSerializer를 사용할 수 없다. ErrorsSerilizer를 만들어서 문제를 해결 할 수 있다. Error의 rejectValue와 reject의 차이점 reject : 글로벌 에러 rejectValue : field 에러 생성한 ErrorSerializer를 ObjectMapper에 등록한다. 스프링부트에서는 @JsonComponent를 제공한다. (ObjectMapper에 등록해준다.) 매개변수를 이용한 테스트 테스트 코드 리팩토링 테스트에서 중복 코드 제거 매개변수만 바꾸면서 사용하고 싶을 때, JUnitParams를 사용하면 해결 할 수 있다. 라이브러리 추가 123456&lt;dependency&gt; &lt;groupId&gt;pl.pragmatists&lt;/groupId&gt; &lt;artifactId&gt;JUnitParams&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; test Class 설정 1234@RunWith(JUnitParamsRunner.class)public class EventTest { ....} 사용 123456789101112131415161718192021@Test@Parameters({ &quot;0, 0, ture&quot;, &quot;100, 0, false&quot;, &quot;0, 100, false&quot;})public void testFree(int basePrice, int maxPrice, boolean isFree) { //given Event event = Event.builder() .basePrice(basePrice) .maxPrice(maxPrice) .build(); //when event.update(); //then assertThat(event.isFree()).isEqualTo(isFree);} TypeSafe하게 사용하고 싶다면 1234567891011121314151617181920212223242526@Test@Parameters(method = &quot;parametersForTestFree&quot;)public void testFree(int basePrice, int maxPrice, boolean isFree) { // given Event event = Event.builder() .basePrice(basePrice) .maxPrice(maxPrice) .build(); // when event.update(); // then assertThat(event.isFree()).isEqualTo(isFree);}private Object[] parametersForTestFree() { return new Object[] { new Object[] {0, 0, true}, new Object[] {100, 0 , false}, new Object[] {0, 100, false} };} parametersFor~~ 를 사용하면 method = “parametersFor~~”는 생략 가능하다.","link":"/2019/06/25/RestAPI/restapi02/"},{"title":"스프링 기반 REST API 개발01 - REST API 및 프로젝트 소개","text":"스프링 기반 REST API 개발(inflearn)1 - 백기선REST API 및 프로젝트 소개REST API 참고 발표 영상 : 그런 REST API로 괜찮은가참고 소스 코드 : https://github.com/keesun/study/tree/master/rest-api-with-spring API Application Programming Interface REST REpresentational State Transfer 인터넷 상의 시스템 간의 상호 운용성(interoperability)을 제공하는 방법중 하나 시스템 제각각의 독립적인 독립적인 진화를 보장하기 위한 방법 REST API: REST 아키텍처 스타일을 따르는 API REST 아키텍처 스타일 Client-Server Stateless Cache Uniform Interface Layered System Code-On-Demand (optional) http만 잘 따라도 잘 지켜지지만 Uniform Interface는 잘 지켜지지 않는다. Uniform Interface (영상영상 11분 40초) Identification of resources manipulation of resources through represenations self-descrive messages hypermisa as the engine of appliaction state (HATEOAS) 강조 된 두 제약조건을 잘 지키지 못한다. 두 문제를 좀 더 자세히 살펴보자. (발표 영상 37분 50초) Self-descriptive message 메시지 스스로 메시지에 대한 설명이 가능해야 한다. 서버가 변해서 메시지가 변해도 클라이언트는 그 메시지를 보고 해석이 가능하다. 확장 가능한 커뮤니케이션 HATEOAS 하이퍼미디어(링크)를 통해 애플리케이션 상태 변화가 가능해야 한다. 링크링크 정보를동적으로 바꿀 수 있다.(Versioning 할 필요 없이!) Self-descriptive message 해결 방법 방법 1: 미디어 타입을 정의하고 IANA에 등록하고 그 미디어 타입을 리소스 리턴할 때, Content-Type으로 사용한다. 방법방법 2: profile 링크 헤더를 추가한다. (발표발표 영상영상 41분 50초) 브라우저들이 아직 스팩 지원을 잘 안해 대안으로 HAL의 링크 데이터에 profile 링크 추가 HATEOAS 해결 방법 방법1: 데이터에 링크 제공 링크를 어떻게 정의할 것인가? HAL 방법2: 링크 헤더나 Location을 제공 HAL(Hypertext Application Language)?HAL은 API의 리소스들 사이에 쉽고 일관적인 하이퍼링크를 제공하는 방식이다.API 설계시 HAL을 도입하면 API간에 쉽게 검색이 가능하다.따라서 해당 API를 사용하는 다른 개발자들에게 좀 더 나은 개발 경험을 제공한다. “Event” REST API앞으로 만들 프로젝트에 대한 설명 이벤트 등록, 조회 및 수정을 하는 REST API GET /api/events 이벤트 목록 조회 REST API (로그인 안 한 상태) 응답에 보여줘야 할 데이터 이벤트 목록 링크 self profile: 이벤트 목록 조회 API 문서로 링크 get-an-event: 이벤트 하나 조회하는 API 링크 next: 다음 페이지 (optional) prev: 이전 페이지 (optional) 문서 : 스프링 REST Docs로 만들 예정 이벤트 목록 조회 REST API (로그인 한 상태) 응답에 보여줘야 할 데이터 이벤트 목록 링크 self profile: 이벤트 목록 조회 API 문서로 링크 get-an-event: 이벤트 하나 조회하는 API 링크 create-new-event: 이벤트를 생성할 수있는 API 링크 next: 다음 페이지 (optional) prev: 이전 페이지 (optional) 로그인 한 상태???? (stateless라며..) 아니, 사실은 Bearer 헤더에 유효한 AccessToken이 들어있는 경우! POST /api/events 이벤트 생성 GET /api/events/{id} 이벤트 하나 조회 PUT /api/events/{id} 이벤트 수정 StatelessStateless 하다는 것은 서버가 어떠한 Client 의 Status 도 저장하지 않는다는 뜻입니다.따라서 Client 는 매 요청마다 자신을 인증할 수 있는 Token 이나 Key 등을 Request 에 포함시켜 전송합니다. 만약 클라이언트의 요청이 Stateful 하다면 서버가 클라이언트의 현재 상태를 저장해야하고, 클라이언트의 상태는 해당 서버에 종속이 됩니다.만약 대규모 환경에서 동일한 웹서버를 다수 배치해 로드밸런싱을 하는 경우에 각 서버가 클라이언트의 상태, 세션을 공유할 수 있는 Redis 같은 별도의 시스템이 필요합니다.그러나 Stateless 하다면 클라이언트의 요청은 어느 서버가 처리하던지 동일하게 처리할 수 있습니다.클라이언트의 상태는 클라이언트의 요청 안에 모두 들어있으니까요.참고, 출처 : http://blog.weirdx.io/post/3110 Events API 사용 예제 https://www.inflearn.com/course/spring_rest-api/lecture/16411 해당강좌 구매한 사람만 볼 수 있습니다. 스프링 부트 프로젝트 만들기의존성 추가 web JPA HATEOAS REST Docs H2 PostgreSQL Lombok 스프링 부트 핵심 원리 의존성 설정(pom.xml) 자동설정(@EnableAutoConfiguration) 내장 웹 서버(의존성과 자동 설정의 일부) 독립적으로 실행 가능한 JAR(pom.xml의 플러그인) Event 생성 API 구현 - Event 도메인 구현 왜 @EqualsAndHasCode에서 of를 사용하는가 entity간의 연관관계가 있을 때, stack over flow 가 발생할 수 있다. @data도 마찬가지… 왜 @Builder를 사용할 때 @AllArgsConstructor가 필요한가 javaBean 스펙도 필요 builder는 public이 아닌 default로 생성된다. @Data를 쓰지 않는 이유 애노테이션 줄일 수 없나 lombok 애노테이션은 메타 애노테이션이 아니기 때문에.. 애노테이션 조합이 안된다. Event 생성 API - 비지니스 로직 다음의 입력 값을 받는다. name description beginEnrollmentDateTime closeEnrollmentDateTime beginEventDateTime endEventDateTime location (optional) 이게 없으면 온라인 모임 basePrice (optional) maxPrice (optional) limitOfEnrollment basePrice와 maxPrice 경우의 수와 각각 로직 결과값 id name … eventStatus: DRAFT, PUBLISHED, ENROLLMENT_STARTED, … offline free _links profile (for the self-descriptive message) self publish …","link":"/2019/06/25/RestAPI/restapi01/"},{"title":"스프링 시큐리티 - 더블 슬래쉬 허용","text":"SpringSecurity더블 슬래쉬 허용 문제점 기본 정책은 URL에 더블 슬래쉬를 허용하지 않는다. 에러가 발생 12345org.springframework.security.web.firewall.RequestRejectedException: The request was rejected because the URL was not normalized. at org.springframework.security.web.firewall.StrictHttpFirewall.getFirewalledRequest(StrictHttpFirewall.java:296) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:194) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357) 허용 SpringSecurityConfig 설정 클래스에 다음 빈을 추가해준다. 1234@Beanpublic HttpFirewall defaultHttpFirewall() { return new DefaultHttpFirewall();} WebSecurity 설정에 추가해준다. 1234@Overridepublic void configure(WebSecurity web) throws Exception { web.httpFirewall(defaultHttpFirewall());}","link":"/2020/01/12/Security/double-slash-permit/"},{"title":"면접 후기01","text":"면접 후기웹 백엔드 개발자 지원 처음으로 개발회사에서 면접을 보게되었고, 면접을 마치고 후기를 씁니다.면접은 기초적인 질문들과 과제 프로젝트관련 질문들이 있었습니다.면접 시, 정말 좋았던건 면접관님들께서 매우 친절했으며, 과제프로젝트에 관련하여 질문만 해주신것이 아닌 고쳐야 할 점에대해 코드리뷰를 해주었다는 점입니다.면접은 잘 못 본 것 같지만.. 좋은 경험이 되었습니다. 😂 기초 질문접근 제어자 멤버 또는 클래스에 사용되어 해당 멤버 및 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 함. 객체지향언어의 주요 특성중 하나인 캡슐화 및 정보숨김을 구현 public : 모든 클래스에 의해 접근 가능 protected : 동일 패키지 및 하위클래스 관계 접근 가능 private : 자기 자신 클래스 내에서만 접근가능 (default) : 동일 패키지 접근가능 default 접근제어자가 왜 생각이 안났는지… Map과 List에 관하여..Map 자료형으로서 대응관계를 쉽게 표현할 수 있도록 해준다. Key와 Value라는 것을 한 쌍으로 가진다. 순차적으로 해당 요소 값을 구하지 않고 Key를 통하여 Value를 얻는다. List ArrayList와 LinkedList가 있다. ArrayList 데이터 타입이 필요 → 제네릭 선언 : 코드의 일관성/사용 용이 크기는 사용에 따라 증가 삭제 시, 알아서 자리 채움 LinkedList 인접데이터를 가르키는 식으로 구현 이웃해서 저장하지 않고 참조하여 사용하여 연결되어 있다. 주소값으로 연결 Linked list 와 Array List를 어떤 상황에서 쓰는지.. ArrayList : index값으로 저장 전체를 순서대로 출력에 용이 추가 삭제에 용이하지 않은 이유 : 삭제시 어떠한 인덱스 값이 비게 되면 안됨으로 재배치 관련하여 메모리를 사용하게 된다. LinkedList : 전후 노드의 주소값과 연결되어저장 리스트 추가 삭제에 용이 query에서 group by절 사용 시 조건문에 붙여야하는 문법 HAVING NoticeProject 관련 질문패키지명 앞에 대문자를 썼는데 패키지명은 모두 소문자여야한다. 페이징 처리 .. 해당 페이지의 시작 인덱스를 구해보세요. (해당페이지 -1) * 페이지사이즈이걸 왜 대답못했는지 모르겠다.. SessionContants123public interface SessionConstants { String LOGIN_USER = &quot;LOGIN_USER&quot;;} 이렇게 구현한 이유가 뭐죠? interface인데 이거 다른위치에서 수정이 가능하지 않나요? 수정이 불가능하다. interface의 모든 멤버 변수는 public static final 이어야한다. 단, 이를 생략할 수 있다. interface의 모든 메소드는 모두 public abstract 이어야한다. 단, 이를 생략할 수 있다. static 메소드 와 default 메소드는 제외한다.(선언 시) class로 public static final로도 구현 할 수 있다. @EnableJdbcHttpSession123@EnableJdbcHttpSessionpublic class HttpSessionConfig {} 해당 설정을 한 이유는? Session값을 DB에 저장하기 위해..몰랐다.. 굳이 구글 로그인 유저를 Account에 저장할 필요가 없었던거 같다.. @Autowired , 생성자 주입 @Autowired 및 생성자로 빈을 주입하는 방식 둘 다 썼는데 코드의 통일성을 위해 하나로 통일하는 것이 좋다. 생성자를 사용하여 주입하는 것이 스프링 권장사항이다. (스프링 4부터..) 쉬운 질문에 대해서도 대답을 잘하지 못해서 .. 너무 아쉬웠습니다.알고 있다고 다 대답할 수 있는것은 아니란것을 .. 깨달았습니다..😂","link":"/2019/05/28/interview/interview02/"},{"title":"oauth2 - 구글 로그인","text":"SpringSpringSecurity-OAuth2 최근 서비스들은 자체적으로 계정을 가입하고, 접근하는 방식도 있지만, 구글, 카카오, 네이버, 페이스북등으로 계정관리를 하고있습니다.이번 포스팅에서는 Spring Security &amp; 구글 OAuth를 사용하여 계정 권한관리에 대해 알아보려고 합니다.빌드 도구로는 gradle을 사용해 보려고 합니다. 구글 OAuth의존성 추가1234567891011121314151617181920dependencies { implementation &apos;org.springframework.boot:spring-boot-starter-actuator&apos; implementation &apos;org.springframework.boot:spring-boot-starter-data-jpa&apos; implementation &apos;org.springframework.boot:spring-boot-starter-web&apos; implementation &apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos; compileOnly &apos;org.projectlombok:lombok&apos; runtimeOnly &apos;com.h2database:h2&apos; runtimeOnly &apos;mysql:mysql-connector-java&apos; annotationProcessor &apos;org.projectlombok:lombok&apos; testImplementation &apos;org.springframework.boot:spring-boot-starter-test&apos; testCompile(&apos;org.springframework.security:spring-security-test&apos;) testCompile(&apos;io.rest-assured:rest-assured:3.0.3&apos;) compile(&quot;org.mariadb.jdbc:mariadb-java-client&quot;) compile group: &apos;org.springframework.security.oauth&apos;, name: &apos;spring-security-oauth2&apos;, version: &apos;2.3.5.RELEASE&apos;} SpringBoot 버전이 2점대로 올라가면서 의존성 추가 방법이 조금 다를 수 있다. rest-assured은 Rest API Test를 위한 의존성 application.yml 설정1234567891011121314spring: profiles: local jpa: show-sql: true hibernate: ddl-auto: create-drop h2: console: enabled: true logging: level: org.hibernate.type: trace # JPA로 생성되는 쿼리의 파라미터 값 확인 SpringSecurity 기본인증 옵션 비활성화 SpringSecurity가 의존성에 있으면 기본인증이 자동으로 추가된다. 현재 상황에 필요한 기능이 아님으로 비활성화 기존 스프링부트 1점대에서는 properties파일 또는 yml 파일에서 security.basic.enabled: false로 변경할 수 있었다. 2점대 부터는 아래와 WebConfigurerAdapter를 상속하는 @Configuration 클래스를 만들어서 설정해줘야한다. 모든 요청에 대하여 인증을 하지 않은것으로 설정한다. index.html 호출 test 파일작성 기본 루트로 접속 시, index.html을 호출하는지 확인하기 위해 테스트 클래스를 작성한다. 구글 OAuth 등록 구글 개발자 콘솔에 접속한다. 프로젝트 생성 프로젝트 정보 입력 및 생성 만들어진 프로젝트를 선택한다. 사용자 인증 정보 페이지로 이동한다. OAuth 클라이언트 ID 생성 OAuth 동의 화면에서 어플리케이션 이름을 설정해준다. 정보 입력 이름(어플리케이션 이름이 아니다.) 테스트용으로 localhost 주소를 사용했다. 완료하게 되면 클라이언트 ID 및 보안(security)를 확인할 수 있다. 구글 인증 정보를 프로젝트에 적용하기 구글 인증 정보를 프로젝트 yml파일에 등록한다. 12345678910google: client: clientId: clientSecret: accessTokenUri: https://accounts.google.com/o/oauth2/token userAuthorizationUri: https://accounts.google.com/o/oauth2/auth clientAuthenticationScheme: form scope: email, Profile resource: userInfoUri: https://www.googleapis.com/oauth2/v2/userinfo git 인증정보가 노출 될 수 있기 때문에 별도의 yml파일을 생성하고 gitignore설정을 해준다. 프로젝트 실행 시, 호출될 수 있도록 Application.java에 추가해준다.(여러개일때는 , 필수) SecurityConfig에 아래와 같은 설정을 해준다. 1234567891011121314@Configurationpublic class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.antMatcher(&quot;/**&quot;) .authorizeRequests() .antMatchers(&quot;/&quot;, &quot;/h2-console/**&quot;, &quot;/favicon.ico&quot;, &quot;/login**&quot;).permitAll() .anyRequest().authenticated() .and().logout().logoutSuccessUrl(&quot;/&quot;).permitAll() .and().headers().frameOptions().sameOrigin() .and().csrf().disable(); }} csrf를 끈 이유 로컬환경에서 H2 Console에 접근하기위해 불필요한 테스트 코드 작성을 줄이기 위해 루트, h2-console, 파비콘, login 등에 권한체크 제외설정을 해준다. Google OAuth 설정 OAuth 설정 파일 생성 @Configuration @EnableOAuth2Client OAuth2ClientContext가 빈으로 등록이 가능하다. 구글로그인 정보를 받을 빈을 등록한다. 1234567891011@Bean@ConfigurationProperties(&quot;google.client&quot;)public OAuth2ProtectedResourceDetails googleClient() { return new AuthorizationCodeResourceDetails();}@Bean@ConfigurationProperties(&quot;google.resource&quot;)public ResourceServerProperties googleResource() { return new ResourceServerProperties();} 필터를 빈으로 등록하고 설정한다. 123456789@Beanpublic Filter ssoFilter(){ OAuth2ClientAuthenticationProcessingFilter oauth2Filter = new OAuth2ClientAuthenticationProcessingFilter(&quot;/login/google&quot;); OAuth2RestTemplate oAuth2RestTemplate = new OAuth2RestTemplate(googleClient(), oAuth2ClientContext); oauth2Filter.setRestTemplate(oAuth2RestTemplate); oauth2Filter.setTokenServices(new UserInfoTokenServices(googleResource().getUserInfoUri(), googleClient().getClientId())); oauth2Filter.setAuthenticationSuccessHandler(google); return oauth2Filter;} OAuth2ClientAuthenticationProcessingFilter의 인자값 = OAuth 로그인 시작 포인트 OAuth2RestTemplate 설정 및 필터에 설정 UserInfoTokenServices 설정 (토큰을 얻을 클라이언트 설정) SuccessHandler 등록 필터를 등록 할 FilterRegistrationBean을 빈으로 등록 1234567@Beanpublic FilterRegistrationBean oauth2ClientFilterRegistration(OAuth2ClientContextFilter filter) { FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(filter); registration.setOrder(-100); return registration;} Authentication 객체를 주입받아 로그인 정보를 얻는다. 1234private LoginAccount getGoogleUser(Authentication authentication) { OAuth2Authentication oAuth2Authentication = (OAuth2Authentication) authentication; return objectMapper.convertValue(oAuth2Authentication.getUserAuthentication().getDetails(), LoginAccount.class);} Authentication객체를 OAuth2Authentication로 형변환 ObjectMapper 객체를 미리 만들어놓은 LoginAccount 객체와 매핑하여 컨버트 한다. 문제발생.. 스프링부트 2점대 버전이 되면서 Spring Security OAuth 기능의 일부가 Spring Security로 마이그레이션 되는중이라 지원안하는 기능 발생 UserInfoTokenService, ResourceServerProperties 클래스 및 @EnableOAuth2Sso 애노테이션 사용이 불가능 2점대에서 사용하는 방법을 숙지하고 싶었으나.. OAuth2에 대한 이해가 적고, SpringSecurity에 대한 이해가 부족하여 임시방편을 사용하였다. spring-security-oauth2 → spring-security-oauth2-autoconfigure로 변경 spring-cloud-security로 변경하는것도 가능하다고 한다. 생성한 ssoFilter가 Security를 거치도록 설정한다. OAuthConfig에서 생성한 ssoFilter 추가 테스트 파일 google.yml파일을 테스트 시에도 사용할 수 있도록 @TestPropertySource로 추가 OAuth2 로그인의 경우 인증코드(code)를 발급 받고, 발급 받은 인증코드로 AccessToken을 다시 발급 받는 과정이 있어 중간 리다이렉션이 발생합니다. 이런 과정들로 login URL 테스트 결과를 확인하기 어려워 리다이렉션을 방지 하였다. 302코드“3xx Redirection”클래스에 속한다.301 : 완전히 새로운 URL로 이동302 : 임시적으로 새로운 URL로 이동 브라우저에서 확인 localhost:8080/login 구글계정으로 가입된 서비스에서 확인 할 수 있다. 로그인 세션 관리 OAuth2를 사용하는것은 사용자 인증 및 허가된 정보를 가져오는것 인증된 정보를 통해 로그인 세셔관리가 필요하다. 세션을 사용하는 방법 톰캣 세션 사용 HttpSession을 사용할 경우 2대이상의 WAS가 구동되는 환경에서는 톰캣들간의 세션 공유를 위한 추가설정이 필요 Database를 세션저장소로 사용(진행할 예정) WAS들간의 공용 세션을 사용할 수 있는 가장 쉬운 방법 많은 설정이 필요없지만, 결국 로그인 요청마다 DB IO가 발생하여 성능상 이슈가 발생할 수 있다. 보통 로그인이 요청이 많이 없는 백오피스, 사내시스템 용도에서 사용합니다. Redis, Memcached등의 메모리 DB를 세션 저장소로 사용 사용자 서비스에서 가장 많이 사용되는 방식입니다. 실제 서비스로 사용하기 위해서는 Embedded Redis와 같은 방식이 아닌 외부 메모리 서버가 필요합니다. 참고 : Havi님 블로그 Database를 세션저장소로 사용의존성 추가 jdbc 및 session 의존성을 추가한다.12compile group: &apos;org.springframework.session&apos;, name: &apos;spring-session&apos;, version: &apos;1.3.5.RELEASE&apos;compile(&apos;org.springframework.boot:spring-boot-starter-jdbc&apos;) Session 테이블 생성 세션의 저장을 DB에 하기 위해서 세션 테이블이 생성되어야한다. SpringSession에서 어떠한 형태로 쿼리문을 사용하는지 알려준다. 맥/intelij 기준으로 , Command + Shift + o schema-검색하면 아래와 같이 DBMS에 맞춰 스키마 쿼리를 확인할 수 있다. 복사하여 새로 작성한다. resources 아래 schema-h2.sql 새로 작성한 스키마를 적용하도록 application.yml에 설정한다. 123spring: datasource: data: classpath:schema-h2.sql JdbcSession 옵션 활성화 @EnableJdbcHttpSession만 사용하면 된다. SuccessHandler 생성 AuthenticationSuccessHandler를 implements하는 클래스 생성 123456789101112131415161718192021222324@Componentpublic class GoogleAuthenticationSuccessHandler implements AuthenticationSuccessHandler { private HttpSession httpSession; private ObjectMapper objectMapper; public GoogleAuthenticationSuccessHandler(HttpSession httpSession, ObjectMapper objectMapper) { this.httpSession = httpSession; this.objectMapper = objectMapper; } @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException { httpSession.setAttribute(SessionConstants.LOGIN_USER, getGoogleUser(authentication)); /* 간단한 구글계정 정보를 세션에 저장*/ response.sendRedirect(&quot;/me&quot;); } /* OAuth 인증정보를 통해 GoogleUser 인스턴스 생성 */ private GoogleUser getGoogleUser(Authentication authentication) { OAuth2Authentication oAuth2Authentication = (OAuth2Authentication) authentication; return objectMapper.convertValue(oAuth2Authentication.getUserAuthentication().getDetails(), GoogleUser.class); }} ObjectMapper의 경우 스프링부트에서 빈으로 등록해준다.(과거에는 아니었지만..) 이 SuccessHandler는 로그인 유저의 기본적인 정보를 LOGIN_USER라는 키값에 담는다. SessionConstants.class 생성 리다이렉트 되는 “/me” 컨트롤러 GoogleUser.class 생성 ObjectMapper가 필드를 명확히 인식하기 위해 @JsonProperty로 필드명을 지정 @JsonIgnoreProperties(ignoreUnknown = true) : 멤버변수로 지정되지 않은 필드는 무시 Serializable SuccessHandler 적용 완성된 SuccessHandler를 필터에 적용시킨다. 결과 localhost:8080/me 접속 인증 오류 403 발생 localhost:8080/login 접속 및 google 로그인 유저 정보 확인 많은 자료들이 스프링부트 1점대를 기준으로 작성되어 작업이 생각보다 오래걸렸습니다..😂구글로그인을 해보고나니, 여러가지 다른 인증들도 해보고 싶어졌습니다.음.. 이번 내용들을 블로깅하면서 내가 security부분도 많이 부족하고 강의를 보고 복습도했지만..아직 스프링 그리고 스프링부트를 완벽히 이해하고 있지 않다는 생각이 들었습니다.","link":"/2019/04/21/Security/oauth2-google-login/"},{"title":"스프링 기반 REST API 개발04 - 이벤트 조회 및 수정 REST API 개발(PagedResouce)","text":"스프링 기반 REST API 개발(inflearn)4 - 백기선이벤트 조회 및 수정 REST API 개발 이벤트 목록 조회 API 구현페이징, 정렬 스프링 데이터 JPA가 제공하는 pageable을 사용한다. GET방식 parameter page : 원하는 페이지 (0부터 시작) size : 한페이지에 들어갈 리소스 수 (기본값 = 20) sort : 정렬타입 및 차순 (ex.. sort=name,DESC) Return pageable : pageable 정보 content : 리소스 정보 totalElements : 전체 리소스 수 … 12345@GetMapping(&quot;/api/events&quot;)public ResponseEntity queryEvents(Pageable pageable) { Page&lt;Event&gt; page = eventsRepository.findall(pagealbe); return ResponseEntity.ok(page);} PagedResouce PagedResourceAssembler를 사용하여 Page객체를 PagedResouce를 생성할 수 있다. 첫페이지, 이전페이지, 현재페이지, 다음페이지, 마지막페이지 Link가 포함되어있다. Resource로 사용할 경우, 각 리소스들의 링크정보는 포함되지 않는다. 이전에 생성했던 EventResource로 적용시킨다. ( e -&gt; new EventResouce(e); ) Profile 링크 추가 1234567@GetMapping(&quot;/api/events&quot;)public ResponseEntity queryEvents(Pageable pageable, PagedResourcesAssembler&lt;Event&gt; assembler) { Page&lt;Event&gt; page = eventRepository.findAll(pageable); PagedResources&lt;Resource&lt;Event&gt;&gt; pagedResources = assembler.toResource(page, e -&gt; new EventResource(e)); pagedResources.add(new Link(&quot;/docs/index.html#resources-events-list&quot;).withRel(&quot;profile&quot;)); return ResponseEntity.ok(pagedResources);} 테스트 (문서화는 생략) 12345678910111213141516171819202122232425262728293031@Test@TestDescription(&quot;30개 이벤트를 10개씩 두번째 페이지 조회하기&quot;)public void queryEvents() throws Exception { // given IntStream.range(0, 30).forEach(this::generateEvent); // mehtod reference로 간결에가 사용이 가능 // when this.mockMvc.perform(get(&quot;/api/events&quot;) .param(&quot;page&quot;, &quot;1&quot;) .param(&quot;size&quot;, &quot;10&quot;) .param(&quot;sort&quot;, &quot;name,DESC&quot;) ) .andDo(print()) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;page&quot;).exists()) .andExpect(jsonPath(&quot;_embedded.eventList[0]._links.self&quot;).exists()) .andExpect(jsonPath(&quot;_links.self&quot;).exists()) .andExpect(jsonPath(&quot;_links.profile&quot;).exists()) .andDo(document(&quot;query-events&quot;)) // 자세한 문서화 생략 ;}private void generateEvent(int i) { Event event = Event.builder() .name(&quot;event&quot; + i) .description(&quot;test eveent&quot;) .build(); this.eventRepository.save(event);} 이벤트 조회 API 구현단일 조회 API123456789101112@GetMapping(&quot;/{id}&quot;)public ResponseEntity getEvent(@PathVariable Integer id) { Optional&lt;Event&gt; byId = eventRepository.findById(id); if (byId.isPresent()) { Event event = byId.get(); EventResource resource = new EventResource(event); resource.add(new Link(&quot;/docs/index.html#resources-events-get&quot;).withRel(&quot;profile&quot;)); return ResponseEntity.ok(resource); } return ResponseEntity.notFound().build();} 해당아이디에 해당하는 이벤트를 찾아서 조회한다. EventResource를 ResponseEntity body에 담아서 리턴(self 링크를 포함하고 있다.) profile 링크를 추가 isPrsent() : 해당 이벤트가 있으면 true 아니면 false를 반환 ResponseEntity.notFound().build(); -&gt; 404에러를 반환 테스트 정상조회 1234567891011121314151617@Test@TestDescription(&quot;기존의 이벤트 하나 조회하기&quot;)public void getEvent() throws Exception { //given Event event = this.generateEvent(100); //when ResultActions perform = this.mockMvc.perform(get(&quot;/api/events/{id}&quot;, event.getId())) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;name&quot;).exists()) .andExpect(jsonPath(&quot;id&quot;).exists()) .andExpect(jsonPath(&quot;_links.self&quot;).exists()) .andExpect(jsonPath(&quot;_links.profile&quot;).exists()); //then perform.andDo(document(&quot;get-an-events&quot;));} 없는 이벤트 조회시 404 응답 123456@Test@TestDescription(&quot;없는 이벤트를 조회하면 404 응답받기&quot;)public void getEvent404() throws Exception { this.mockMvc.perform(get(&quot;/api/events/1142323&quot;)) .andExpect(status().isNotFound());} 이벤트 수정 API 구현이벤트 수정 API123456789101112131415161718192021222324252627282930@PutMapping(&quot;/{id}&quot;)public ResponseEntity updateEvent(@PathVariable Integer id, @RequestBody @Valid EventDto eventDto, Errors errors) { Optional&lt;Event&gt; byId = this.eventRepository.findById(id); if (!byId.isPresent()){ return ResponseEntity.notFound().build(); } if (errors.hasErrors()) { return badRequest(errors); } this.eventValidator.validate(eventDto, errors); if (errors.hasErrors()) { return badRequest(errors); } Event event = byId.get(); modelMapper.map(eventDto, event); Event updateEvent = eventRepository.save(event);// eventRepository.flush(); EventResource resource = new EventResource(updateEvent); resource.add(new Link(&quot;/docs/index.html#resources-events-update&quot;).withRel(&quot;profile&quot;)); return ResponseEntity.ok(resource);} 테스트코드 이벤트 정상 수정 1234567891011121314151617181920212223@Test@TestDescription(&quot;이벤트를 정상적으로 수정하기&quot;)public void updateEvent() throws Exception { // given Event event = this.generateEvent(200); EventDto eventDto = this.modelMapper.map(event, EventDto.class); eventDto.setName(&quot;수정한 이벤트&quot;); // when this.mockMvc.perform(put(&quot;/api/events/{id}&quot;, event.getId()) .contentType(MediaType.APPLICATION_JSON_UTF8) .content(this.objectMapper.writeValueAsString(eventDto)) .accept(MediaTypes.HAL_JSON_UTF8)) .andDo(print()) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;name&quot;).value(eventDto.getName())) .andExpect(jsonPath(&quot;_links.self&quot;).exists()) .andDo(document(&quot;update-event&quot;)); Event updateEvent = eventRepository.findById(event.getId()).get(); assertThat(updateEvent.getName()).isEqualTo(eventDto.getName());} 수정하려는 이벤트가 없는경우 404 Not Found 123456789101112131415@Test@TestDescription(&quot;존재하지 않는 이벤트 수정 404 응답&quot;)public void updateEvent404_NotFound() throws Exception { // given Event event = this.generateEvent(200); EventDto eventDto = this.modelMapper.map(event, EventDto.class); // when this.mockMvc.perform(put(&quot;/api/events/123331&quot;) .contentType(MediaType.APPLICATION_JSON_UTF8) .content(this.objectMapper.writeValueAsString(eventDto)) .accept(MediaTypes.HAL_JSON_UTF8)) .andDo(print()) .andExpect(status().isNotFound());} 입력 데이터가 이상한 경우 400 Bad Request 12345678910111213@Test@TestDescription(&quot;이벤트 입력값이 잘못된 경우 BadRequest 응답 받기&quot;)public void updateEvent400_Empty() throws Exception { // given Event event = this.generateEvent(200); // when this.mockMvc.perform(put(&quot;/api/events/{id}&quot;, event.getId()) .contentType(MediaType.APPLICATION_JSON_UTF8) .accept(MediaTypes.HAL_JSON_UTF8)) .andDo(print()) .andExpect(status().isBadRequest());} 도메인로직으로 데이터 검증 실패 400 Bad Request 1234567891011121314151617@Test@TestDescription(&quot;이벤트 입력값이 잘못된 경우 BadRequest 응답 받기&quot;)public void updateEvent400_Wrong() throws Exception {// givenEvent event = this.generateEvent(200);EventDto eventDto = this.modelMapper.map(event, EventDto.class);eventDto.setBasePrice(20000);eventDto.setMaxPrice(1000); // whenthis.mockMvc.perform(put(&quot;/api/events/{id}&quot;, event.getId()) .contentType(MediaType.APPLICATION_JSON_UTF8) .content(this.objectMapper.writeValueAsString(eventDto)) .accept(MediaTypes.HAL_JSON_UTF8)) .andDo(print()) .andExpect(status().isBadRequest());} 테스트 코드 리팩토링 중복 코드 제거 하기 중복되는 코드들을 뽑아 테스트 클래스를 작성 후 상속한다. 상속 클래스에는 @Ignore 어노테이션으로 테스트로 간주되지 않도록 설정한다.123456789101112131415161718@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvc@AutoConfigureRestDocs@Import(RestDocsConfiguration.class)@ActiveProfiles(&quot;test&quot;)@Ignorepublic class BaseControllerTest { @Autowired protected MockMvc mockMvc; @Autowired protected ModelMapper modelMapper; @Autowired protected ObjectMapper objectMapper;} 상속받는 테스트들에서 상속. (중복된 내용 제거) 123public class EventControllerTest extends BaseControllerTest { ...}","link":"/2019/08/09/RestAPI/restapi04/"},{"title":"인증 시, UsernameNotfoundException 발생 안함 문제(BadCredentials Exception만 발생)","text":"SpringSecurityDebug인증 시, UsernameNotfoundException 발생 안함 문제(BadCredentials Exception만 발생) 조건 SpringSecurity 사용 로그인 성공 시, 응답으로 authorization에 ‘success 200’ 문자열을 응답 로그인 샐패 시, 응답으로 authorization에 ‘fail 에러코드’ 문자열을 응답 ExceptionHandler 설정 및 ReturnCodes 는 미리 설정해두었지만 생략.. UserDetailsService 및 PasswordEncoder를 생성 및 등록 -&gt; DaoAuthenticationProvider 생성 AuthenticateManager에 DaoAuthenticationProvider를 Provider로 등록 과정Exception 및 DTO/VO설정은 제외하고 진행하겠습니다. Account 생성 123456789101112131415161718192021222324252627282930313233343536@Entity@Table(name = &quot;mt_account&quot;)@Getter@NoArgsConstructor@EqualsAndHashCode(callSuper = false, of = { &quot;id&quot; })public class Account { @Id @Column(name = &quot;id&quot;, length = 50) @GenericGenerator(name = &quot;system-uuid&quot;, strategy = &quot;uuid2&quot;) @GeneratedValue(generator = &quot;system-uuid&quot;) private String id; @Column(name = &quot;email&quot;, length = 100, nullable = false) private String email; @Column(name = &quot;password&quot;, length = 100, nullable = false) private String password; @Column(name = &quot;name&quot;, length = 100) private String name; @ElementCollection(fetch = FetchType.EAGER) @Enumerated(EnumType.STRING) private Set&lt;AccountRole&gt; roles; @Builder public Account(String email, String password, String name) { Set&lt;AccountRole&gt; set = new HashSet&lt;&gt;(); set.add(AccountRole.USER); this.email = email; this.password = password; this.name = name; this.roles = set; } id String으로 자동생성 email username으로 사용하기 위해 nullable=false 설정 password password로 사용하기 위해 nullable=false 설정 name 테스트 작성 ApplicationRunner를 빈으로 등록하여 미리 Account를 저장해 놓을것이다. 성공 123456789101112131415@Testpublic void getAuth_success() throws Exception { AccountDTO.LoginRequestDTO loginRequest = AccountDTO.LoginRequestDTO.builder() .email(&quot;bong@email.com&quot;) .password(&quot;pass&quot;) .build(); this.mockMvc.perform(post(&quot;/getAuthorization&quot;) .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE) .content(objectMapper.writeValueAsString(loginRequest)) ) .andDo(print()) .andExpect(jsonPath(&quot;authorization&quot;).value(&quot;true&quot;)) ;} 실패 - password 오류 123456789101112131415@Testpublic void getAuth_bad_credentials_fail() throws Exception { AccountDTO.LoginRequestDTO loginRequest = AccountDTO.LoginRequestDTO.builder() .email(&quot;bong@email.com&quot;) .password(&quot;passs&quot;) .build(); this.mockMvc.perform(post(&quot;/getAuthorization&quot;) .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE) .content(objectMapper.writeValueAsString(loginRequest)) ) .andDo(print()) .andExpect(jsonPath(&quot;authorization&quot;).value(Matchers.containsString(ReturnCodes.BAD_CREDENTIALS))) ;} 실패 - username 오류 123456789101112131415@Testpublic void getAuth_bad_usernamenotfound_fail() throws Exception { AccountDTO.LoginRequestDTO loginRequest = AccountDTO.LoginRequestDTO.builder() .email(&quot;bong@email.com&quot;) .password(&quot;passs&quot;) .build(); this.mockMvc.perform(post(&quot;/getAuthorization&quot;) .contentType(MediaType.APPLICATION_JSON_UTF8_VALUE) .content(objectMapper.writeValueAsString(loginRequest)) ) .andDo(print()) .andExpect(jsonPath(&quot;authorization&quot;).value(Matchers.containsString(ReturnCodes.USER_NOTFOUND))) ;} UserDetailsService 구현한 AccountService 생성 1234567891011121314151617@Service@RequiredArgsConstructorpublic class AccountService implements UserDetailsService { private final AccountRepository accountRepository; @Override public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException { Optional&lt;Account&gt; byEmail = accountRepository.findByEmail(email); Account account = byEmail.orElseThrow(() -&gt; new UsernameNotFoundException(\"not found\")); return new User(account.getEmail(), account.getPassword(), authorities(account.getRoles())); } private Collection&lt;? extends GrantedAuthority&gt; authorities(Set&lt;AccountRole&gt; roles) { return roles.stream().map(r -&gt; new SimpleGrantedAuthority(\"ROLE_\" + r.name())).collect(Collectors.toSet()); }} username으로 email을 사용 authorities로 사용할 AccountRole을 미리 enum 으로 만들어 놓았다. passwordEncoder 1234@Beanpublic PasswordEncoder passwordEncoder() { return PasswordEncoderFactories.createDelegatingPasswordEncoder();} SpringSecurity 설정 12345678910111213141516171819202122232425262728293031@Configuration@EnableWebSecurity@RequiredArgsConstructorpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter { private final PasswordEncoder passwordEncoder; private final AccountService accountService; @Override public void configure(WebSecurity web) throws Exception { web.ignoring().antMatchers(\"/getAuthorization\"); } public DaoAuthenticationProvider daoAuthenticationProvider() { DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider(); authenticationProvider.setUserDetailsService(accountService); authenticationProvider.setPasswordEncoder(passwordEncoder); return authenticationProvider; } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.authenticationProvider(daoAuthenticationProvider()); } @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); }} 테스트를 위해 시큐리티 필터 미적용(“/getAuthorization”) DaoAuthenticationProvider 생성 빈으로 등록한 passwordEncoder와 UserDetailsService의 구현체인 AccountService를 설정해준다. 생성한 DaoAuthenticationProvider를 AuthenticationManager에 등록한다. configure(AuthenticationManagerBuilder auth) 메소드를 통해 AuthenticationManger를 만들고 해당 AuthenticationManager를 사용한다. configure(AuthenticationManagerBuilder auth) 메소드를 사용하지 않으면 빈으로 등록된 Provider를 찾아 AuthenticationManger를 만들고 사용한다. AuthenticationManager를 빈으로 등록하기 위해 authenticationManagerBean() 을 오버라이딩하고 빈으로 등록해준다. Login 맵핑 12345678910111213141516171819202122232425@RestController@RequiredArgsConstructorpublic class AccountController { private final AuthenticationManager authenticationManager; @PostMapping(\"/getAuthorization\") public ResponseEntity getAuthorization(@RequestBody AccountDTO.LoginRequestDTO requestDTO) { UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(requestDTO.getEmail(), requestDTO.getPassword()); try { Authentication authenticate = authenticationManager.authenticate(token); ResponseVO response = ResponseVO.builder().authorization(\"success \" + ReturnCodes.OK).build(); return ResponseEntity.ok(response); } catch (AuthenticationException e) { if (e instanceof BadCredentialsException) throw new BadCredentials(); if (e instanceof UsernameNotFoundException) throw new AccountNotFound(); } ResponseVO fail = ResponseVO.builder().authorization(\"fail\").build(); return ResponseEntity.ok(fail); }} Exception발생 시, @ExceptionHandler, @ResponseBody를 사용하여 Json으로 응답하도록 하였다. (생략) 테스트 실행 성공 실패 - password 오류 실패 - username 오류 문제점 AuthenticationManager를 빈으로 등록 후, 다른 서비스에서 authenticateManager.authenticate()를 사용하여 인증할 때 username이 틀려도 password가 틀려도 모두 BadCredentialsException만 발생 Debug Controller WebSecurityConfigurerAdapter.authentiacate(Autentication authentication) delegate(AuthenticationManager)가 있으면 사용 없으면 빌더로 가져오기 ProviderManager.authenticate(Authentication authentication) this.providers : AnonymousProvider (어떤 프로파이더인지는 잘모르겠다.) parents providers : DaoAuthenticationProvider (설정했던 provider) AnonymousProvider는 지원하지 않아서 지나감. result(파라미터로 넘긴 authentication.getClass())와 parent가 있으면 parent.authenticate(authenticate); 재귀함수 호출 다시 왔을때는 provider가 설정한 DaoAuthenticationProvider인것을 알 수있다. provider.authenticate(authentication);을 호출한다. AbstractUserDetailsAuthenticationProvider retrieveUser() 안에서 UserDetailsService.loadUserByUsername(String email); 을 호출한다. hideUserNotFoundExceptions 를 확인해서 BadCredentialsException을 던지고 있다. hideUserNotFoundExceptions을 확인해보자. 기본적으로 true setHideUserNotFoundException을 통해 false로 변경 될 수 있는데.. 이건 DaoAuthenticationProvider 설정 시에 설정할 수 있다. 이렇게 설정 되어있는 이유는 ? 아이디 체크와 비밀번호 체크를 따로 exception을 날리는거보다 BadCredential Exception하나만 날리는것이 보다 더 보안이 강하기 때문에… 해결 AuthenticationProvider 생성 시에 setHideUserNotFoundException(false); 로 설정한다. 그러나 더 강한 보안을 위해서라면 모두 BadCredential을 호출하는것이 맞다.","link":"/2019/09/30/Security/usernamenotfound/"},{"title":"정보처리기사 필기 - 1과목(데이터베이스)","text":"정보처리기사 -필기1과목 - 데이터베이스 로킹로킹(Locking)이란?하나의 트랜잭션이 데이터를 액세스 하는 동안 다른 트랜잭션이 그 데이터 항목을 액세스할 수 없도록 하는 방법 로킹단위 : 로킹의 대상이되는 객체의 크기(데이터 베이스, 파일, 레코드등) 로킹단위가 커지면, 로크수가 적어 관리하기 쉽지만 데이터베이스의 공유도(병행성)이 감소 로킹단위가 작으면, 로크수가 많아 오버헤드가 커지지만 병행성 수준이 높아진다. 이진트리의 운행법 Preorder(전위)운행 : Root -&gt; Left -&gt; RightA -&gt; B -&gt; C Inorder(중위)운행 : Left -&gt; Root -&gt; RightB -&gt; A -&gt; C Postorder(후위)운행 : Left -&gt; Right -&gt; RootB -&gt; C -&gt; A데이터 베이스의 정의 통합된 데이터(Integrated Data) : 자료의 중복을 배제한 데이터의 모임 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장매체에 저장된 자료 운영 데이터(Operational Data) : 조직의 업무를 수행하는데 있어서 존재 가치가 확실하고 없어서는 안될 반드시 필요한 자료 공용 데이터(Shared Data) : 여러 응용 시스템들이 공통으로 소유하고 유지하려는 자료트랜잭션의 특성 Atomicity(원자성) 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야함. 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되야 하며, 모두가 완벽히 수행되지않고 어느하나라도 에러가 발생하면 트랜잭션 전부가 취소되어야 함. Consistency(일관성) 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함. 시스템이 가지고 있는 고정요소는 트랜잭션 수행전과 트랜잭션 수행 완료 후의 상태가 같아야 함. Isonlation(독립성, 격리성) 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음. 수행중인 트랜잭션은 완전히 완료 될 때 까지는 다른 트랜잭션의 결과를 참조할 수 없음. Durability(영속성, 지속성) 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함. 데이터베이스의 특징 실시간 접근성(Real Tiem Accessibility) : 수시적이고 비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능함. 계속적인 변화(Continuous Evolution) : 새로운 데이터의 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지함. 동시공유(동시공용)(Concurrent Sharing) : 여러 사용자가 동시에 자기가 원하는 데이터를 이용할 수 있음. 내용에 의한 참조(Content Reference) : 데이터베이스에 있는 데이터를 참조할 때 데이터 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 데이터를 찾음.(값에의한 참조) 함수적 종속 관계어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분집합이라고 할 경우, X의 값 각각에 대한 시간에 항상 애트리뷰트 Y의값이 오직하나면 연관되어 있을때, Y는 X에 함수종속적이라고 하며, ‘X-&gt;Y’와 같이 표기한다. 스키마의 3계층외부 스키마(ExterSchema) = 서브 스키마 = 사용자 뷰(View) 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한다. 전체 데이터베이스의 한 논리적인 부분으로 볼 수 있으므로 서브 스키마라고도 한다. 하나의 데이터 베이스 시스템에는 여러 개의 외부 스키마가 존재 할 수 있으며, 하나의 외부 스키마를 여러 개의 응용프로그램 사용자가 공용할 수 있다. 같은 데이터베이스에 대해서도 서로 다른 관점을 정의 할 수 있도록 허용한다. 일반 사용자는 질의어(SQL)를 사용하여 DB를 사용한다. 개념 스키마(Conceptual Schema) = 전체적인 뷰(View) 데이터베이스의 전체적인 논리적 구조로서, 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 통합 한 조직 전체의 데이터베이스로 하나만 존재 한다. 개념 스키마는 개체 간의 관계와 제약조건을 나타내고 데이터베이스의 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의한다. 단수히 스키마라고 하면, 개념 스키마를 의미한다. 기관이나 조직체의 관점에서 데이터베이스르 정의한것이다. 데이터베이스 관리자에 의해서 구성된다. 내부 스키마(Internal Schema) 물리적 저장장치의 입장에서 본 데이터베이스 구조로, 물리적인 저장장치와 밀접한 계층이다. 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의하고, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다. 시스템 프로그래머나, 시스템 설계자가 보는 관점의 스키마이다. 데이터베이스의 물리적 구조를 정의한다. 데이터의 실제 저장 방법을 기술한다. 물리적인 저장장치와 밀접한 계층이다. 시스템 카탈로그 시스템 그 자체에 관련이 있는 스키마 및 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스이다. 데이터베이스에 포함되는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지관리하는 시스템 테이블이다. 데이터 정의어의 결과로 구성되는 기본 테이블, 뷰, 인덱스, 패키지, 접근권한 등의 데이터 베이스 구조 및 통계정보를 저장한다. 카탈로그들이 생성되면 자료사전에 저장되기 때문에 좁은 의미로는 카탈로그를 자료 사전이라고도 한다. 카탈로그에 저장된 정보를 메타 데이터라고 한다. 특징 카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 사용자도 SQL을 이용하여 내용을 검색해 볼 수 있다. INSERT, DELETE, UPDATE문으로 갱신하는 것은 허용하지 않는다. DBMS가 스스로 생성하고 유지한다. 카탈로그는 사용자가 SQL문을 실행시켜 기본 테이블, 뷰, 인덱스 등에 변화를 주면 시스템이 자동으로 갱신된다. 자료구조의 분류 선형구조 : 선형 리스트(배열), 연결 리스트, 스택, 큐, 데크 비선형구조 : 트리, 그래프 릴레이션의 특징 한 릴레이션에 포함된 튜플들은 모두 상이하다. 한 릴레이션에 포함된 튜플 사이에는 순서가 없다. 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다. 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다. 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지마, 속성을 구성하는 값은 동일한 값이 있을 수 있다. 릴레이션을 구성하는 튜플은 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 설정한다. 속성은 더이상 쪼갤 수 없는 원자값만을 저장한다. 릴레이션에서 degree는 속성의 술를 의미한다. 정렬 버블정렬 선택정렬 n개의 레코드 중에서 최소값을 찾아 첫번째 레코드 위치에 놓고, 나머지 n-1개 중에서 다시 최소값을 찾아 두번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식이다. 삽입정렬 수와 관계해석 관계대수 : 원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적인 특성을 가지는것 관계해석은 원래 수학의 프레디킷 해석에기반을 두고 있다. 관계대수는 릴레이션을 처리하기 위한 연산의 집합으로 피연산자가 릴레이션이고 결과도 릴레이션이다. 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력 면에서 동등하다. 분산데이터베이스 장점 분산제어가 용이하다. 지역자치성이 높다. 효용성과 융통성이 높다. 점진적 시스템 확장이 용이하다. 단점 데이터베이스 설계가 어렵다. 개발비용이 증가한다. 트리(Tree)와 차수(Degree) 차수(Degree) : 가장 차수가 많은 노드의 차수 터미널 노드 : 자식이 하나도 없는 노드 E-R 다이어그램 표현 마름모 : 관계타입 속성 : 타원 개체 : 사각형 특정 DBMS를 고려한 것은 아니다. 1976년 Peter Chen이 제안하였다. 개체타입과 관계타입을 기본 개념으로 현실 세계를 개념적으로 표현하는 방식이다. 데이터 모델의 구성요소 데이터 모델의 구성요소 3가지 구조(Structure) : 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적성질을 표현함. 연산(Operation) : 데이터베이스에 저장된 실제 데이터를 처리하는 방법을 표시하는 것으로 데이터베이스를 조작하는 기본도구이다. 제약조건(Constaint) : 데이터베이스에 저당될 수 있는 실제 데이터의 논리적인 제약조건을 표시함. 순차파일 파일 탐색 시, 모든파일을 비교하면서 검색해야 하므로 검색효율이 낮아 즉각적인 응답을 요구하는 대화형 처리에는 적합하지 않습니다. 레코드가 키 순서대로 편성되어 취급이 용이하다. 연속적인 레코드의 저장에 의해 레코드 사이에 빈 공간이 존재하지 않으므로 기억장치의 효율적인 이용이 가능하다. 필요한 레코드를 삽입, 삭제, 수정하는 경우 파일을 재구성해야 하므로 파일 전체를 복사해야한다. 색인 순차 파일 색인 순차 파일은 인덱스를 저장하기 위한 공간과 오버플로우 처리를 위한 별도의 공간이 필요하다. 순차 처리와 직접 처리가 모두 가능하다. 레코드를 추가 및 삽입하는 경우, 파일 전체를 복사할 필요가 없다. 색인 구역은 트랙 색인 구역, 실린더 색인 구역, 마스터 색인 구역으로 구성된다. 구성 기본 구역(Prime Area) : 실제 레코드들을 기록하는 부분, 각 레코드를 키 값 순으로 저장 색인 구역(Index Area) : 기본 구역에 있는 레코드들의 위치를 찾아가는 색인이 기록되는 부분으로, 트랙 색인 구역, 실린더 색인 구역, 마스터 색인 구역으로 구분할 수 있음. 오버플로 구역(Overflow Area) : 기본 구역에 빈 공간이 없어서 새로운 레코드의 삽입이 불가능할 때를 대비하여 예비적으로 확보해 둔 부분 정규화함수적 종속성등의 종속성 이론을 이요하여, 잘못 솔계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어가는 과정 정규화의 목적 데이터 구조의 안정성을 최대화한다. 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만든다. 효과적인 검색 알고리즘을 생성할 수 있다. 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지한다. 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다. 정규화과정 비정규릴레이션 1NF -&gt; 도메인이 원자값 2NF -&gt; 부분적 함수 종속 제거 3NF -&gt; 이행적 함수 종속 제거 BCNF(강한 제 3정규형) -&gt; 결정자이면서 후보키가 아닌 것 제거 4NF -&gt; 다치종속 5NF -&gt; 조인 종속성 이용 폴리쉬 순수 관계 연산자 Select 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만듦 릴레이션의 행에 해당하는 튜플을 구하는 것이므로 수평연산 이라고도 함. 연산자의 기호는 그리스문자 마(𝝈)를 사용함. Project 주어진 릴레이션에서 속성 List에 제시된 Attribute만을 추출하는 연산 릴레이이션의 열에 해당하는 Attribute를 추출하는 것이므로 수직 연산자라고도 함. 연산자의 기호는 그리스 문자 파이를 사용함. Join 공통 속성을 중심으로 2개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산 연산자기호는 ⧓ 사용함. Division X ⊃ Y인 2개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산 예제 관계 데이터베이스의 Relation 구조 튜플 : 행 Degree : 속성 수 Cardinality : 튜플의 수 망(그래프, 네트워크)형 데이터 모델 CODASYL 이 제안한 것으로 CODASYL DBTG 모델 이라고도 한다. 상위와 하위 레코드 사이에서 다대다(N : M) 대응관계를 만족하는 구조이다. 상위의 레코드를 Owner, 하위의 레코드를 Member라하여 Owner-Member 관계라고도한다. 레코드 타입 간의 관계는 1:1, 1:N, N:M이 될 수 있다. 대표적인 DBMS : DBTG, EDBS, TOTAL 등 해싱(Hashing) 버킷(Bucket) : 하나의 주소를 갖는 파일의 한 구역을 의미하며, 버킷의 크기는 같은 주소에 포함될 수있는 레코드 수를 의미함. 슬롯(Slot) : 1개의 레코드를 저장할 수 있는 공간으로 n개의 슬롯이 모여 하나의 버킷을 형성함. Collision(충돌현상) : 서로 다른 2개 이상의 레코드가 같은 주소를 갖는 현상 Synonym : 같은 Home Address를 갖는 레코드들의 집합 Overflow 계산된 Home Address의 Bucket 내에 저장할 공간이 없는 상태 Bucket을 구성하는 Slot이 여러개 일때는 Collision은 발생해도 Overflow는 발생하지 않을 수 있음. DBMS의 필수기능 정의(조직)(Definition) 데이터의 형과 구조, 데이터가 DB에 저장될 때의 제약조건 등을 명시하는 기능이다. 데이터와 데이터의 관계를 명확하게 명세할 수 있어야 하며, 원하는 데이터 연산은 무엇이든 명세할 수 있어야한다. 조작(Manipulation) 데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 데이터 접근 수단등을 정하는 기능이다. 사용자와 데이터베이스 사이의 인터페이스 수단을 제공한다. 제어(Control) 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게수행되어 데이터의 무결성을 유지되도록 제어 해야한다. 정당한 사용자가 허가된 데이터만 접근할 수 있도록 보안을 유지하고 권한을 검사할 수 있어야 한다. 여러 사용자가 데이터베이스를 동시에 접근하여 데이터를 처리할 때, 처리결과가 항상 정확성을 유지하도록 병행 제어를 할 수 있도록 한다.","link":"/2019/03/01/test/test01/"},{"title":"정보처리기사 필기 - 3과목(운영체제)","text":"정보처리기사 -필기3과목 - 운영체제 시스템 소프트웨어의 구성 제어 프로그램(Control Program) : 시스템 전체의 작동상태 감시, 작업의 순서 지정(스케쥴링), 작업에 사용되는 데이터 관리, 인터럽트 처리 등의 역할을 수행하는 프로그램 감시(Supervisor) 프로그램 : 프로그램의 실행과 시스템 전체의 작동상태를 감시, 감독하는 프로그램 작업제어(Job Control) 프로그램 : 어떤업무를 처리하고 다른업무로의 이행을 자동으로 수행하기 위한 준비 및 그 처리에 대한 완료를 담당하는 프로그램 자료관리(Data Management) 프로그램 : 주기억장치와 보조 기억 장치 사이의 데이터 전송과 보조기억장치의 자료 갱신 및 유지 보수 기능을 수행하는 프로그램 처리 프로그램 : 제어프로그램의 지시를 받아 사용자가 요구한 문제를 해결하기 위한 프로그램 언어 번역 프로그램 : 원시 프로그램을 기계어 형태의 목적 프로그램으로 번역하는 프로그램 (어셈블리, 컴파일러, 인터프리터) 서비스 프로그램 : 컴퓨터를 효율적으로 사용할 수 있는 사용빈도가 높은 프로그램 문제 프로그램 : 특정 업무 및 해결을 위해 사용자가 작성한 프로그램 운영체제의 개요정의 시스템의 자원을 효율적으로 관리하며, 사용자가 컴퓨터를 효과적으로 사용할 수 있도록 환경을 제공 windows, ms-dos, unix, linux 등이 있다. 목적 처리능력, 신뢰도, 사용가능도 향상 반환시간 단축 성능평가기준 처리능력(Throughput) : 일정시간동안 처리하는 일의 양 반환시간(Turn Around Time) : 요청부터 처리가 완료될때 까지 걸린시간 사용 가능도(Availability) : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도 신뢰도(Reliability) : 시스템이 주어진 문제를 정확하게 해결하는 정도 기능 프로세스 관리 사용자 및 시스템 프로세스 생성/제거 프로세스 스케쥴링 자원관리 자원의 효과적인 경영 스케쥴링 사용자와 시스템간 편리한 인터페이스 제공 시스템의 각종 하드웨어와 네트워크 관리/제어 오류검사 및 복구, 데이터관리, 데이터 및 자원 공유 자원보호 가상 계산기 기능 병렬 수행을 위한 편의성 운영체제 운용 기법 및 발달 과정운영체제 운용 기법 일괄처리(Batch Processing) 시스템 초기의 컴퓨터에서 사용 일정량 또는 일정기간의 데이터를 모아서 한꺼번에 처리 효율적으로 사용할 수 있음 사용자 측면에서 응답시간이 늦지만, 하나의 작업이 모든 자원을 독점하여 CPU 유휴시간 줄어듦 급여계산, 지불계산, 연말 결산 등의 업무에 사용됨. 다중 프로그래밍(Multi Programming)시스템 하나의 CPU와 주기억장치를 이용하여 여러개의 프로그램을 동시에 처리하는 방식 하나의 주기억장치에 2개이상의 프로그램을 기억시켜놓고, 하나의 CPU와 대화하면서 동시처리 시분할(Time Sharing) 시스템 여러명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리해줌 라운드 로빈방식이라고도 함. 하나의 CPU는 같은시점에서 여러개의 작업을 동시에 수행할 수 없기 때문에 CPU의 전체 사용시간을 작은 작업 시간량으로 나누어 그시간량 동안만 번갈아 가면서 cpu를 할당하여 각 작업을 처리 다중 프로그래밍 방식과 결합하여 모든 작업이 동시에 처리되는것처럼 대화식 처리가 가능함. 다중 처리(Multi Processing) 시스템 여러개의 CPU와 하나의 주기억장치를 이용하여 여러 프로그램을 처리하느 방식 하나의 CPU가 고장나더라도 다른 CPU를 이용하여 업무를 처리할 수 있으므로 시스템의 신뢰성과 안정성이 높음. 실시간 처리(Real Time Processing) 시스템 데이터 발생 즉시, 또는 데이터 처리 요구 즉시 처리하여 결과를 산출 시간에 제한을 두고 수행되어야 하는 작업에 사용됨 다중 모드 처리(Multi Mode Processing) : 일괄 처리 시스템, 시분할 시스템, 다중 처리 시스템, 실시간 처리 시스템을 한 시스템에서 모두 제공하는 방식 분산 처리 (Distributed Processing) 여러개의 컴퓨터를 통신 회선으로 연결하여 하나의 작업을 처리하는 방식 각 단말장치 및 컴퓨터 시스템은 고유의 운영체제 및 CPU, 메모리를 가지고 있음 운영체제 발달 과정일괄 처리 시스템 -&gt; 다중 프로그래밍, 다중 처리, 시분할, 실시간 처리 시스템 -&gt; 다중 모드 -&gt; 분산 처리 시스템 매크로와 매크로 프로세서 매크로 : 동일한 코드를 한번만 작성하여, 정의된 이름을 호출하여 사용하는 것 매크로 프로세서 : 원시 프로그램에 존재하는 매크로 호출 부분에 매크로 프로그램을 삽입하여 확장 된 원시 프로그램을 생성하는 시스템 소프트웨어 링커/로더링커 언어 번역 프로그램이 생성한 목적 프로그램들과 라이브러리, 또 다른 실행프로그램 등을 연결하여 실행 가능한 로드 모듈을 만드는 시스템소프트웨어 연결 기능만 수행하는 로더의 한 형태로 링커에 의해 수행되는 작업을 링킹이라고 한다. 로더정의 컴퓨터 내부로 정보를 들여오거나, 로드모듈을 디스크 등의 보조 기억장치로부터 주기억장치에 적재하는 시스템 소프트웨어 기능 할당(Allocation) : 기억장치 내에 옮겨놓을 공간을 확보 연결(Linking) : 부프로그램 호출 시, 할당된 기억장소의 시작주소를 호출한 부분에 연결 재배치(Relocation) : 보조기억장치에 저장된 프로그램이 사용하는 각 주소들을 할당된 기억장소의 실제 주소로 배치시키는 기능 적재(Loading) : 실행 프로그램을 할당된 기억공간에 실제 옮기는 기능 종류 Compile And Go Loader : 별도의 로더 없이 언어 번역프로그램이 로더의 기능까지 수행 절대로더(Absolute Loader) 목적 프로그램을 기억장소에 적재시키는 기능만 수행 가장 간단한 로더 기억장소 할당 및 연결을 프로그래머가 직접 지정 한번 지정한 주 기억장치의 장소를 변경하기 어려움 직접 연결 로더(Direct Linking Loader) : 일반적인 기능의 로더로, 로더의 기능 4가지를 모두 수행하는 로더 동적 적재 로더(Dynamic Loading Loader) : 프로그램을 한꺼번에 적재하는것이 아니라, 필요한 일부분만을 적재하는 로더 프로세스일반적으로 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램을 의미한는것으로 프로세스는 필요한 각종 자원을 요구한다. 정의 실행중인 프로그램, PCB를 가진 프로그램, 실 기억장치에 저장된 프로그램 프로세서가 할당되는 실체, 프로시저 활동중인것 비동기적 행위를 이으키는 주체, 지정된 결과를 얻기 위한 일련의 계통적 동작 목적 또는 결과에 따라 발생하는 사건들의 과정 프로세서가 할당하는 개체로서 디스패치가 가능한 단위 국부성(Locality, 구역성) 실행중인 프로세스가 주기억장치를 참조할 때는 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론으로 Denning에 의해 증명됨. 스래싱을 방지하기 위한 워킹 셋 이론의 기반이 된다. 캐시 메모리 시스템의 이론적 근거이다. 프로세스가 집중적으로 사용되는 페이지를 알아내느 방법 중 하나로, 가상 기억장치 관리의 이론적인 근거가 된다. 종류 시간 구역성(Temporal Locality) 프로세스가 실행되면서 하나의 페이지를 일정 시간동안 집중적으로 액세스하는 현상 한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음을 의미함 시간 구역성이 이루어지는 기억장소 : Loop, 스택, 부프로그램, couning, totaling 공간 구역성(Spatial Locality) 프로세스 실행 시, 일정 위치의 페이지를 집중적으로 액세스하는 현상 공간 구역성이 이루어지는 기억장소 : 배열순회, 순차적 코드의 실행, 프로그래머들이 관련된 변수들 디렉토리의 구조 1단계 디렉토리 가장 간단하고, 모든파일이 하나의 디렉토리 내에 위치하여 관리되는 구조 모든 파일들이 유일한 이름을 가지고 있어야 함. 2단계 디렉토리 중앙에 마스터 디렉토리(MFD)가 있고, 그 아래에 사용자별로 서로 다른 파일 디렉토리(UFD)가 있는 2 계층 구조 트리 디렉토리 하나의 루트 디렉토리, 여러개의 종속(서브) 디렉토리로 구성된 구조 DOS, windows, UNIX 등의 운영체제에서 사용되는 디렉토리 구조 디렉토리 생성, 파괴가 비교적 용이 포인터를 사용하여 디렉토리를 탐색 경로명은 절대경로와 상대경로명을 사용 비순환 그래프 디렉토리 하위 파일이나 하위 디렉토리를 공동으로 사용할 수 있는것으로 사이클이 허용되지 않는 구조 하나의 파일이나 디렉토리가 여러개의 경로 이름을 가질 수 있음 공유 된 파일을 삭제할 경우 고아 포인터(Dangling Pointer) 발생 일반적인 그래프 디렉토리 트리 구조에 링크(Link)를 첨가시켜 순환을 허용 디렉토리와 파일 공유에 완전한 융통성이 있음 불필요한 파일을 제거하여 사용 공간을 늘리기 위하여 참조 계수기가 필요함. 하이퍼 큐브 하나의 프로세서에 연결되는 다른 프로세서의 수(연결점)가 n개일 경우 프로세서는 총 2의 n제곱승 개가 필요하다. HRN 기법우선순위 공식 : (대기시간 + 서비스 시간)/ 서비스 시간계산 된 숫자가 클수록 우선순위가 높다. UNIX특징 시분할 시스템을 위해 설계된 대화식 운영체제 소스가 공개된 개방형 시스템이다. 대부분 C언어로 작성되어 있어 이식성이 높음, 장치 프로세스간 호환성 높음 크기가 작고 이해하기 쉬움 Multi-User, Multi-Tasking을 지원한다. 많은 네트워킹 기능을 제공하므로 통신망(Network)관리용 운영체제로 적합하다. 트리 구조의 파일 시스템 백그라운드에서 작업을 수행할 수 있으므로 여러개의 작업 병행 처리할 수 있다. 정보와 유틸리티들을 공유하여 편리하게 작업을 수행할 수 있다. UNIX 시스템의 구성 커널(Kernel) UNIX의 가장 핵심 하드웨어를 보호(캡슐화)하고, 프로그램들과 하드웨어간 인터페이스를 담당 프로세스관리, 기억장치 관리, 파일관리등 여러가지 기능 수행 컴퓨터 부팅 시, 주기억장치에 적재되어 상주하면서 실행됨 쉘(Shell) 사용자의 명령어를 인식, 프로그램 호출하는 명령어 해석기 시스템과 사용자 간의 인터페이스를 담당함 DOS의 COMMAND.COM과 같은 기능을 수행함 주기억장치에 상주하지 않고 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능함 유틸리티(Utility) 일반 사용자가 작성한 응용 프로그램을 처리하는데 사용함 DOS에서 외부 명령어에 해당함 명령어 파일내용을 화면에 표시 : cat 파일의 소유자를 변경 : chown 새로운 프로세스를 생성 : fork 기억장치 관리 전략반입전략(Fetch)반입 : 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할것인지 결정하는 전략 요구 반입 : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할때 적재 예상 반입 : 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재 배치전략(Placement)배치 : 주기억장치 어디에 위치시킬 것인지를 경정하는 전략 최초적합(First Fit) : 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법 최적적합(Best Fit) : 빈 영역 중에서 단편화를 가장 작게 남기는 분할영역에 배치시키는 방법 최악적합(Worst Fit) : 빈 영역 중에서 단편화를 가장 크게 남기는 분할영역에 배치시키는 방법 교체전략교체(Replacement) 전략 : 주 기억장치의 모든 영역이 이미 사용중인 상태에서 기억장치의 필요한 페이지를 주기억장치에 배치하려고 할 때, 이미 사용되고있는 영역중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략으로 FIFO, OPT, LRU, LFU, NUR, SCR등이 있음 스레싱(Thrashing)하나의 프로세스가 작업수행과정에서 수행하는 기억장치 접근에서 지나치게 페이지 폴트가 발생하여 프로세스 수행에 소요되는 시간보다 페이지 이동에 소요되는 시간이 더커지는 현상 워킹셋(Working set) 프로세스가 일정시간 동안 자주 참조하는 페이지들의 집합 데닝(Denning)이 제안한 구역성(Locality)특징을 이용한다. 자주 참조되는 워킹 셋을 주기억장치에 상주시켜, 페이지의 부재 및 교체를 줄인다. 워킹셋은 시간에 따라 변경된다. 페이지부재 페이지 부재 : 참조할 페이지가 주기억장치에 없는 현상 페이지 부재 빈도 : 페이지 부재 현상 횟수 페이지 부재 빈도 방식 : 페이지 부재율에 따라 주기억장치에 있느 프레임의 수를 조절하여 부재율을 적정 수준으로 유지하는 방식 세마포어(Semaphore)‘신호기’, ‘깃발’을 뜻하며, 각 프로세스에 제어 신호를 전달하여 순서대로 작업을 수행하도록 하는 기법 교혼(Swapping)하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법 파일 디스크립터(File Descriptor) 파일을 관리하기 위해 시스템이 필요로 하는 파일에 대한 정보를 갖고 있는 제어 블록(파일 제어 블록, FCB) 보통 파일 디스크립터는 보조기억장치 내에 저장되어 있다가 해당파일이 Open될때 주기억장치로 옮겨진다. 파일마다 독립적으로 존재, 시스템에 따라 다른 구조를 가질 수 있다. 파일 시스템이 관리하므로 사용자가 직접 참조할 수 없다. 파일 디스크립터 정보 파일 ID, 이름, 크기, 구조, 유형 보조기억장치 위치, 유형 액세스 제어정보, 횟수 생성 시간, 제거 시간, 최종 수정 시간, 직접 파일(Direct File), 직접 접근방식 파일을 구성하는 레코드를 임의의 물리적 저장공간에 기록하는 것장점 파일의 각 레코드에 직접 접근 및 기록 가능 접근시간 빠름 레코드 삽입, 삭제, 갱신이 용이함 단점 레코드의 주소 변환 과정이 필요하며, 이 과정으로 인해 시간 소요 기억공간의 효율 저하 기억장치의 물리적 구조에 대한 지식이 필요 다중 처리기의 운영체제 구조 주/종 처리기 하나의 프로세서를 Master로 지정하고, 나머지들을 Slave로 지정하는 비대칭 구조 주 프로세서가 고장나면 전체 시스템 다운 주 프로세서 : 입출력, 연산 담당 ,운영체제 수행 종 프로세서 : 연산만 담당 분리 실행 처리기 주/종 처리기의 비대칭성을 보완하여 각 프로세서가 독자적인 운영체제를 가지고 있도록 구성한 구조 각 프로세서 발생 인터럽트 해당 프로세서 해결 한 프로세서가 고장나더라도 전체 시스템 다운되지 않음 대칭적 처리기 여러 프로세서들이 완전한 기능을 갖춘 하나의 운영체제를 공유하여 수행하는 구조 가장 복잡한 구조를 가지고 있으나 가장 강력한 시스템 여러개의 프로세스가 동시에 수행가능하며, 시스템 전반적인 정보를 통일적이고 일관성있게 운영 프로세서의 수를 늘린다고 해도 시스템 효율은 향상되지 않음 프로세서 간의 통신은 공유 메모리를 통해 이루어짐 가상 기억장치(Virtual Memory)구현기법 페이징 기법 가상 기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 주기억장치 영역에 적재시켜 실행 외부단편화는 발생하지 않으나, 내부 단편화는 발생할 수 있음 페이지 맵 테이블이 필요함 세그먼테이션 기법 가상 기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후, 주기억장치에 적재시켜 실행 논리적인 크기로 나눈 단위를 세그먼트라고 부른다. 각 세그먼트는 고유한 이름과 크기를 가지며, 다른세그먼트에 할당된 영역을 침범할 수 없다. 이를위해 기억장치 보호키가 필요하다. 내부 단편화는 발생하지 않으나, 외부 단편화는 발생할 수 있다. 세그먼트 맵 테이블이 필요함 PCB(Process Control Block) 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳 프로세스가 생성될 때마다 고유의 PCB가 생성, 프로세스가 완료되면 PCB가 제거됨 PCB에 저장되어 있는 정보 프로세스의 현재상태, 고유식별자, 우선순위, 스케줄링 포인터 CPU 레지스터 정보 주기억장치 관리정보, 입출력상태정보, 계정정보 디스크 스케줄링 사용할 데이터가 디스크상의 여러 곳에 저장되어있는 경우, 데이터를 액세스하기위해 디스크 헤드가 움직이는 경로를 결정하는 기법 목적 처리량 최대화 평균응답시간 최소화 응답시간 편차 최소화 종류 FCFS(First Come First Service) 가장 간단한 스케줄링 디스크 대기 큐에 가장먼저 들어온 트랙에 대한 요청을 먼저 서비스 공평성이 보장 SSTF(Shortest Seek Time First) 탐색거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스 현재 헤드위치에서 가장 가까운 거이에 있는 트랙으로 헤드를 이동 FCFS보다 처리량이 많고, 평균탐색시간 짧음 탐색패턴이 편중되어 안쪽 및 바깥쪽 트랙이 가운데보다 서비스를 덜받음, 기아상태 발생할 수 있음 처리량이 많은 일괄 처리 시스템에 유용함 SCAN SSTF의 탐색편차를 해소 현재 헤드위치에서 진행방향 결정하여 탐색 걱리가 짧은 순서에 따라 요청을 서비스, 끝까지 이동후 역방향 요청 서비스 진행 C-SCAN(Circular SCAN) 항상 바깥쪽에서 안쪽으로 움직이면서 가장 짧은 탐색거리를 갖은 요청을 서비스하는 기법 끝까지 이동후 바깥쪽 끝으로 이동 후 다시 요청을 서비스함 N-Step SCAN SCAN의 무한대기 가능성을 제거한 것 시작당시 요청에 대해서만 서비스하고, 진행도중 도착한 요청은 반대방향 진행시 서비스 에션바흐(Eschenbach) 부하가 매우 큰 항공 예약 시스템을 위해 개발 탐색시간과 회전 지연 시간을 최적화 헤드는 C-SCAN처럼 움직이며, 모든 실린더는 요청의 유무에 곤계없이 전체트랙이 한바퀴 회전할 동안 서비스를 받음 SLTF(Shortest Latency Time First) 섹터큐잉(Sector Queing)이라고 하며, 회전 시간의 최적화 분산운영체제 구조 성형 연결구조(STAR) 모든 사이트는 하나의 호스트에 직접연결 중앙 컴퓨터 장애 시 모든 사이트 간 통신불가 통신 비 최대 두개의 링크만 필요(통신비 저렴) 파일보호기법종류 파일의 명명(Naming) : 파일이름을 모르는 사용자를 접근대상에서 제외시킴 비밀번호(password) : 각 파일에 판독 암호와 기록 암호를 부여하여 암호를 아는 사용자에게만 접근허용 접근제어(Access Control) : 사용자에 따라 공유 데이터에 접근할 수 있는 권한을 제한 보안유지기법 외부보안 시설보안 : 천재지변이나 외부 침입자로부터의 보안 운용보안 : 전산소 관리 및 경영자들의 정책과 통제에 의해 이루어지는 보안 사용자 인터페이스 보안 운영체제가 사용자의 신원을 확인 후 권한이 있는 사용자에게만 시스템의 프로그램과 데이터를 사용할 수 있게 하는 보안기법 내부보안 하드웨어나 운영체제의 내장된 보안 기능을 이용하여 시스템의 신뢰성을 유지하고 보안문제를 해결하는 기법 자원보호기법객체(자원)에 불법적으로 접근하는 것을 제어하고 객체(자원)에 물리적인 손상을 예방하는 것 종류 접근 제어 행렬(Acess Control Matrix) 자원 보호의 일반적인 모델 객체에 대한 접근권한을 행렬로써 표시한 기법 전역 테이블(Global Table) 가장 단순한 구현방법 3개의 순서쌍인 영역, 객체, 접근권한의 집합을 목록형태로 구성한 기법 접근 제어 리스트(Acess Control List) 접근 제어 행렬의 열 즉, 객체를 중심으로 리스트를 구성한 기법 권한(자격) 리스트(Capability List) 접근 제어 행렬의 행 즉, 영역을 중심으로 리스트를 구성한 기법 사용자에 대한 자격들로 구성된다. 자격은 객체와 그 객체에 호용된 연산 리스트임 프로세서의 결합도 약결합(Loosely Coupled) 시스템 각 프로세스마다 독립된 메로리를 가진 시스템 -&gt; 분산 처리 시스템 둘 이상의 독립된 컴퓨터 시스템을 통신망을 통하여 연결한 시스템 각 시스템 독립적인 운영체제 각 시스템은 독립적으로 작동하며, 필요한 경우 상호 통신 가능 프로세서 간 통신은 메세지전달 및 원격 프로시저 호출을 통해서 이루어진다. CPU간 결합력이 약함 강결합(Tightly Coupled) 시스템 동일한 운영체제 하에 여러개의 프로세서가 하나의 메모리를 공유하는 시스템 -&gt; 다중 처리 시스템 하나의 운영체제가 모든 프로세서 및 시스템 하드웨어를 제어함 프로세서간 통신은 공유 메모리를 통해 이루어진다. 공유 메모리를 차지하려는 프로세서간 경쟁을 최소화해야한다. CPU간 결합력이 강합 페이지의 크기 작을경우 페이지 단편화가 감소 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다. 기억장치 효율이 높아짐 맵 테이블의 크기가 커지고, 매핑속도가 늦어짐 디스크 접근 횟수가 많아져서 전체적인 입출력 시간 증가 필요한 내용만 적재될 확률이 높기 때문에 더 효율적인 워킹 셋을 유지할 수 있다. 큰 경우 페이지 단편화 증가 한개의 페이지를 주기억장치로 이동하는 시간이 늘어난다. 디스크 접근횟수가 줄어들어 입출력 효율성이 증가한다. 프로그램에 불필요한 내용까지도 주기억장치에 적재될 수 있다. 교착상태 해결방법 예방기법 : 교착상태가 발생하지 않도록 사전에 시스템을 제어, 교착 발생 4가지 조건중 한가지를 제거함으로써 자원 낭비가 가장 심함 상호 배제 부정 점유 및 대기 부정 비선점 부정 환형 대기 부정 회피 기법 : 교착상태가 발생할 가능성을 배제하지 않고, 교착발생시 적절히 피해나가능 방법 은행원 알고리즘 : 각 프로세스에게 자원을 할당하여 교착상태가 발생하지 않는다.","link":"/2019/03/01/test/test02/"},{"title":"Async","text":"@Async 스프링 부트에서 개발자에게 비동기 처리를 하기 위해 제공하는 방법중 하나이다. Reactive stack, CompletableFuture등이 있으나 가장 쉬운 방법이 @Async 적용이다. 사용법 @EnableAsync로 @Async를 스프링에게 알린다. 123456789@SpringBootApplication@EnableAsyncpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 비동기로 수행되었으면 하는 메소드위에 @Async를 적용한다. Controller 12345678910111213@RestController@RequiredArgsConstructorpublic class SampleController { private final SampleService sampleService; @GetMapping(\"/async\") public void async() { for (int i = 0; i &lt; 1000; i++) { sampleService.async(i); } }} Service 12345678910@Service@Transactional@Slf4jpublic class SampleService { @Async public void async(int i) { log.info(\"async test - \" + i); }} Thread Pool 설정 별도의 설정이 없으면 비동기 작업을 스레드 플에서 처리하는것이 아니고, 새로운 스레드를 매번 생성해서 작업을 수행시키는것이 default 설정이다. Thread Pool 빈 등록 1234567891011121314//import java.util.concurrent.Executor;@Configurationpublic class ThreadConfig { @Bean public Executor myPool() { ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor(); threadPoolTaskExecutor.setCorePoolSize(8); threadPoolTaskExecutor.setMaxPoolSize(8); threadPoolTaskExecutor.setThreadNamePrefix(\"task\"); return threadPoolTaskExecutor; }} SpringBoot 2.0 이상이라면 auto configuration으로 Excutor(스레드 풀)를 빈으로 등록해준다. yml, properties 파일을 통해 관련 설정을 변경할 수 있다. 123456spring: task: execution: pool: max-size: 8 core-size: 8 Thread Pool 병렬 작업 처리가 많아지면 스레드 개수가 증가되고 스레드 생성과 스케쥴링으로 인해 CPU가 바빠져 메모리 사용량이 늘어난다.이러한 갑작스런 병렬작업의 극대화로 인한 스레드의 증폭으 맞기위해서 사용한다.작업처리에 사용되는 스레드를 제한된 개수만큼 정해놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 스레드가 맡아서 처리한다. 처리가 끝난 스레드는 다시 작업 큐에서 작업을 가져와 처리한다. 결과 Async 적용 미적용 심화주의사항 public 메소드에만 적용이 가능하다. Self-Invocation(자가호출) 메소드는 적용 불가능하다. (= 같은 클래스 내부의 메소드를 호출하는것은 안됨) 해당 메소드의 리턴값은 void 또는 CompletableFuture&lt;&gt; 이유 AOP가 적용되어 springcontext에 등록되어 있는 빈 객체의 메소드가 호출될 때, Async가 적용되어 있는 메소드를 스프링이 가로채서 스레드풀에서 실행시켜 준다. public이어야 프록시가 될수 있고, 가로챈 스프링의 다른 클래스에서 호출이 가능 셀프호출은 프록시를 우회하고 해당 메소드를 직접 호출하기 때문에 작동하지 않는다. https://dzone.com/articles/effective-advice-on-spring-async-part-1 문제 service의 메소드는 동기로 호출되기를 바라지만, 내부에서 하는 일부의 기능에 대해 비동기로 실행하기를 바란다면 @Async동작이 불가능 하다. (내부 메소드를 호출은 @Async적용이 불가하여..) 해결 AsyncService를 하나 만들고 유틸클래스 처럼 사용 AsyncService 1234567@Servicepublic class AsyncService { @Async public void asyncRun(Runnable runnable) { runnable.run(); }} 사용 12345678910111213141516@Service@Transactional@RequiredArgsConstructor@Slf4jpublic class SampleService { private final AsyncService asyncService; public void asyncCall(int i) { asyncService.asyncRun(() -&gt; async(i)); } public void async(int i) { log.info(\"async test - \" + i); }} 결과 @Async 사용하지 않고 CompletableFuture를 쓰되, 쓰레드 풀을 주입받아 해당 쓰레드 풀에서 실행 CompletableFuture 사용 12345678910111213141516@Service@Transactional@RequiredArgsConstructor@Slf4jpublic class SampleService { private final Executor myPool; public void asyncCall(int i) { CompletableFuture.runAsync(() -&gt; async(i), myPool); } public void async(int i) { log.info(\"async test - \" + i); }} 결과 More 비동기로 작업(다른 Thread)시, Authentication 전달 안됨 Exception 발생 시, Test Class 에서는 잡히지 않는다… (메인 스레드를 보고 있음) 참고 정아무추어 코딩블로그 - How does @Async work? Limky 삽질블로그 - Java Thread Pool(스레드 풀) 허원철의 개발 블로그 - SpringBoot Async 제대로 사용하기 spring guide","link":"/2019/10/26/spring/async/"},{"title":"정보처리기사 필기 - 4과목(소프트웨어 공학)","text":"정보처리기사 -필기4과목 - 소프트웨어 공학 품질표준 정확성(Correctness) 신뢰성(Reliability) 효율성(Efficency) 무결성(Integrity) 사용 용이성(Useability) 유지보수성(Maintainability) 유연성(Flexibility) 시험 역량(Testability) 이식성(Portability) 재사용성(Reusability) 상호 운용성(Interoperability) 객체지향 기법구성요소 객체 데이터와 데이터를 처리하는 함수를 묶어놓은 하나의 모듈 이름을 가진다. 메세지를 받았을 때 수행 클래스 공통된 속성과 연산을 갖는 객체의 집합 객체의 타입을 의미 속성과 연산을 정의하고 있는 틀 클래스에 속하는 객체를 인스턴스라고 함 메세지 객체들 간의 상호작용을 하는데 사용되는 수단 명령 수신자의 이름, 수행할 메소드 이름, 메소드를 수행할 때 필요한 인자로 구성 되어있다. 주요 기본원칙 캡슐화(Encapsulation) 정보 은닉(Information Hiding) 상속성(Inheritance) 추상화(Abstraction) 다형성(Polymorphism) 럼바우(Rumbaugh)의 분석 기법 그래픽 표기법을 이용하여 모델링하는 기법 분석활동 객체(Object) 모델링 : 객체들간의 관계를 규정하여 객체 다이어그램 동적(Dynamic) 모델링 : 시간의흐름에 따른 동적인 행위를 표현 기능(Function) 모델링 : 자료 흐름을 중심으로 처리과정 표현 정형 기술 검토(FTR) 가장 일반적인 검토방법 소프트웨어 기술자들에 의해 수행되는 소프트웨어 품질 보증 활동 목적 해당요구사항과 검토중인 소프트웨어가 일치하는지를 검증함 정해진 표준에 따라 표현되고 있는지, 기능 및 로직의 오류가 있는지 확인함 균일한 방식으로 개발되도록 함 보다 용이하게 관리하도록 함 지침사항 검토에만 집중 의제를 제한하여 진행 논쟁과 반박을 제한 문제영역을 명확히 표현 해결책이나 개선책을 논하지 말라 참가자수 제한, 사전준비 강요 체크리스트 자원과 시간일정을 할당 의미있는 훈련을 행하라 사전에 작성한 메모를 공유 검토의 과정과 결과를 재검토 응집도(Cohesion) 정보은닉의 개념을 확장한 것으로 모듈안의 요소들이 관련되어있는정도를 나타낸다. 모듈의 내부 요소에는 특정작업을 수행하기 위한 명령어, 명령어의 모임, 호출문 등이 있다. 독립적인 모듈이 되기위해서는 응집도가 강해야한다. 종류아래로 갈수록 응집도가 약하다. 기능적(Functional) 응집도 : 단일문제와 연관되어 수행 될 경우 순차적(Sequential) 응집도 : 출력데이터를 다음 활동의 입력데이털 사용할 경우 교환(통신)적(Communication) 응집도 : 동일한 입력과 출력을 사용 절차적(Procedural) 응집도 : 모듈이 다수의 관련기능을 가질때 모듈안의 구성요소들이 그기능을 순차적으로 수행할 경우 시간적(Temporal) 응집도 : 특정시간에 처리되는 몇개의 기능을 모아 하나의 모듈로 작성할 경우 논리적(Logical) 응집도 : 유사한 성격, 특정 형태로 분류되는 요소들로 하나의 모듈이 형성되는 응집도 우연적(Coincidental) 응집도 : 서로 관련없는 다른 기능을 수행하느 경우의 응집도 화이트 박스 테스트 원시 코드를 오픈 시킨 상태에서 논리적인 모든 경로를 검사하여 검사 사례를 설계하는 방법 종류 기초 경로 검사 조건 검사 루프검사 데이터 흐름검사 블랙 박스 테스트 소프트웨어 인터페이스에서 실시되는 검사 각 기능이 완전히 작동하는 것을 입증하는 검사 기능검사 종류 동치 분할 검사 경계값 분석 원인-효과 그래프 검사 오류 예측 검사 비교검사 프로젝트 일정 계획 브룩스(Brooks)의 법칙 : 진행중에 새로운 인력을 투입할 경우, 작업 적응 기간과, 부작용으로 인해 일정을 더욱 지연시키고 혼란을 가져온다. PERT/CPM 프로젝트의 지연을 방지하고, 일정을 계획하는 것 프로젝트 개발 기간을 결정하는 임계 경로(CP : Critical Path)를 제공한다. 각 작업에 대한 시작 시간을 정의하여 작업들 간의 경계시간을 계산할 수 있게한다. PERT 상호관계를 표시하는 네트워크 단계별 종료 시기를 결정하는 방법 노드와 간선으로 구성된다. 노드에는 작업, 간선에는 낙관치/기대치/비관치 표시 작업에 대한 경계 시간, 작업 간의 상호 관련성, 작업의 결정 경로를 확인할 수 있음 CPM 프로젝트 완성에 필요한 작업을 나열하고, 소요시간을 예측하는데 사용하는 기법 노드는 작업, 간선은 작업사이의 전후 의존관계를 표시 원형노드는 작업, 박스노드는 이정표, 박스위에는 예상 완료 시간을 표시함 한 이정표에서 다른 이정표에 도달하려면 이전의 작업이 모두 완료 되어야함 경영층의 과학적인 의사결정을 지원하며, 효과적인 프로젝트 통제를 가능하게 해 줌 결합도 모듈간 상호 의존하는 정도를 나타낸다. 독립적인 모듈이 되기 위해서는 결합도가 낮아야 한다. 종류아래로 갈수록 결합도가 강하다. 자료 결합도(Data Coupling) : 모듈간 인터페이스가 자료 요소로만 구성될 경우 스탬프 결합도(Stamp Coupling) : 배열이나 레코드등의 자료구조가 전달될 경우 제어 결합도(Control Coupling) : 내부의 논리적인 흐름을 제어하기 위해 제어 신호를 이용하여 통신하거나, 제어요소를 전달하는 경우 외부 결합도(External Coupling) : 외부로 선언한 데이터를 참조할 경우 공통 결합도(Common Coupling) : 공통 데이터 영역을 여러 모듈이 사용할 경우 내용 결합도(Content Coupling) : 내부기능 및 내부자료를 직접 참조하거나 수정할 경우 CASE 소프트웨어 개발 과정에서 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것 소프트웨어 개발 환경을 조성한다. 생명 주기의 전체 단계를 연결 자동화해 주는 통합된 도구를 제공하는 기술 소프트웨어 개발도구 + 방법론 = 생산성 향상을 구현하는 공학기법 주요기능 소프트웨어 생명주기 전단계 연결 다양한 소프트웨어 개발 모형 지원 그래픽 지원 장점 개발 기간 단축 비용절감 품질향상 유지보수 용이 생산성 향상 재사용성 향상 개발주기의 표준화 개발기법의 실용화 문서화 용이 CASE 분류 상위(Upper) CASE 생명주기의 전반부에서 사용 문제를 기술하고 계획 ‘모델 모순검사, 오류검증, 자료흐름도 작성’ 기능 지원 하위(Lower) CASE 생명주기의 후반부에서 사용 코드의 작성, 테스트, 문서화 과정 지원 통합(Intergrate) CASE 생명주기에 포함되는 전체 과정을 지원 정보저장소(Repository) CASE 정보 저장소, CASE 데이터 베이스, 요구사항 사전, 저장소라고도 한다. 장점 유지 보수성 향상 쉽게 새로운 도구를 추가 가능 통합 CASE도구를 사용 가능 불필요한 정보 제거 생명주기 정보를 재사용 이식과 변환을 용이하게 한다. 소프트웨어 재공학 기존에 있던 소프트웨어를 파기하지 않고, 새로운 요구에 맞도록 수정보완 하거나 새로운 기능을 추가하여 성능을 향상 시키는 것 유지보수성과 품질을 향상시키려는 기술 위험부담이 감소되고 개발비용이 절감된다. 자동화된 도구를 사용하여 소프트웨어를 분석하고 수정하는 과정을 포함한다. 주요활동 분석 : 기존 명세서를 확인하여 동작을 이해하고, 재공학 대상을 선정하는 것 개조(재구조, 재구성, Restructure) 상대적으로 같은 추상적 수준에서 하나의 표현을 다른 표현형태로 바꾸는 것 기존의 소프트웨어의 구조를 향상시키기 위하여 코드를 재구성하는것(기능과 외적인 동작은 바뀌지 않는다.) 역공학 기존 소프트웨어를 분석하여 개발과정과 데이터 처리과정을 설명하는 분석 및 설계정보를 재발견하고나 다시 만들어내는 작업 일반적인 개발 단계와 반대되는 의미로 기존 코드를 복구하는 방법 역공학의 가장 간단하고 오래된 형태는 재문서화이다. 이식 : 다른운영체제나 하드웨어 환경에서 사용할 수 있도록 변환 목표 복잡한 시스템을 다루는 방법 구현 다른 뷰의 생성 잃어버린 정보의 복구 및 제거 부작용의 발견 기능모형의 설계 순서 입, 출력 결정 자료 흐름도 작성 기능의 내용을 상세히 기술 제약사항을 결정하고 최소화 자료 흐름도의 구성요소 :프로세스(Process), 자료 흐름(Data flow), 자료 저장소(Data Store), 단말(Terminator) 자료사전(DD) 데이터를 설명하는 데이터 메타데이터 표기 = : 자료의 정의 -&gt; ~로 구성되어있다. (is composed of) + : 자료의 연결 -&gt; 그리고 () : 자료의 생략 -&gt; 생략가능한 자료 [|] : 자료의 선택 -&gt; 또는 {} : 자료의반복 ** : 자료의 설명 -&gt; 주석 검사전략검증 검사 형상검사 : 모든사항들이 제대로 표현되었는지 검사 알파 검사 사용자가 개발자 앞에서 행하는 검사 통제된 환경, 문제점을 확인하면서 기록 베타검사 사용자가 사용자 앞에서 수행하는 검사 제어되지 않는상태에서 사용상의 문제점 기록","link":"/2019/03/02/test/test03/"},{"title":"\\@RequestParam, \\@Pathvariable(RESTful), tiles, File up/down, JSON, AOP, Transaction (KOSTA)","text":"KOSTA DAY57Springframework RequestParam HTTP 요청 파라미터를 매핑 get 방식으로 data를 전달한다. parameter값에 @RequestParam 사용하여 변수를 받는다.(RequestParam을 사용 시, 장점은 자동으로 형변환을 해준다는 점이다. 후에 나올 PathVariable도 마찬가지) PathVarialbe URI 템플릿 변수에 접근할 때 사용 RESTful 방식 http://somehost/users/madvirus http://somehost/games/ http://somehost/forum/board1/10 @RequestMapping 어노테이션 값으로 {템플릿변수}를 사용한다. @PathVariable 어노테이션을 이용해서 {템플릿변수}와 동일한 이름을 갖는 파라메터를 추가한다. tiles웹 페이지의 상단이나 하단, 메뉴와 같은 반복적으로 사용되는 부분들에 대한 정보를 한 곳에 모아 둔 프레임워크 레이아웃 : 모든 페이지에 표시될 HTML과 반복 적으로 사용될 부분의 위치를 정의한 JSP 파일. Tiles Definition : 레이아웃에서 반복적으로 사용되는 부분들(HTM, JSP)지정하는 설정. (설정:XML) tiles-api 라이브러리 추가가 필요하다. tiles 설정파일을 bean객체로 등록한다. 출력을 위한 viewResolver를 등록한다. 을 사용하여 viewResolver의 우선순위를 정한다. 공통된 부분을 base_layout을 지정한다. 각 페이지의 본문이 될부분을 지정한다.(base_layout을 extends한 definition으로 설정 ) 파일 업/다운로드업로드 commos-io / commons-fileupload 라이브러리가 필요하다. uploadDir : 업로드 될 폴더 경로 MultipartFile 객체 생성 후, 업로드 된 파일을 받는다. 받은 파일을 transferTo 메소드를 사용하여 업로드 경로에 넣는다. 파일이름을 추출하여, DB에 insert 시, 같이 기입한다. 다운로드 다운로드를 위한 뷰를 작성 후 bean객체로 등록한다. 해당view는 java파일임으로 viewResolver를 등록한다. multipartResolver bean객체를 등록한다. 파일이름과 경로를 받아서 새로운 파일 객체를 생성한다. 생성된 객체를 담아서 등록한 bean객체로 보낸다. JSON Json객체를 컨트롤러로 만들어주기 위해서는 해당 라이브러리가 필요하다. @RestController 어노테이션을 통해서 JSON객체로 변환하는 컨트롤러를 생성한다. RequestMapping 후, JSON객체로 변환할 객체 or List를 리턴한다.매핑된 json 객체를 사용하기 위해서는 view에서 다음과같이 스크립트를 설정한다. 파라미터값으로 url주소와, data(넘겨줄값 없으면 생략), 콜백함수 를 가진다. $.ajax 와 유사하게 사용된다.(비동기식) Spring MVC AOP이전에 포스팅하였던 AOP를 MVC패턴에서 적용하는법에 대해 알아보자. 예제spring-aspects 라이브러리가 필요하다. @Aspect를 사용한 공통 관심사항 클래스를 생성한다. ProceedingJoinPoint객체를 파라미터로 가지는 @Around 메소드를 생성한다. Around : 공통관심사항 가운데 핵심관심사항이 나타나게 하는 어노테이션 object 배열에 핵심관심사항을 담는다.(여러개일수 있음으로 배열) request객체로 형변환하여 담는다. “name”이름의 session값을 얻는다. 리턴할 뷰의값을 fail상태로 초기화한다. 값이 null일경우, 에러발생하여, catch문으로 전달되어 fail상태 그대로 리턴된다. 값이 null이 아닐경우 핵심관심사항이 호출되어 success값을 리턴하게 된다. namespaces에 aop를 추가한다. 생성한 aspect class를 bean객체로 등록한다. Spring Transaction 트랜잭션은 성공적으로 처리되거나 또는 하나라도 실패하면 완전히 실패 처리를 해야 하는 경우에 사용 스프링에서 트랜잭션 관리 기능을 지원하고, 간단한 설정으로 트랜 잭션 처리 가능함 어노테이션 기반 트랜잭션을 대부분 사용한다.어노테이션을 활용하여 트랜잭션 처리하는 방법에 대해 알아보자. 예제주문 데이터 생성과 동시에 재고 데이터가 주문한 수량만큼 감소되며, 재고가 없을 시, 실패되는 트랜잭션처리 예제이다. 어노테이션을 활용한 트랜잭션처리를 위해서는 spring-tx 라이브러리가 필요하다. 트랜잭션 매니저 객체를 생성한다. property 값으로 dataSource객체를 갖는다. &lt;tx:annotation-driven transaction-mansger=”*”&gt;을 통해 등록한 트랜잭션매니저 객체를 등록한다. @Transactional 태그를 사용하여 메소드를 생성한다.(propagation = Propagation.REQUIRED → 트랜잭션이 없으면 새로운 트랜잭션을 생성해라.) rollbackFor= {Exception.class} → 예외발생시, rollback 주문등록 후에 남은 재고량보다 주문량이 많을 경우 예외를 발생시킨다. service에서 예외발생 시, 에러를 출력하고 다시 주문 창으로 연결된다. 예외발생이 없을 시, 성공 화면으로 view 이동","link":"/2019/01/28/spring/kosta_spring03/"},{"title":"정보처리기사 필기 - 5과목(데이터 통신)","text":"정보처리기사 -필기5과목 - 데이터 통신 동축 케이블 주파수 범위가 넓어 데이터 전송률 높음 꼬임선에 비해 외부 간섭과 누화의 영향이 적음 신호 감쇠 현상을 막기 위해 일정 간격마다 중계기를 설치해야한다. 광대역 전소에 적합하며 CATV, 근거리 통신망등에 사용된다. 위성 마이크로파 지상에서 쏜 마이크로 주파수를 통신위성을 통해 증폭한 후 다른 주파수로 자상에 송신하는 방식 위성통신 시스템은 통신 위성 지구국 채널로 구성된다. 대역폭이 넓어 고속 및 대용량 통신이 가능하고 통신 비용이 저렴 하나의 통신 위성에 여러개의 지구국이 접속하여 사용하므로 통신위성을 공동으로 사용하기 위한 다중 접속방식이 필요함(FDMA, TDMA, CDMA) 단방향 통신한쪽방향으로만 전송이 가능한 방식 (라디오,TV) 반이중 통신양방향 전송이 가능하지만 동시에 양쪽방향에서 전송할 수 없는방식 전이중 통신동시에 양방향 전송이 가능한 방식","link":"/2019/03/03/test/test04/"},{"title":"Spring MVC, valid이용 검증, mybatis 연동 (KOSTA)","text":"KOSTA DAY56SpringframeworkSpring MVCMVC(Model-View-Controller)패턴 어플리케이션의 확장을 위해 Model, View, Controller 세가지 영역으로 분리 컴포넌트의 변경이 다른 영역 컴포넌트에 영향을 미치지 않음 컴포넌트 간의 결합성이 낮아 프로그램 수정이 용이 장점 화면과 비즈니스 로직을 분리해서 작업 가능 영역별 개발로 인하여 확장성이 뛰어남 표준화된 코드를 사용하므로 공동작업이 용이하고 유지보수성이 좋음 단점 개발과정이 복잡해 초기 개발속도가 늦음 초보자가 이해하고 개발하기에 다소 어려움 Spring MVC MVC패턴 기반 웹 개발 프레임워크 Dispatcher Servlet : 컨트롤러 역할을 한다. (.do 등으로 오는 모든 요청을 받아서 연결시켜줌) Controller : 기존의 action 클래스의 역할 Handler Mapping : Dispatcher Servlet이 Controller로 매핑하는 방식을 설정 (설정하지 않으면 Default annotation mapping →annotation으로 메소드를 호출) ModelAndView : view 이름 , data를 담을수 있다. (최근 5버젼 사용자들은 잘안쓴다고 한다.) viewResolver : view 타입을 설정해준다. view : 받은 data를 출력 요청 처리 순서 DispatcherServlet이 요청을 수신 단일 front controller servlet 요청을 수신하여 처리를 다른 컴포넌트에 위임 어느 컨트롤러에 요청을 전송할지 결정 DispatcherServlet은 Handler Mapping에 어느컨트롤러를 사용할 것인지 문의 URL과 매핑 DispatcherServlet은 요청을 컨트롤러에게 전송하고 컨트롤러는 요청을 처리한 후 결과 리턴 비즈니스 로직 수행 후 결과 정보(Model)가 생성되어 JSP와 같은 뷰에서 사용됨 ModelAndView 오브젝트에 수행결과가 포함되어 DispatcherServlet에 리턴 ModelAndView는 실제 JSP정보를 갖고 있지 않으며, ViewResolver가 논리적 이름을 실제 JSP이름으로 변환 View는 결과정보를 사용하여 화면을 표현함 좋은 디자인은 컨트롤러가 많은 일을 하지 않고 서비스에 처리를 위임 라이브러리 설정Spring MVC 를 위해 Maven을 사용하여 라이르러리를 적용하였다. Spring MVCmvc패턴을 사용하기 위해 라이브러리 필요 validator@valid, @InitBinder 어노테이션 사용하기 위해 필요 Spring jdbcDB연동을 위해 필요 mybatismybatis-config.xml사용하기 위해 필요 mybatis-springmybatis-spring 연동을 위해 필요 DispatcherServlet 설정 다른 Servlet처럼 web.xml에 등록 기본적으로 “-servlet.xml” 파일에서 어플리케이션 컨텍스트 정보를 로드 은 DispatcherServlet이 처리하는 URL 매핑 패턴을 정의 springframework의 springapp라는 이름의 DispatcherServlet를 등록한다. DispatcherServlet 영역 지정 ‘/’를 지정한것은 모든 요청을 영역으로 지정한것 context: annotation-configcontext: component-scan base-package=”kosta”→ kosta 패키지 안의 모든 @ 를 찾아 객체화 mvc: annotation-dirvenmvc:default-servlet-handler→ 매핑되는 컨트롤러가 없어도 default serlvet handler가 빈객체로 등록되어, default servlet handler에 요청을 전달한다. viewResolver -Controller가 넘긴 view이름을 통해 알맞은 view 를 찾는 역할 prefix 경로 / suffix 타입 한글처리 web.wml에서 한글처리를 위한 filter 처리 가능 @Controller , @Service 등으로 객체화 Controller 내에 @RequestMapping 으로 매핑 @Autowired, @Inject 를 사용하여 DI 처리 같은 매핑 조건이더라도, RequestMethod 타입에 의해 전해진다. data를 가져가는 방법 ModelAndView (setViewName, addObject) Model (addAttribute) command 객체 command 객체form에서 입력된 값을 받기 위한 객체form 의 name = command객체의 필드변수명과 같을 때, 쓸수 있다. @ModelAttribute 어노테이션 설정으로 모델명을 설정할 수 있다. valid 검증valid 검증을 위해서 라이브러리가 필요하다. Validator 를 implements 하는 객체를 생성 @validate 시, 발생 될 validate 메소드를 오버라이드 해당 객체 및 메소드를 사용하기 위해 @InitBinder 어노테이션 등록InitBinder 메소드 작성 @Valid 어노테이션으로 원하는 검증위치에 사용검증내용을 직접 작성하지않고, 빈값, 사이즈, 문자타입 등을 어노테이션으로 등록 후, InitBinder어노테이션 없이 @Valid 사용이 가능하다. NotEmpty : 빈값일 때, error Size : min값, max값 설정 Pattern : 정규표현식등을 사용하여, 패턴설정 mybatis 연동xml 설정 원하는 DB의 name, password, url, 을 입력하고, name, type을 정하여 server.xml에 기입한다. 작성한 Resource를 참조하여, Dispatcher Servlet.xml 을 작성한다. dataSource → jndiObjectFactoryBean sqlSessionFactorydataSource → 생성한 dataSource 객체configLocation → mybatis-config.xml 설정파일 sqlSessionTemplatesqlSessionFactory → sqlSessionFactory객체 DB연동 Dao객체 생성 → 등록한 sqlSessionTemplate 선언 및 등록 Dao객체 등록","link":"/2019/01/25/spring/kosta_spring02/"},{"title":"Spring MVC TEST (KOSTA)","text":"KOSTA DAY59Springframework Mapper TestCRUD를 위한 Mapping이 잘되었는지 확인하기위한 Test방법에 대해 알아보자. 테스트를 위한 DB의 테이블과 data를 생성한다.(table명 = tbl_board, seq_board) BoardVO클래스 생성 BoardMapper 인터페이스 생성 및 메소드 생성 BoardMapper.xml 생성 및 select 쿼리문 작성 BoardMapperTests 테스트 클래스 생성 후 Junit Test처리전체 data 로그로 출력 Create Test 인서트문의 경우 두가지 처리방법이 있다. 인서트 후에, pk정보가 필요없는 경우 처리방법/pk정보가 필요한 경우 먼저 pk정보가 필요없는 insert Query문 작성 Test 실행 bno값이 null로 결과가 나온다. pk정보가 필요한 경우 insert insert문 안 selectKey태그를 작성하여, pk값을 구한다.(bno) 위와 같은 방식으로 test를 실행했을때, 결과값에 bno값이 출력된다. Read Testpk정보를 이용하여 테이터 출력을 해보자. Long값을 파라미터값으로 쓸 경우, L을 뒤에 붙여준다. Service Testservice 객체를 만들어서 Test를 실행해보자. service 패키지를 생성root-context.xml에 service 패키지를 scan할 수 있도록 설정한다. service 인터페이스 생성 servie 인터페이스를 implements 하는 InsertBoardService 생성 InsertBoardService에 오버라이딩 메소드를 작성한다.내용 → Insert(selectKey사용) 테스트 실행 Controller TestController 객체를 만들어서 Test 해보자. Controller는 기본적으로 서버로 부터 받는 주소값을 가지고 결과를 요청하는 공간이기 때문에 서버를 실행하지 않고 Test하기 위해서는 Test 클래스 안에서 설정이 필요하다. BoardController를 생성한다. ControllerTest 생성 및 설정 WebAppConfiguration을 사용하여 WebAppicationContext를 이용할 수 있도록 한다. ContextConfiguration으로 설정 파일을 로드한다. WebAppicationContext를 Setter로 DI한다. MockMvc를 선언한다. 이유는 WAS 구동을 하지 않고도 테스트를 할 수 있기 때문에 Before 어노테이션은 테스트 메소드 실행 전 실행하게 해준다. 테스트 코드를 상기 예제와같이 작성 후 실행하면 톰캣 서버 실행을 하지 않아도 결과가 log로 출력된다. post방식/ 파라미터값이 있는 경우 예제를 작성해보았다.","link":"/2019/01/30/spring/kosta_spring05/"},{"title":"스프링 MVC 동작 원리01 - 스프링 MVC 소개, 서블릿","text":"스프링 웹 MVC(inflearn) - 백기선Springframework 백기선님의 스프링 웹 MVC강의를 수강하고 공부내용을 정리하고 있습니다.해당 강좌는 스프링 MVC에 대하여 핵심원리, 설정, 활용으로 나누어 강의해주고 있습니다.모든 예제는 github에 올리고 있습니다. 스프링 MVC 소개 스프링 MVC M: 모델 도메인 객체 또는 DTO로 화면에 전달할 또는 화면에서 전달 받은 데이터를 담고 있는 객체. 평범한 자바 객체 POJO ex) V: 뷰 데이터를 보여주는 역할. 다양한 형태로 보여줄 수 있다. HTML, JSON, XML, … HTML. JSP, 타임리프, … 스프링부트는 기본적으로 동적인 뷰를 resources - templates디렉토리에서 찾는다. ex) C: 컨트롤러 사용자 입력을 받아 모델 객체의 데이터를 변경하거나, 모델 객체를 뷰에 전달하는 역할. 입력값 검증 입력 받은 데이터로 모델 객체 변경 변경된 모델 객체를 뷰에 전달 @Controller 사용한 클래스 ex) tip Java9는 적은수의 요소로 편리하게 Collections의 인스턴스를 생성 할 수 있는 새로운 정적 팩토리를 지원한다. 다만 정적 팩토리 메소드로 작성된 콜렉션은 불변이므로, 요소 또는 null을 add/put 하려고 하면 java.lang.UnsupportedOperationException 또는 java.lang.NullPointerException 을 발생 시킨다.123List&lt;String&gt; immutableList = List.of(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;);Set&lt;String&gt; immutableSet = Set.of(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;);Map&lt;Integer,String&gt; immutableMap = Map.of(1,&quot;one&quot;,2,&quot;two&quot;,3,&quot;three&quot;) MVC 패턴의 장점 동시 다발적(Simultaneous) 개발 - 백엔드 개발자와 프론트엔드 개발자가 독립적으로 개발을 진행할 수 있다. 높은 결합도 - 논리적으로 관련있는 기능을 하나의 컨트롤러로 묶거나, 특정 모델과 관련있는 뷰를 그룹화 할 수 있다. 낮은 의존도 - 뷰, 모델, 컨트롤러는 각각 독립적이다. 개발 용이성 - 책임이 구분되어 있어 코드 수정하는 것이 편하다. 한 모델에 대한 여러 형태의 뷰를 가질 수 있다. MVC 패턴의 단점 코드 네비게이션 복잡함 코드 일관성 유지에 노력이 필요함 높은 학습 곡선 서블릿 서블릿 (Servlet) 자바 엔터프라이즈 에디션은 웹 애플리케이션 개발용 스팩과 API 제공. 요청 당 쓰레드 (만들거나, 풀에서 가져다가) 사용 그 중에 가장 중요한 클래스중 하나가 HttpServlet. 서블릿 등장 이전에 사용하던 기술인 CGI (Common Gateway Interface) 요청 당 프로세스를 만들어 사용 서블릿의 장점 (CGI에 비해) 빠르다. 플랫폼 독립적 보안 이식성 서블릿 엔진 또는 서블릿 컨테이너 (톰캣, 제티, 언더토, …) 세션 관리 네트워크 서비스 MIME 기반 메시지 인코딩 디코딩 서블릿 생명주기 관리 … 우리가 만든 서블릿 어플리케이션은 직접 사용할 수 없으며, 반드시 서블릿 컨테이너를 이용하여 사용할 수 있다. 서블릿 생명주기 서블릿 컨테이너가 서블릿 인스턴스의 init() 메소드를 호출하여 초기화 한다. 최초 요청을 받았을 때 한번 초기화 하고 나면 그 다음 요청부터는 이 과정을 생략한다. 서블릿이 초기화 된 다음부터 클라이언트의 요청을 처리할 수 있다. 각 요청은 별도의 쓰레드로 처리하고 이때 서블릿 인스턴스의 service() 메소드를 호출한다. 이 안에서 HTTP 요청을 받고 클라이언트로 보낼 HTTP 응답을 만든다. service()는 보통 HTTP Method에 따라 doGet(), doPost() 등으로 처리를 위임한다. 따라서 보통 doGet() 또는 doPost()를 구현한다. 서블릿 컨테이너 판단에 따라 해당 서블릿을 메모리에서 내려야 할 시점에 destroy()를 호출한다 서블릿 어플리케이션 개발가장 기본적이고 원시적인 서블릿 어플리케이션 개발 메이븐 프로젝트 생성 archetype 사용(메이븐이 만들어 놓은 프로젝트 틀) webapp archetype 사용 Java Servlet API 의존성 추가 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; provided 스코프는 코딩시점에서는 사용이 가능하나, runtime시점에는 사용할 수 없다.(어디선가 제공할것이다. 톰캣 컨테이너에서 제공(서블릿 컨테이너) 톰캣 설치 및 추가 artifacts 는 war-exploded로 추가한다. war는 압축된것 exploded 풀린상태 web.xml에 서블릿 클래스 추가 및 매핑 추가 서블릿 리스너와 필터서블릿 리스너 웹 애플리케이션에서 발생하는 주요 이벤트를 감지하고 각 이벤트에 특별한 작업이 필요한 경우에 사용할 수 있다. 서블릿 컨텍스트 수준의 이벤트 컨텍스트 라이프사이클 이벤트 컨텍스트 애트리뷰트 변경 이벤트 세션 수준의 이벤트 세션 라이프사이클 이벤트 세션 애트리뷰트 변경 이벤트 예제 서블릿 리스너 생성 implements ServletContextListener web.xml에 리스너 등록 리스너 적용 및 결과 서블릿 필터 들어온 요청을 서블릿으로 보내고, 또 서블릿이 작성한 응답을 클라이언트로 보내기 전에 특별한 처리가 필요한 경우에 사용할 수 있다. 체인 형태의 구조 예제 서블릿 필터 생성 implements Filter(javax.servlet) doFilter 설정 다음 필터 적용 또는 마지막 필터인 경우 서블릿은 연결해준다. web.xml에 필터 등록 및 매핑 매핑은 servlet-name 또는 url-pattern 으로 매핑할 수 있다. 리스너 - 필터 - 서블릿 순서로 init destroy는 역순","link":"/2019/04/23/spring/spring_web_mvc01/"},{"title":"Sheduled","text":"@Scheduled 스케줄러 설정 @EnableScheduling 을 사용하여 스케쥴링을 사용하는것을 알린다. 1234567@SpringBootApplication@EnableSchedulingpublic class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); }} SpringBoot 2.0 에서는 auto-configuration으로 스케줄러를 생성해준다.그러나 이 스케줄러의 경우, 쓰레드풀이 아니기 때문에 많은 작업이 있을 때 효율적이지 못하다. 많은 작업이 필요한 경우, 쓰레드 풀을 사용할 수 있도록 설정할 수 있다. yml 파일 설정 123456spring: task: scheduling: pool: size: 8 thread-name-prefix: my-scheduler 이미지 configuration 설정 1234567891011@Configurationpublic class SchedulerConfiguration { @Bean public TaskScheduler poolScheduler() { ThreadPoolTaskScheduler threadpool = new ThreadPoolTaskScheduler(); threadpool.setPoolSize(Runtime.getRuntime().availableProcessors() * 2); threadpool.setThreadNamePrefix(\"my-scheduler\"); return threadpool; } } Runtime.getRuntime().availableProcessors() = 4 사용법 주기적으로 실행을 요하는 메소드 위에서 @Scheduled 를 사용한다.(빈으로 등록된 클래스의 메소드여야 한다.) 1234@Scheduled(fixedRateString = \"5\", initialDelay = 3000) private void scheduleTest() { logger.error(\"hello jeong-pro\"); } initialDelay : 대기시간 fixedRateString : 이전 작업이 끝난 시점으로 부터 고정된 시간을 문자열로 설정 (milli seconds 단위) 속성 속성이름 설명 cron 크론 표현식을 지원, “초 분 시 일 월 주 (년)”으로 표현한다. fixedDelay 이전 작업이 끝난 시점으로 부터 고정된 시간을 설정 (milli seconds 단위) fixedDelayString fixedDelay의 value값을 문자열로 설정 fixedRate 이전 작업이 수행되기 시작한 시점으로 부터 고정된 시간을 설정 (milli seconds 단위) fixedRateString fixedRate의 value값을 문자열로 설정 initialDelay 스케줄러에서 메소드가 등록되자마자 수행하는것이 아닌 초기 지연시간을 설정 initialDelayString initialDelay의 value값을 문자열로 설정 zone cron 표현식을 사용햇을 때 사용할 time zone, default = 서버의 time zone cron 표현식 필드명 값의 허용 범위 허용된 특수분자 초 0 ~ 59 , - * / 분 0 ~ 59 , - * / 시 0 ~ 23 , - * / 일 1 ~ 31 , - * / ? L W 월 1 ~ 12 or JAN ~ DEC , - * / 요일 1 ~ 7 or SUN ~ SAT , - * / ? L # 연도 empty or 1970 ~ 2099 , - * / * : 모든값 ? : 특정한 값이 없음 - : 범위 (ex&gt; MON-WED) , : 특별한 값일 때만 동작 / : 시작시간/단위 (ex&gt; 0/5 매 5분) L : 일에서 사용하면 마지막 일, 요일에서는 마지막 요일 (토요일) W : 가장 가까운 평일 (ex&gt; 15W 15일에서 가장 가까운 평일) # : 몇째주의 무슨 요일을 표현, 요일#주 (ex&gt; 4#2 2번째주 수요일 ) fixedDelay vs fixedRate 커스터마이징 ThreadPoolTaskScheduler를 상속받는 클래스를 생성 커스터마이징을 원하는 메소드를 오버라이드 한다. 상기 예제는 fixedRate가 0이면 아무일도 일어나지 않도록 커스터마이징본래는 fixedRate가 0이면 exception 발생 생성한 커스터마이징 클래스를 사용하도록 설정한다. 외부설정으로 주기 설정 yml, properties파일에 정의한 값으로 적용가능하다. 1234@Scheduled(fixedRateString = \"${myscheduler.period}\", initialDelay = 2000) private void scheduleTest() { logger.error(\"hello jeong-pro\"); } 참고 정아마추어 코딩블로그 - @Scheduled 사용법","link":"/2019/10/26/spring/scheduled/"},{"title":"스프링 MVC 동작 원리02 - 스프링 연동, DispatcherServlet","text":"스프링 웹 MVC(inflearn) - 백기선Springframework 웹 서블릿 어플리케이션에 스프링을 사용한다는 의미는 크게 2가지로 나눠서 이야기 할 수 있다. 스프링 IoC 컨테이너를 사용하겠다. 스프링 MVC를 사용하겠다. 스프링 IoC 컨테이너 연동 의존성 추가 spring-webmvc ContextLoaderListener 등록 ApplicationContext를 서블릿 어플리케이션 생명주기에 맞춰서 바인딩해준다. ApplicationContext를 웹어플리케이션에 등록된 서블릿들이 사용할 수 있도록 서블릿 컨텍스트에 등록해준다. 서블릿이 종료될때 제거해준다. 즉, ApplicationContext를 연동해준다.(ApplicationContext는 만들어야한다.) 서블릿에서 IoC 컨테이너를 ServletContext를 통해 꺼내 사용할 수 있다.123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; ApplicationContext 생성 기본적으로 xml을 사용하지만 Java설정파일 사용하겠다. (최근 추세) AppConfig 생성 context class 설정 변경123456789&lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;&lt;/context-param&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;bong.spring.AppConfig&lt;/param-value&gt; /* Appconfig파일위치 */&lt;/context-param&gt; ContextLoaderListener - initWebApplicationContext을 보면 WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE라는 이름으로 ApplicationContext를 setattribute하는것을 볼 수 있다. 등록한 빈 사용하기 servletcontext에서 확인한 이름으로 getattrbute해서 확인할 수 있다. 빈으로 등록한 서비스를 getBean()으로 사용할 수 있다.12345private Object getName() { ApplicationContext applicationContext = (ApplicationContext) getServletContext().getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE); HelloService helloService = applicationContext.getBean(HelloService.class); return helloService.getname();} 지금까지 만들었던 내용을 RootApplicationContext라고 할 수 있다. 다른 서블릿에서도 공용으로 사용될 공용 리소스 web과 상관없는… 스프링 MVC 연동 DispatcherServlet 스프링 MVC의 핵심. Front Controller 역할을 한다. DispatcherServlet 등록 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;bong.spring.WebConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; @Controller로 매핑 할 수 있도록한다. RootApplicationContext와 같이 쓸 수 있다. Root : Service, Repository등.. 공통 사용빈 Dispatcher : Controller등 web 관련 .. 그러나 다음과 같은 설정이 필요하다. 최근에는 DispatcherServlet 하나만 등록해서 모두 사용하는 방법을 주로 사용한다. SpringBoot의 경우 구조가 다르다. ServletContext 안에 스프링이 들어갔다면 스프링부트는 어플리케이션(Java) 안에 톰캣(Servlet컨테이너)가 들어간다. DispatcherServlet동작원리 DispatcherServlet 초기화 다음의 특별한 타입의 빈들을 찾거나, 기본 전략에 해당하는 빈들을 등록한다. HandlerMapping : 핸들러를 찾아주는 인터페이스 HandlerAdapter : 핸들러를 실행하는 인터페이스 HandlerExceptionResolver : 예외처리 ViewResolver : 뷰를 찾아낸다. … DispatcherServlet 동작 순서 요청을 분석한다. (로케일, 테마, 멀티파트 등) (핸들러 맵핑에게 위임하여) 요청을 처리할 핸들러를 찾는다. (등록되어 있는 핸들러 어댑터 중에) 해당 핸들러를 실행할 수 있는 “핸들러 어댑터”를 찾는다. 찾아낸 “핸들러 어댑터”를 사용해서 핸들러의 응답을 처리한다. 핸들러의 리턴값을 보고 어떻게 처리할지 판단한다. 뷰 이름에 해당하는 뷰를 찾아서 모델 데이터를 랜더링한다. @ResponseEntity가 있다면 Converter를 사용해서 응답 본문을 만들고. (부가적으로) 예외가 발생했다면, 예외 처리 핸들러에 요청 처리를 위임한다. 최종적으로 응답을 보낸다. DispatcherServlet의 사용전략은 서블릿 init 할 때 이루어짐으로 최초 한번만 실행된다. ViewResolver등록이라던지.. HandlerMapping RequestMappingHandlerMapping HandlerAdapter RequestMappingHandlerAdapter SimpleController HandlerMapping BeanNameUrlHandlerMapping HandlerAdapter SimpleControllerHandlerAdapter 1234567@org.springframework.stereotype.Controller(&quot;/simple&quot;)public class SimpleController implements Controller { @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { return new ModelAndView(&quot;/WEB-INF/simple.jsp&quot;); }} 커스텀 ViewResolver ViewResolver InternalResourceViewResolver InternalResourceViewResolver Prefix Suffix 예제 이제 뷰이름만 주어도 된다. 주소 및 타입 설정을 생략할 수 있다.","link":"/2019/04/25/spring/spring_web_mvc02/"},{"title":"스프링 MVC 동작 원리03 - 스프링 MVC 구성 요소, 동작원리 정리","text":"스프링 웹 MVC(inflearn) - 백기선Springframework 스프링 MVC 구성 요소 DispatcherSerlvet의 기본 전략 DispatcherServlet.properties를 보면 정의되어있다. MultipartResolver 파일 업로드 요청 처리에 필요한 인터페이스 HttpServletRequest를 MultipartHttpServletRequest로 변환해주어 요청이 담고 있는 File을 꺼낼 수 있는 API 제공. LocaleResolver 클라이언트의 위치(Locale) 정보를 파악하는 인터페이스 기본 전략은 요청의 accept-language를 보고 판단. ThemeResolver 애플리케이션에 설정된 테마를 파악하고 변경할 수 있는 인터페이스 참고: https://memorynotfound.com/spring-mvc-theme-switcher-example/ HandlerMapping 요청을 처리할 핸들러를 찾는 인터페이스 HandlerAdapter HandlerMapping이 찾아낸 “핸들러”를 처리하는 인터페이스 스프링 MVC 확장력의 핵심 HandlerExceptionResolver 요청 처리 중에 발생한 에러 처리하는 인터페이스 RequestToViewNameTranslator 핸들러에서 뷰 이름을 명시적으로 리턴하지 않은 경우, 요청을 기반으로 뷰 이름을 판단하는 인터페이스 ViewResolver 뷰 이름(string)에 해당하는 뷰를 찾아내는 인터페이스 FlashMapManager FlashMap 인스턴스를 가져오고 저장하는 인터페이스 FlashMap은 주로 리다이렉션을 사용할 때 요청 매개변수를 사용하지 않고 데이터를 전달하고 정리할 때 사용한다. redirect:/events 이런식으로 이전 정보들을 가지고 가되, url에 정의하지 않고 리다이렉트할 때 사용됨. 스프링 MVC 동작원리 정리 결국엔 (굉장히 복잡한) 서블릿 = DispatcherServlet DispatcherServlet 초기화 특정 타입에 해당하는 빈을 찾는다. 없으면 기본 전략을 사용한다. (DispatcherServlet.properties) 스프링 부트 사용하지 않는 스프링 MVC 서블릿 컨네이너(ex, 톰캣)에 등록한 웹 애플리케이션(WAR)에 DispatcherServlet을 등록한다. web.xml에 서블릿 등록 또는 WebApplicationInitializer에 자바 코드로 서블릿 등록 (스프링 3.1+, 서블릿 3.0+) 123456789101112public class WebApplication implements WebApplicationInitializer { @Override public void onStartup(ServletContext servletContext) throws ServletException { AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.register(WebConfig.class); context.refresh(); DispatcherServlet dispatcherServlet = new DispatcherServlet(context); ServletRegistration.Dynamic app = servletContext.addServlet(&quot;app&quot;, dispatcherServlet); app.addMapping(&quot;/app/*&quot;); }} 세부 구성 요소는 빈 설정하기 나름. 스프링 부트를 사용하는 스프링 MVC 자바 애플리케이션에 내장 톰캣을 만들고 그 안에 DispatcherServlet을 등록한다. 스프링 부트 자동 설정이 자동으로 해줌. 스프링 부트의 주관에 따라 여러 인터페이스 구현체를 빈으로 등록한다.","link":"/2019/04/30/spring/spring_web_mvc03/"},{"title":"Request 로그 찍기 - CommonsRequestLoggingFilter","text":"SpringAPI LoggingCommonsRequestLggingFilter REST API를 만들고 서버에서 어떤 url로 요청을 하는지 로그를 남기고 싶을 때 사용한다. 사용법 CommonsLoggingFilter 빈등록 12345678910@Beanpublic CommonsRequestLoggingFilter commonsRequestLoggingFilter() { CommonsRequestLoggingFilter filter = new CommonsRequestLoggingFilter(); filter.setIncludeClientInfo(true); filter.setIncludeHeaders(true); filter.setIncludePayload(true); filter.setIncludeQueryString(true); filter.setMaxPayloadLength(1000); return filter;} setIncludeClientInfo(true): 클라이언트 주소와 세션 ID를 로그 메세지에 포함한다. filter.setIncludeHeaders(true) : 헤더정보를 로그에 포함한다. filter.setIncludePayload(true) : request내용을 로그에 포함한다. filter.setIncludeQueryString(true) : 쿼리 문자열을 로그 메세지에 포함한다. filter.setMaxPayloadLength(1000) : 로그의 최대 길이을 설정한다. logger의 debug level을 enable해준다. 1234567891011121314151617181920public class CommonsRequestLoggingFilter extends AbstractRequestLoggingFilter { @Override protected boolean shouldLog(HttpServletRequest request) { return logger.isDebugEnabled(); } /** * Writes a log message before the request is processed. */ @Override protected void beforeRequest(HttpServletRequest request, String message) { logger.debug(message); } /** * Writes a log message after the request is processed. */ @Override protected void afterRequest(HttpServletRequest request, String message) { logger.debug(message); }} SpringBoot를 사용할 경우 아래와 같이 간편한게 Property or yml 파일 수정으로 설정이 가능하다. 1logging.level.org.springframework.web.filter=debug 결과 참고 홍이의 개발 노트 - 스프링에서 웹 또는 API 개발시 요청정보 로깅 방법 https://www.popit.kr/spring%EC%97%90%EC%84%9C%EC%9D%98-api-logging/","link":"/2019/12/23/spring/CommonsRequestLoggingFilter/"},{"title":"스프링 MVC 설정04 - 스프링 MVC 빈 설정","text":"스프링 웹 MVC(inflearn) - 백기선Springframework 스프링 MVC 빈 설정@Configuration을 사용한 자바 설정 파일에 직접 @Bean을 사용해서 등록하기 Dispatcher Servlet의 기본적략을 따른다면 아래와 같다. 추가적인 설정이 있다면 아래와 같이 설정을 추가해준다. 현재는 이러한 방법은 거의 쓰지 않는다. spring mvc에서 제공하는 방법을 사용한다. @EanbleWebMvc 애노테이션 기반 스프링 MVC를 사용할 때 편리한 웹 MVC 기본 설정 @Configuration이 있는 클래스에 @EanbleWebMvc를 설정해준다. @EanbleWebMvc는 DelegatingWebMvcConfiguration을 import해준다. DispatcherServlet의 기본설정을 빈으로 등록해준다. (등록된 빈이 없다면..) 사용 시에는 반드시 servletContext를 설정해주어야한다. DelegatingWebMvcConfiguration에서 servletContext를 많이 참조하고 있기 때문에.. WebMvcConfigurer @EnableWebMvc가 제공하는 빈을 커스터마이징할 수 있는 기능을 제공하는 인터페이스 WebMvcConfigurer를 implements 함으로서 설정이 가능하다. viewresolver를 직접등록하지 않고 다음과 같이 설정 할 수 있다. 스프링 부트의 MVC 설정 스프링 부트의 “주관”이 적용된 자동 설정이 동작한다. JSP 보다 Thymeleaf 선호 JSON 지원 정적 리소스 지원 (+ 웰컴 페이지, 파비콘 등 지원)스프링 MVC 커스터마이징 application.properties @Configuration + Implements WebMvcConfigurer: 스프링 부트의 스프링 MVC 자동설정 + 추가 설정 @Configuration + @EnableWebMvc + Imlements WebMvcConfigurer: 스프링 부트의 스프링 MVC 자동설정 사용하지 않음.","link":"/2019/05/31/spring/spring_web_mvc04/"},{"title":"스프링 MVC 설정05 - 스프링 부트에서 JSP 사용하기","text":"스프링 웹 MVC(inflearn) - 백기선Springframework 스프링 부트에서 JSP 사용하기 제약 사항 JAR 프로젝트로 만들 수 없음, WAR 프로젝트로 만들어야 함 Java -JAR로 실행할 수는 있지만 “실행가능한 JAR 파일”은 지원하지 않음 언더토우(JBoss에서 만든 서블릿 컨테이너)는 JSP를 지원하지 않음 Whitelabel 에러 페이지를 error.jsp로 오버라이딩 할 수 없음 의존성 추가 12345678910&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; WAR로 프로젝트를 생성하면 ServletInitializer클래스가 추가된다. 독립적인 WAR파일로 실행할때는 Application 클래스를 사용하는 것이고, 톰캣 및 서블릿엔진에 배포할때는 ServletInitializer를 사용하는 것이다. 태그선언 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; view suffix 및 prefix 설정 application.properties 12spring.mvc.view.prefix=/WEB-INF/jspspring.mvc.view.suffix=.jsp mvn package war파일로 생성된다. java -jar 명령어로 실행이 가능하다. 독립적으로 실행가능한 어플리케이션 mvnw package스프링 부트 프로젝트를 만들면 mvnw라는 커맨드가 생성되고,로컬에 메이븐이 설치 안되어있어도 패키징 할 수 있다. WAR 파일 배포하기java -jar를 사용해서 실행하기 SpringApplication.run 사용하기 (java -jar 실행한것과 같다.) 서블릿 컨테이너에 배포하기 SpringBootServletInitializer (WebApplicationInitializer) 사용하기 톰캣 설치 톰캣 홈페이지에서 톰캣을 다운받는다.(현재 최신버전 9버전) 압출을 풀고 해당위치에서 권한을 준다. bin 폴더를 찾아들어가서 아래 명령어를 사용하여 .sh파일을 실행가능한 파일로 만들어준다.1chmod +x *.sh 톰캣 설정 실행 설정 톰캣 추가 톰캣 폴더 경로 지정 및 아티팩트 지정 (war는 압출파일 , war exploded는 압축을 푼 것)","link":"/2019/05/31/spring/spring_web_mvc05/"},{"title":"Spring, Maven, DI, 객체주입, AOP (KOSTA)","text":"KOSTA DAY55Springframework Spring 오픈소스 프레임 워크 엔터프라이즈 어플리케이션 개발의 복잡성을 줄여주기 위한 목적 EJB 사용으로 수행되었던 모든 기능을 일반 POJO(Plain Old Java Object) 를 사용해서 가능하게 함. 장점 경량 컨테이너 DI ( Dependency Injection) 지원 DI프로그래밍에서 구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일 등을 통해 정의되게 하는 디자인 패턴 중의 하나이다. AOP(AspectOrientedProgramming)지원 AOP관점 지향 프로그래밍으로 “기능을 핵심 비즈니스 기능과 공통 기능으로 ‘구분’하고, 공통 기능을 개발자의 코드 밖에서 필요한 시점에 적용하는 프로그래밍 방법 POJO(PlainOldJavaObject)지원 POJO기존에 만들어진 자바 객체 JDBC를 위한 다양한 API 지원 Transaction 처리를 위한 일관된 방법제공 다양한 API와의 연동 지원 Maven 자바용 프로젝트 관리 툴 협업 작업시 , 라이브러리 버전이 다르거나, 유무 때문에 에러발생을 줄일 수 있다. 사용법 poem.xml 생성 Maven Repository 사이트에서 필요한 라이브러리를 검색하여 값을 poem.xml에 넣어주어야 한다. 메이븐 문제 발생시, 빨간색 느낌표 발생해결방안툴을 종료 → 유저폴더에서 숨김파일 확인(Mac : cmd + shift + .) → m2 → Repository 삭제 후 툴 재실행 DI(Dependency Injection) 의존성주입 Spring에서 DI를 지원 Spring Container가 DI조립기를 제공 스프링 설정파일을 통하여 객체간의 의존관계를 설정한다. Spring Container가 제공하는 api를 이용해 객체를 사용한다. 설정 파일은 xml or java 두가지 종류로 설정이 가능하다. Spring Container 객체를 관리하는 컨테이너 위의 interface들을 구현한다. Resource 구현 클래스 Resource interface : 다양한 종류의 자원을 동일한 방식으로 통일하여 표현할 수 있게 한다. XmlBeanFactory는 객체 생성시 설정 파일의 위치를 알려줘야한다.(Resource를 이용) 객체 및 DI 설정크게 3가지 방법으로 나눌 수 있다. xml 사용하여 객체들을 각각 주입 및 DI 설정 xml사용하여 패키지 단위로 객체들을 주입 후, annotation 사용하여 DI설정 java 클래스를 사용하여 메소드와 annotation을 사용하여 객체주입 및 DI 설정 주입된 객체들은 모두 Spring Container에 담기며, 호출을 위해서는 SpringContainer에서 호출한다. xml 사용하여 객체들을 각각 주입 및 DI 설정 service객체를 implements하는 객체를 생성한다. Dao를 생성자를 통해 호출 해당 클래스 안에서는 new를 통한 Dao객체 생성을 하지않는다. xml상에서 연결시킬 예정 Spring Bean Configuration File 생성(xml파일) 각각의 객체들을 bean으로 주입 id :주입받을곳에서호출할이름설정(‘/’ 값으로못가짐) class : 주입할 객체의 클래스 oracleDao라는 객체를 SpringContainer에 담도록하고 bean태그에 명시되있는 클래스에 dao를 사용할 수 있도록 주입한다. (DI설정)constructor 또는 property를 사용하여 설정한다. value or ref 같은 속성을 이용한다. (객체 = ref , 값 = value) Resource 객체를 통해 xml 파일을 받아온 후, BeanFactory를 통해 Bean객체를 받아 Spring Container생성. getBean(“*”) 의 * 은 DI설정시 id 값과 동일하도록 설정해야 한다. xml사용하여 패키지 단위로 객체들을 주입 후, annotation 사용하여 DI설정 xml 작성 시, Namespaces에서 context를 활성화 시킨다. context: annotation-config 설정한다.(어노테이션이 달린 객체를 담는다.) context:component-scan base-package=”*”해당 패키지 영역을 지정한다. DI를 설정해주는 것은 앞서 1번 방식과 같으나, 직접 constructor 나 property를 통해 지정해주지 않는다. 담고싶은 Bean객체에 Repository 어노테이션을 작성한다. 주입할 부분에 Inject 또는 Autowired 어노테이션을 작성@ Inject → 선언부 상단@Autowired → set메소드 상단 Inject 어노테이션 활용 시, 라이브러리 추가 필요 ApplicationContext를 통해 정보를 받아서 Spring Container를 생성 getBean(“*”) 의 * 은 DI설정시 id 값과 동일하도록 설정해야 한다. java 클래스를 사용하여 메소드와 annotation을 사용하여 객체주입 및 DI 설정 클래스에 Configuration 어노테이션을 작성한다. xml파일이 아닌 자바 파일로 생성 해당 객체들에 Bean어노테이션을 작성한다. 메소드이름이 xml방식의 id값 역할을 한다. 주입할 부분에 Inject 또는 Autowired 어노테이션을 작성@ Inject → 선언부 상단@Autowired → set메소드 상단 Inject 어노테이션 활용 시, 라이브러리 추가 필요 ApplicationContext객체를 통해 Spring Container 생성 getBean(“*”)을 통해 객체를 호출한다. (*값은 메소드 이름) AOP 핵심 관심사항(core concern)과 공통 관심사항 (cross-cutting concern) 기존 OOP 에서는 공통관심사항을 여러 모듈에서 적용하는데 중복된 코드를 양산과 같은 한계가 존재 → 이를 극복하기 위해 AOP 가 등장 Aspect Oriented Programming은 문제를 해결 하기 위한 핵심 관심사항과 전체에 적용되는 공통 관심사항을 기준으로 프로그래밍함으로써 공통 모듈을 손쉽게 적용할 수 있게 해준다. 반복되는 공통관심사항 코드들을 줄일 수 잇다. Spring AOP 용어 Aspect : 여러 객체에서 공통으로 적용되는 공통 관심사항(ex:트랜 잭션, 로깅, 보안) JoinPoint : Aspect가 적용 될 수 있는 지점(ex:메소드, 필드) Pointcut : 공통관심사항이 적용될 Joinpoint→ pointcut에 의해 joinpoint가 결정된다. Advice : 어느 시점(ex: 메소드 수행 전/후, 예외발생 후 등)에 어 떤 공통 관심기능(Aspect)을 적용할지 정의한 것. Weaving : 어떤 Advice를 어떤 Pointcut(핵심사항)에 적용시킬 것 인지에 대한 설정 (Advisor) example)남자들 오늘 술먹자.Aspect = 술먹자joinpoint = 각각 남자pointcut = 남자들advice = 오늘 AOP 사용법 라이브러리 추가Maven → Spring aspect 추가 공통관심사항에 대한 메소드 작성후, try catch를 통해 Object 객체를 통해 핵심관심사항 로직을 호출한다. 호출 뒤 실행문에 대하여는 finally 부분에 넣어준다. Bean태그를 통해 공통관심사항 객체 지정 &lt;aop:pointcut expression=”execution(pointcut지정)” id =”포인트컷이름지정”&gt; &lt;aop : aspect id=”이름지정” ref=”공통관심사항 해당객체 이름”&gt; &lt;aop:around method=”공통관심사항객체실행메소드이름” pointcut-ref=”포인트컷이름”&gt; 두가지 이상의 xml 사용시 스트링 배열에 담은후, ApplicationContext객체를 통해 Spring Container 생성 해당메소드 실행시, 공통관심사항객체의 메소드가 실행된다. 결과","link":"/2019/01/24/spring/kosta_spring01/"},{"title":"개발환경 세팅, Junit 테스트, OracleDB 연동, mybaits연동, log4jdbc, MVC Controller, 파일업/다운로드 (KOSTA)","text":"KOSTA DAY58Springframework 개발환경 설정(Spring MVC)해당 포스팅은 Eclipse를 통해 이루어진다. 추후에 IntelliJ 로 변경할 예정이다. 프로젝트생성 Spring Legacy Project를 생성한다. Spirng MVC Project 선택 사용 될 Controller 피키지명 입력( 자동생성) pom.xml에 Java 및 Spring, Maven의 버전을 변경한다. maven update Lombok 설치 및 라이브러리 추가 Lombok이란?Java에서 자주 사용하는 생성자, setter/getter, toString()을 자동으로 생성해 주는 라이브러리이다. Lombok홈페이지에서 다운로드 한다. Lombok을 설치한다. JUnit 테스트 xUnit이란?자바만 단위 테스팅 프레임 워크인 JUnit만 있는게 아니다. 다른 언어도 단위 테스트를 위한 프레임워크가 존재하며 보통 이름을 xUnit이라 칭한다.ex) JUnit → java, CUnit → C ,CppUnit →c++ JUnit assert 관련 메소드JUnit을 활용하여 설정이 잘 되었는지 확인해보자. pom.xml에 라이브러리 추가(junit 4.12버전) root-context.xml 파일은 Spring과 관련된 설정을 작성하는 곳 ‘어노테이션을 통해 sample 패키지를 스캔하여 객체를 만들겠다.’를 의미한다. 테스트 객체 추가 @Component 를 사용하여 Bean객체로 등록한다. @Data를 통해 Lombok을 사용 (@Setter 의존성 주입) src/test/java에 테스트파일 생성 @RunWith : JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 어노테이션이다. SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.→JUnit에 내장된 Runner대신 그 클래스를 실행 @ContextConfiguration : 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일위치를 지정 Oracle DB 연동 Build Path를 통해 Ojdbc 라이브러리를 추가한다.(Maven으로 추가 시, 에러발생함으로 로컬환경에서 추가하도록 하자.) pom.xml에 spring-jdbc 라이브러리 추가 src/test/java에 테스트 파일을 생성한다. junit test 실행 결과 정상으로 나타난다. mybatis연동spring에서는 mybatis를 쉽게 연동하기위해 라이브러리를 지원한다. pom.xml에 해당 라이브러리들을 추가한다.HikariCP/spring-tx / mybatis / mybatis-spring root-context.xml 설정 hikariCP라이브러리를 사용하여 상기와 같이 Connection Pool을 한다.(상기예제의 diriverClassName, jdbcUrl 은 추후 log4jdbc설정을 위해 변경된 값이다. 주석처리한 부분이 원래 값) dataSource 객체 생성 (ref = hikariConfig) sqlSessionFactory 객체 생성(ref = dataSource) mybatis-sping:scan을 사용하여 mapper패키지의 xml파일 및 인터페이스 파일을 검색하고 사용한다. 먼저 DB와 연동되는지 확인해보자. @Setter 를 사용하여 DataSource 객체 및 SqlsessionFactory객체 생성 DB를 연결하고 잘 연결되었는지 확인하기 위해 session과 con 을 출력한다. try 사용 시, 괄호안의 코드를 작성하면 try가 끝날때 내용을 자동으로 close 해준다. DB와 연동이 잘된다면 mybatis설정이 잘되었는지 확인해보자. mybatis로 연동될 인터페이스 생성 src/main/resources 에 인터페이스의 경로와 같도록 폴더를 생성하고 그안에 xml파일을 생성한다. 이전에 root-cotntex.xml에서 mybatis-spring : scan 경로와 같도록 해야한다.(자동으로 scan하기 위해서) 테스트 파일 작성 및 실행 log4jdbc-log4j2 설정sql 관련 log를 보다 가시성이 높게 표현되도록 변경해주는 라이브러리이다. pom.xml에 해당라이브러리를 추가한다. src/main/resources에 log4jdbc2.properties를 추가한다. root-context.xml 의 Connection Pool 세팅의 value값을 변경한다.(HikariCP 라이브러리 사용) 다시 테스트파일을 실행해보면 다음과 같은 결과가 나온다. MVC ControllerSpring-MVC 패턴에서의 Controller의 역할을 알아보자. HttpServletRequest, HttpServletResponse를 거의 사용할 필요 없이 구현 가능 다양한 타입의 파라미터 처리, 리턴 타입이 가능 GET, POST 방식에 대한 어노테이션 처리 가능 상속/인터페이스 방식 대신 어노테이션 만으로도 설정 가능 컨트롤러를 사용하여 톰캣서버를 실행해보자. pom.xml의 버전변경 (Spring legacy 로 생성된 lib들의 버전이 낮음)spring → 5.0.7 / javax.servlet-api → 3.1.0 /maven-compiler-plugin → 2.5.1 웹프로젝트 가능한 절대경로를 이용하는 구조를 사용하는것이 바람직함으로, Tomcat의 Module메뉴를 이용하여 ‘/’ 경로로 프로젝트가 실행될 수 있도록 처리한다. servlet-context.xml 에 해당 패키지안을 찾아내도록 설정한다. @Controller 를 사용하여 컨트롤러를 찾아낼 수 있도록한다. RequestMapping(“/sample/*”) 주소 /sample/로 들어올시, 해당 컨드롤러에 매핑된다. RequestMapping 과 GetMapping 을 사용하여 각각 mapping 하였다.GetMapping get방식만 data를 받을 수 있다.RequestMapping 은 get/post를 모두 지원하며 두방식 모두 지원시 배열로 처리할 수 있다. void 함수로 return 값이 없으면 매핑 주소값을 return 한다. 파라미터 수집spring에서는 파라미터가 자동으로 수집되는 기능을 지원한다.즉, request.getParameter()를 이용하는 불편함이 없다. 예제를 통해 살펴보자. @Data 어노테테이션을 찾아 파라미터값으로 가진다. 파라미터 형변환파라미터수집을 다른용어로는 binding이라고 한다. 자동으로 변환이 가능한 data들은 변환을 하지만, 변환처리가 필요한 경우도 있다.예를들어 문자를 Date 타입으로 변환하기 위해서는 다음과같은 과정이 필요하다. InitBinder를 사용하여 형변환을 할 수 있다. DateTimeFormat 으로 대체 가능하다.(Chef 클래스 주석부분) Json 변환@ResponseBody를 사용하여 객체를 Json 타입으로 변환하여 출력이 가능하다. pom.xml에 jackson 라이브러리 추가 @ResponseBody 를 사용하여 Json객체로 출력하였다. ResponseEntity 타입 원하는 헤더 정보 및 데이터를 전달 할 수 있다. HttpHeaders 객체를 전달해 원하는 헤더 메세지로 가공이 가능하다.예제를 통해 살펴보자. 컨트롤러에서 리턴값을 ResponseEntity값으로 선언하였다.(데이터 타입이다. 어노테이션이 아님) 쌍따옴표를 사용하기 위해 \\ 사용 결과값을 보면 알 수 있듯이,HttpStatus.OK → status 200(정상)header → 결과페이지의 헤더값 (Json타입) 라는 상태 코드를 전송한다. 파일업/다운로드파일업로드파일업로드 방법은 여러가지가 있는데 Servlet3.0이하버전에서 일반적으로 사용했던 가장 일반적인 commons-fileupload 방법에대해 알아보자. pom.xml에 commons-fileupload 라이브러리를 추가한다. servlet-context.xml 아래와 같이 설정한다.maxUploadSize : Request로 전달될 수 있는 최대의 크기maxUploadSizePerFile : 하나의 파일 최대크기maxlnMemorySize : 메모리상에서 유지하는 최대의 크기uploadTempDir : 업로드 파일 경로(‘file:/’로 시작한 이유는 절대경로를 이용하려면 URI형태로 제공해야되기 때문에) defaultEncoding는 한글처리를 해준다. Controller를 통해서 views/sample/exUpload.jsp 로 간다. exUpload.jsp에서 파일을 올릴수 있는 input태그 작성 (form태그의 속성들 주의) form 이 post방식으로 컨트롤러로 오기때문에 @PostMapping 사용한다. 값이 여러개임으로 ArrayList사용 타입은 MultipartFile이며 변수명은 input태그의 name값으로 한다. foreach(file-&gt;{});를 사용하여 log 출력","link":"/2019/01/29/spring/kosta_spring04/"},{"title":"스프링 부트 시작하기01","text":"스프릥 부트 개념과 활용01(inflearn) - 백기선Spring boot 백기선 님의 강의 중 세 번째로 수강하게 된 ‘스프링 부트 개념과 활용’!!사실 이 강의를 듣고 스프링 부트를 사용하기 위해서 앞선 두 강의를 수강했다고 할 수 있습니다.스프링 부트에 대해서 기초부터 탄탄히 다져 나갑시다.해당 강좌는 스프링 부트의 원리, 활용(예제), 운영에 대해서 알려주고 있습니다.😀 스프링 부트 제품수준의 스프링 기반 어플리케이션을 만들 때, 빠르고 쉽게 만들 수 있도록 도와준다. 기본적인 설정을 지원한다.(opinionated view) 스프링 플랫폼 third-party 즉, 제 3의 라이브러리 설정 지원 (ex)톰캣 자바 8버전 이상 사용이 요구된다. 목적 모든 스프링 개발에 있어 더 빠르고 폭넓은 사용성을 제공한다. 기본 설정을 convention으로 지원한다.또한 그 설정을 필요에 따라서 의도에 맞도록 쉽고 빠르게 변경할 수 있다. 비지니스 로직을 구현하느 기능뿐만 아니라, non-functional한 기능도 제공해준다. xml설정을 하지 않는다. 코드 제너레이션도 하지 않는다. 스프링 부트 시작하기프로젝트 생성 프로젝트를 생성한다. (메이븐/인텔리제이 사용) GroupId는 보통 패키지명 생성위치 설정 spring boot 레퍼런스 문서를 보고 메이븐 파일을 설정한다. maven간에 프로젝트 계층구조를 만들수 있다.부모 프로젝트로 spring-boot-starter-parent로 설정해준다. spring-boot-starter-web을 의존성 추가한다. 빌드 플러그인에 spring-boot-maven을 추가한다. 패키지 및 클래스 파일 만든 후, 메인 실행 메소드 생성 실행 시, 스프링 부트 내장 톰캣이 실행된다. (기본 포트 : 8080) 여러가지 스프링 부트 생성방법 인텔리제이 Spring Initializr start.spring.io 사용 스프링 부트 구조 이븐 기본 프로젝트 구조와 동일 소스 코드 (src\\main\\java) 소스 리소스 (src\\main\\resource) 테스트 코드 (src\\test\\java) 테스트 리소스 (src\\test\\resource) resource의 파일을 참조할 시, ‘classpath:’로 참조할 수 있다.(‘classpath:text.txt’일 경우, resource 디렉토리 바로 아래 text.txt가 있다.) 메인 애플리케이션 위치 기본패키지 @SpringBootApplication이 @ComponentScan을 포함하여 해당 패키지 및 하위 패키지들을 스캔한다. 만약 java 하위에 패키지를 생성하지 않고 만들게 되면 모든 패키지를 스캔하기 때문에 좋지 않다. @Component스캔 참고","link":"/2019/03/28/spring/springboot01/"},{"title":"스프링 부트 원리02 - 의존성 관리","text":"스프릥 부트 개념과 활용02(inflearn) - 백기선Spring boot 의존성 관리 이해 pom.xml에서 spring-boot-parent로 들어가본다. spring-boot-parent도 spring-boot-dependencies라는 parent계층을 가지고 있다. spring-boot-dependencies에는 스프링과 호환되는 버전들이 설정되어있다. 또한, dependencyManagement에 각 버전에 해당하는 의존성이 다 정의되어있다. 정의된 의존성을 사용하게되면, 버전에 대한 정보는 없이 사용할 수 있다.dependencyManagement에 정의된 버전을 가져온다. starter 기반으로 추가하면 된다. 장점 관리해야 할 의존성이 줄어든다. 제3의 라이브러리 사용 시, 스프링 버전과의 호환성 확인작업 줄어든다. dependencyManagement에 있더라도 버전을 명시하면, 명시 된 버전을 가져온다. 부모 pom 없이 스프링부트 사용하기 spring-boot-starter의 부모로 spring-boot-parent를 넣어줘도 의존성 관리를 받을 수 있다. 그마저도 원하지 않는다면 spring-boot-depencies를 설정 해주어야한다.(레퍼런스 문서를 참고하자.) 그러나 parent pom은 의존성뿐만 아니라 인코딩,자바버전등 여러 설정을 포함하기 때문에 parent를 사용하는것을 추천한다. 의존성 관리 응용스프링 의존성 추가 pom.xml 안에 에 추가해준다. 메이븐 의존성 검색 : https://mvnrepository.com 스프링 부트 버전관리 지원 의존성 : 버전정보를 기입하지 않아도 된다.(인텔리제이에서는 좌측에 아이콘이 생성되며, 클릭하면 해당 dependencyManagement로 이됭된다.) 스프링 부트 버전관리 지원하지 않는 의존성 : 버전정보도 같이 기입 기존 의존성 버전 변경하기 spring-boot-dependencies 또는 parent properties 값 복사 pom.xml에 properties를 직접 재정의한다.","link":"/2019/03/28/spring/springboot02/"},{"title":"스프링 MVC 설정06 - 포매터 추가하기, 도메인 클래스 컨버터 자동 등록","text":"스프링 웹 MVC(inflearn) - 백기선Springframework 포매터 추가하기 Reference 문서 Formatter Formatter를 implements 하는 클래스를 생성한다. Printer, Parser를 구현한다. Printer: 해당 객체를 (Locale 정보를 참고하여) 문자열로 어떻게 출력할 것인가 Parser: 어떤 문자열을 (Locale 정보를 참고하여) 객체로 어떻게 변환할 것인가 Formatter를 추가하는 방법 WebMvcConfigurer의 addFormatters(FormatterRegistry) 메소드 정의 해당 포매터를 빈으로 등록(스프링 부트 사용시에만 가능하다.) 도메인 클래스 컨버터 자동 등록 스프링 데이터 JPA는 스프링 MVC용 도메인 클래스 컨버터를 제공합니다. 도메인 클래스 컨버터 스프링 데이터 JPA가 제공하는 Repository를 사용해서 ID에 해당하는 엔티티를 읽어옵니다. findById()를 통해서 도메인 클래스로 컨버트해서 가져온다. 테스트 코드","link":"/2019/06/10/spring/spring_web_mvc06/"},{"title":"스프링 부트 원리04 - 내장 웹 서버","text":"스프릥 부트 개념과 활용04(inflearn) - 백기선Spring boot 내장 웹 서버 @SpringBootApplication 쓰지 않고 톰캣 띄우기 부트는 서버가 아니다. 톰캣객체생성 포트설정 톰캣에 컨텍스트 추가 서블릿 만들기 톰캣에 서블릿 추가 컨텍스트에 서블릿 맵핑 톰캣실행및대기 이 모든 과정을 보다 상세히 또 유연하게 설정하고 실행해주는게 바로 스프링 부트의 자동 설정. ServletWebServerFactoryAutoConfiguration (서블릿 웹 서버 생성) TomcatServletWebServerFactoryCustomizer (서버 커스터마이징) DispatcherServletAutoConfiguration 서블릿 만들고 등록한다. DispatcherServlet이 따로 있는 이유 서블릿 컨테이너는 변경될 수 있느나, 서블릿은 변경되지 않기때문에 컨테이너와 서버 포트 톰캣이 기본 컨테이너로 설정되어있다. 다른 서블릿 컨테이너로 변경 톰캣 의존성을 제외한다. 원하는 서블릿 컨네이너 설정 웹 서버 사용하지 않기 코드로 타입변경 application.properties로 타입변경 포트 변경 application.properties에 포트번호 정의1server.port=7070 랜덤포트 사용가능한 포트를 랜덤으로 사용한다.1server.port=0 ApplicationListner&lt;ServletWebServerInitializedEvent> 웹서버가 초기화가되면(생성되면) 이벤트 리스터가 콜백된다. 해당 방법으로 포트 확인이 가능하다. 응답 압축해서 보내기 application.properties에 아래왕 같이 입력 시, 응답을 압축해서 보낸다. 1server.compression.enabled=true 기본적으로 압축해도 좋은 타입만 압축해서 보내준다. text/html text/xml text/plain text/css text/javascript application/javascript application/json application/xml HTTPS와 HTTP2 HTTPS 설정하기 키스토어 만들기 줄바꿈없이 아래내용 입력한다.(터미널) 1234567keytool -genkey -alias spring -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -validity 4000 genkey : key를 생성한다. alias : 별칭 storetype : 서블릿 컨테이너마다 지원 티압이 다르다. 주요키타입 PKCS12 JKS (JavaKeyStore) application.properties 설정 12345server.ssl.key-store: keystore.p12/* keysotre의 경로를 classpath에 넣은경우, classpath:를 앞에 붙여준다.*/server.ssl.key-store-password: 비밀번호server.ssl.keyStoreType: PKCS12server.ssl.keyAlias: spring HTTP로 요청 시, 실패 HTTPS로 요청 시, 브라우저가 해당 인증서의 펍키를 모르는 상태일때, 위와같은 화면이 나타난다. 공인된 인증서를 사용 시, 대부분의 브라우저가 펍키를 알기때문에 정상적인 화면이 나타난다. 커넥터가 하나이기때문에 HTTP를 받을 커넥터가 없다. HTTP 커넥터는 코딩으로 설정하기 123456789101112@Bean public ServletWebServerFactory servletContainer(){ TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory(); tomcat.addAdditionalTomcatConnectors(createStandardConnector()); return tomcat; } private Connector createStandardConnector() { Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;); connector.setPort(8080); return connector; } https, http 포트번호를 달리 설정한 후 테스트 결과, 둘다 정상으로 나온다.이미지 HTTP2 활성화 application.properties에 다음설정을 추가한다. 1server.http2.enabled=true 그러나 컨테이너 마다, 전부 다르다. undertow HTTPS만 설정되어있으면 추가 설정이 필요없다. Tomcat 8.5버전 이하는 복잡한 설정이 필요 (비추천) 톰캐9 이상 과 JDK9 이상 시, 설정 필요없다. 차리리 버전을 업그레이드 하는것을 추천한다. 참고 강의 : 생활코딩 - HTTPS와 SSL 인증서","link":"/2019/04/02/spring/springboot04/"},{"title":"스프링 부트 원리03 - 자동 설정","text":"스프릥 부트 개념과 활용03(inflearn) - 백기선Spring boot 자동 설정 이해 @SpringBootApplication는 아래와 같이 구성되어있다. @Configuration @ComponentScan @EnableAutoConfiguration @EnableAutoConfiguration (@SpringBootApplication 안에 숨어 있음) 빈은사실두단계로나눠서읽힘 1단계: @ComponentScan 2단계: @EnableAutoConfiguration @ComponentScan @Component라는 어노테이션을 가진 클래스를 빈으로 등 @Configuration @Repository @Service @Controller @RestController- @EnableAutoConfiguration spring.factories : 스프링부트 기본 설정들이 정의되어있다. org.springframework.boot.autoconfigure.EnableAutoConfigu ration 모두 @Configuration이 붙은 설정파일이다. @Configuration @ConditionalOnXxxYyyZzz(조건에 따라 빈으로 등록된다.) 자동 설정 만들기 Starter와 Autoconfigure 자동설정 프로젝트 네이밍 패턴 Xxx-Spring-Boot-Autoconfigure : 자동 설정 Xxx-Spring-Boot-Starter : 필요한 의존성 정의 그냥 하나로 만들고 싶을 때는? Xxx-Spring-Boot-Starter 구현방법 의존성 추가 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; @Configuration 파일 작성 Holoman이라는 객체가 있다고 가정한다.(name, howlong 필드값 가짐) src/main/resource/META-INF에 spring.factories 파일 만들기 spring.factories 안에 자동 설정 파일 추가 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ Configuration 클래스 파일 위치 정의 mvn install 다른 메이븐 프로젝트에서도 사용할 수 있도록 로컬 메이븐 프로젝트에 설치한다. 사용 시에는 아래의 내용을 사용한다. 다른 메이븐 프로젝트에서 설치한 의존성을 추가하고 사용한다. 문제점 ComponentScan이 먼저 빈으로 등록하고 autoConfiguration으로 빈으로 등록한다.따라서, 따로 빈으로 Holoman을 등록 시, 오류가 발생하거나, 덮어써진다. 자동 설정 만들기 @ConfigurationProperties 위의 문제점을 해결할 수 있다. 덮어쓰기 방지하기 @ConditionalOnMissingBean 해당 타입의 빈이 없으면 빈으로 등록한다. 빈 재정의 수고 덜기 빈으로 매번 등록(재정의)하는 수고를 덜어준다. 프로퍼티의 정의한 값으로 빈을 등록한다. (설정 프로젝트에서..) @ConfigurationProperties(“properties에서 쓸 이름”) 위의 네모박스를 클릭하면 자동완성을 위한 의존성 추가에 대한 정보가 나온다. 의존성을 추가한다. @EnableConfigurationProperties(@ConfigurationProperties를 사용한 클래) 프로퍼티 키값 자동 완성","link":"/2019/04/01/spring/springboot03/"},{"title":"스프링 부트 활용06 - SpringApplication","text":"스프릥 부트 개념과 활용06(inflearn) - 백기선Spring boot SpringApplication로그 기본 로그 레벨 INFO debug 레벨로 변경 VM options : -Ddebug Program arguments : - -debug 변경 후 debug레벨로 로그가 찍힌다. 어떠한 자동설정이 적용됬는지 어떠한 자동설정이 왜 적용되지 않았는지 FailureAnalyzer 어플리케이션 에러가 발생 시, 보다 가시적으로 보이도록 해준다. 직접 등록도 가능하다. 거의 만질일이 없다. 배너 resources에 배너 설정파일을 만든다.(banner.txt | gif | jpg | png) banner파일은 resources 바로 아래 위치해야한다. classpath 또는 spring.banner.location을 사용해서 다른 위치의 배너 파일을 사용할 수 있다. ${spring-boot.version} 등의 변수를 사용할 수 있다. 일부 변수들은 MANIFEST파일이 있어야 사용할 수 있다. Banner 클래스 구현하고 SpringApplication.setBanner()로 설정 가능. txt(승) vs 코딩 배너끄는방법 Builder 패턴 SpringApplicationBuilder로 빌더 패턴 사용 가능 ApplicationEvent 등 ApplicationContext를 만들기 전에 사용하는 리스너는 @Bean으로 등록할 수 없다. ex) ApplicationStartingEventApplication이 시작할 때. 즉, ApplicationContext가 만들어지기 전 이런 경우 직접 해주어야한다. (addListener 등) Bean으로 등록이되는 리스너는 Bean등록만 해주면 된다. ApplicationStartedListenr로 변경 WebApplicationType 설정 기본적으로 서블릿으로 동작 (Spring WebMVC가 들어있다면) 서블릿이 있으면 무조건 서블릿 동작 서블릿이 없고 WebFlux가 있다면 REACTIVE none 웹 어플리케이션 동작안함 애플리케이션 arguments 사용하기 Application Arguments를 빈으로 등록해 주니까 가져다 쓸 수 있다. 애플리케이션 실행한 뒤 뭔가 실행하고 싶을 때 ApplicationRunner (추천) 또는 CommandLineRunner Program arguments는 사용가능하나 JVM options는 무시한다. 순서 지정 가능 @Order (숫자 낮은게 우선)","link":"/2019/04/03/spring/springboot06/"},{"title":"스프링 부트 활용07 - 외부설정","text":"스프릥 부트 개념과 활용07(inflearn) - 백기선Spring boot 외부 설정사용할 수 있는 외부 설정 properties 스프링 부트가 애플리케이션을 구동할 때, 자동으로 로딩 key=value로 정의 애플리케이션에서 참조해서 사용할 수 있다. YAML 환경변수 커맨드 라인 아규먼트 프로퍼티 우선 순위 유저 홈 디렉토리에 있는 spring-boot-dev-tools.properties 테스트에 있는 @TestPropertySource 파일로도 정의 가능하다. @SpringBootTest 애노테이션의 properties 애트리뷰트 커맨드 라인 아규먼트 1java -jar target/jar_name --bong.name=bong SPRING_APPLICATION_JSON (환경 변수 또는 시스템 프로티) 에 들어있는 프로퍼티 ServletConfig 파라미터 ServletContext 파라미터 java:comp/env JNDI 애트리뷰트 System.getProperties() 자바 시스템 프로퍼티 OS 환경 변수 RandomValuePropertySource JAR 밖에 있는 특정 프로파일용 application properties JAR 안에 있는 특정 프로파일용 application properties JAR 밖에 있는 application properties JAR 안에 있는 application properties test resources가 더 늦게 빌드되어 덮어씌어진다. main properties에 있던 속성이 test에 없다면 에러가 발생한다. @PropertySource 기본 프로퍼티 (SpringApplication.setDefaultProperties) application.properties 우선 순위 높은게 낮은걸 덮어 씁니다. file:./config/ file:./ classpath:/config/ classpath:/ 단, application.properties는 프로퍼티 우선순위 14,15이기 때문에 상위 우선순위가 있을 시, 적용되지 않는다. 예제 2순위, 4순위에 해당하는 위치에 application.properties를 만들고 각각 다른값을 정의한다. 2순위의 application.properties가 적용된다. 랜덤값 설정하기 ${random.*} ${random.int(1,100)} 1~ 100까지중 랜덤 공백문자 주의(없어야 한다.) 플레이스 홀더 name = keesunfullName = ${name} baik 타입-세이프 프로퍼티 @ConfigurationProperties 여러 프로퍼티를 묶어서 읽어올 수 있음 빈으로등록해서다른빈에주입할수있음 @EnableConfigurationProperties 이렇게 설정을 빈으로 등록해야 하지만 기본적으로 되어있기 때문에 빈으로 등록만 해주면 된다. @Component @Bean 예제다음과 같은 properties값이 있을 때 properties값에 맞추어 필드값 및 getter, setter를 생성한다. @ConfigurationPropertiess(“properties_name”) 필요한 의존성 설정이 안되어 있어 의존성 추가가 필요하다.12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 앞서 설명했듯이 @EnableConfigurationProperies 자동으로 설정되기 때문에 빈으로 등록하여 사용한다. @Autowired로 빈을 주입받아 사용한다. 융통성 있는 바인딩 대소문자, -, _를 융통성 있게 바인딩한다. context-path (케밥) context_path (언드스코어) contextPath (캐멀) CONTEXTPATH 프로퍼티 타입 컨버전 ConversionService통해서 타입 Conversion이 일어난다. 참고 : 데이터바인딩 @DurationUnit Duration객체로 타입 Conversion해준다. 따로 지정하지 않으면 30 지정하면 지정한값 해당 어노테이션을 쓰지않아도 아래와 같은 suffix를 잘쓰면 자동으로 타입 변한을 해준다. 프로퍼티 값 검증 @Validated JSR-303 (@NotNull, …) @Value 어노테이션을 사용하는것은 SpEL 을 사용할 수 있지만… 위에 있는 기능들은 전부 사용 불가 따라서 properties값을 사용할 때는 위와같이 사용하는 것을 추천","link":"/2019/04/05/spring/springboot07/"},{"title":"스프링 부트 활용08 - 프로파일","text":"스프릥 부트 개념과 활용08(inflearn) - 백기선Spring boot 프로파일참고 : IoC컨테이너와 빈 - profile @Profile 애노테이션은 어디에? @Configuration @Component @Bean(메소드) 어떤 프로파일을 활성화 할 것인가? spring.profiles.active 커맨드라인 arguments가 우선순위가 높다. 어떤 프로파일을 추가할 것인가? spring.profiles.include 프로파일용 프로퍼티 application-{profile}.properties 프로파일용 프로퍼티 파일이 기본적으로 application.properties보다 우선순위가 높다.","link":"/2019/04/08/spring/springboot08/"},{"title":"스프링 부트 원리05 - JAR","text":"스프릥 부트 개념과 활용05(inflearn) - 백기선Spring boot 독립적으로 실행 가능한 JAR mvn package를 하면 실행 가능한 ​JAR 파일 “하나가”​ 생성 됨. mvn clean : target아래 파일들 삭제 mvn package -DskipTests : test제외하고 실행 target아래 jar파일 하나를 생성한다. 만든 jar파일 샐행 java -jar &lt;jar파일명> --&lt;arguments> spring-maven-plugin이 해주는 일 (패키징) 모든 의존성을 포함하는 jar파일 하나를 만들어준다. 과거 “uber” jar 를 사용 모든 클래스 (의존성 및 애플리케이션)를 하나로 압축하는 방법 뭐가어디에서온건지알수가없음 무슨 라이브러리를 쓰는건지.. 내용은 다르지만 이름이 같은 파일은 또 어떻게? 스프링 부트의 전략 내장 JAR : 기본적으로 자바에는 내장 JAR를 로딩하는 ​표준적인 방법이 없음​. 애플리케이션 클래스와 라이브러리 위치 구분 org.springframework.boot.loader.jar.JarFile을 사용해서 내장 JAR를 읽는다. org.springframework.boot.loader.Launcher를 사용해서 실행한다.","link":"/2019/04/03/spring/springboot05/"},{"title":"스프링 부트 활용10 - Test","text":"스프릥 부트 개념과 활용10(inflearn) - 백기선Spring boot Test spring-boot-starter-test 의존성이 필요하다. @SpringBootTest @RunWith(SpringRunner.class)랑 같이 사용해야 한다. 빈 설정 파일 필요없음. 빈은 알아서 찾는다.(@SpringBootApplication) webEnvironment MOCK: mock servlet environment 기본값 ServletContainer가 사용하지 않는다.내장 톰캣 구동 안 함. mocking한 servlet이 뜬다. dispatcher servlet에 요청을 보내는것과 유사한 실험이 가능하다. mockmvc라는 클라이언트가 필요하다. stauts(), content() 메소드는 MockMvcResultMatcher에 있는것을 가져온다. RANDON_PORT, DEFINED_PORT ServletContainer를 사용한다.내장 톰캣 구동함 테스트 TestRestTemplet 또는 테스트용 web client를 사용해야한다. TestRestTemplet 원본이 아닌 mocking을 하여 사용할 수 있다. WebTestClient Java5에 추가 된 RestClient Async 하다.테스트 코드에서도 웹클라이언트와 유사한 api를 사용할 수 있다. webflux 의존성 추가가 필요하다. 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt; api가 보다 이해하기 편하다. 추천 NONE 서블릿환경제공안함. 슬라이스 테스트 @SpringBootTest를 사용 시, @SpringBootApplication을 찾아서 모든 빈을 등록하고 @MockBean이 있으면 해당 빈만 교체한다. 모든 빈이 등록되는걸 원하지 않을 때 사용한다. 레이어 별로 잘라서 테스트하고 싶을 때 사용한다. @SpringBootTest를 대체하여 사용한다. @JsonTest Json형태로 결과가 나올 때, 해당 Json과 관련 된 테스트에 사용 JacksonTester&lt;도메인>을 주입 받아 사용한다. reference문서 @WebMvcTest controller 관련 테스트할 때, 주로 사용 web과 관련된 것들만 빈으로 등록된다. 필요한것들은 MockBean으로 등록하여 사용한다. @WebFluxTest @DataJpaTest 테스트 유틸 OutputCapture 로그를 포함 콘솔에 찍히는 모든것을 캡쳐한다. TestPropertyValues TestRestTemplate ConfigFileApplicationContextInitializer","link":"/2019/04/10/spring/springboot10/"},{"title":"스프링 부트 활용09 - 로깅","text":"스프릥 부트 개념과 활용09(inflearn) - 백기선Spring boot 스프링 부트 기본 로거 설정로깅 퍼사드 VS 로거 로깅 퍼사드 로거를 바꿔낄 수 있게 해준다. Commons Logging​, SLF4j 로거 실제로 로그를 찍는 역할 JUL, Log4J2, ​Logback 스프링 5에 로거 관련 변경 사항 reference 문서 Spring-JCL(자카르타 커먼스 로깅) Commons Logging -&gt; SLF4j or Log4j2 pom.xml에 exclusion 안해도 됨.(Spring boot 2 부터..) Log4j2가 있으면 Log4j2를 사용한다.SLF4j만 있으면 SLF4j를 쓴다. 스프링 부트는 Commons Logging을 쓴다.Commons Logging을 사용해도 SLF4j로 가고 Logback로 간다.결국 Logback이 로그를 찍는다. 스프링 부트 로깅 기본포맷 --debug (일부 핵심 라이브러리만 디버깅 모드로) --trace (전부 다 디버깅 모드로) 컬러 출력: spring.output.ansi.enabled 파일 출력: logging.file 또는 logging.path file : 파일 path : 디렉토리 로그 레벨 조정: logging.level.패지키 = 로그 레벨 커스터 마이징 reference 문서 커스텀 로그 설정 파일 사용하기 Logback: logback-spring.xml 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;include resource=&quot;org/springframework/boot/logging/logback/base.xml&quot;/&gt; &lt;logger name=&quot;패키지_path&quot; level=&quot;DEBUG&quot;/&gt;&lt;/configuration&gt; Log4J2: log4j2-spring.xml JUL (비추): logging.properties Logback extension logback-spring.xml을 사용해야한다.(logback.spring.xml 사용 시, 로딩이 일찍되어 사용불가) 프로파일 Environment 프로퍼티 로거를 Log4j2로 변경하기 reference문서 exclusion logging(spring-boot-starter) 123456&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt; 의존성 추가 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 앞서 말했던 스프링부트2버전대부터 pom.xml에 exclusion없이 사용할 수 있다고 하였는데, 그 경우에는 로깅퍼사드를 변경하는 경우이며, 이 경우에는 로거를 변경하는 경우이다.","link":"/2019/04/10/spring/springboot09/"},{"title":"스프링 MVC 설정07 - 핸들러 인터셉터, 리소스 핸들러, HTTP 메세지 컨버터, 기타 설정","text":"스프링 웹 MVC(inflearn) - 백기선Springframework 핸들러 인터셉터 reference HandlerInterceptor 핸들러 맵핑에 설정할 수 있는 인터셉터 핸들러를 실행하기 전, 후(아직 랜더링 전) 그리고 완료(랜더링까지 끝난 이후) 시점에 부가 작업을 하고 싶은 경우에 사용할 수 있다. 여러 핸들러에서 반복적으로 사용하는 코드를 줄이고 싶을 때 사용할 수 있다. 로깅, 인증 체크, Locale 변경 등… boolean preHandle(request, response, handler) 핸들러 실행하기 전에 호출 됨 핸들러에 대한 정보를 사용할 수 있기 때문에 서블릿 필터에 비해 보다 세밀한 로직을 구현할 수 있다. 리턴값으로 계속 다음 인터셉터 또는 핸들러로 요청,응답을 전달할지(true) 응답 처리가 이곳에서 끝났는지(false) 알린다. void postHandle(request, response, modelAndView) 핸들러 실행이 끝나고 아직 뷰를 랜더링 하기 이전에 호출 됨 “뷰”에 전달할 추가적이거나 여러 핸들러에 공통적인 모델 정보를 담는데 사용할 수도 있다. 이 메소드는 인터셉터 역순으로 호출된다. 예) preHandle 1 -&gt; preHandle 2 -&gt; 요청처리 -&gt; postHandler2 -&gt; postHandler1 비동기적인 요청 처리 시에는 호출되지 않는다. asyncHandlerInterceptor에서 다룬다. void afterCompletion(request, response, handler, ex) 요청 처리가 완전히 끝난 뒤(뷰 랜더링 끝난 뒤)에 호출 됨 preHandler에서 true를 리턴한 경우에만 호출 됨 이 메소드는 인터셉터 역순으로 호출된다. 비동기적인 요청 처리 시에는 호출되지 않는다. 서블릿 필터와 비교 서블릿 보다 구체적인 처리가 가능하다.(핸들러, 뷰가 제공된다.) 서블릿은 보다 일반적인 용도의 기능을 구현하는데 사용하는게 좋다. 예) Cross-site scripting (XSS) attack 방지 → 뷰 or 핸들러의 정보는 필요없다.. naver에서 만든 LUCY필터가 있다. 구현 implements HandlerInterceptor 핸들러 인터셉터 등록하기 .order로 순서를 정할수 있다. add 순으로 등록된다. .addPathPattern을 사용하여 원하는 핸들러에만 적용 가능 testcode AnotherInterceptor는 PathPattern에 걸리지 않아서 제외 리소스 핸들러 이미지, 자바스크립트, css, html 파일 같은 리소스를 처리하는 핸들러 reference 문서 Default Servlet 서블릿 컨테이너가 기본으로 제공하는 서블릿으로 정적인 리소를 처리할 때, 사용한다. 예)..톰캣문서 스프링 MVC 리소스 핸들러 맵핑 등록 가장 낮은 우선 순위로 등록. 다른 핸들러 맵핑이 “/” 이하 요청을 처리하도록 허용하고 최종적으로 리소스 핸들러가 처리하도록. 스프링 부트를 사용하는 경우 리소스 핸들러 설정 file시스템으로 맵핑 시, classpath: 대신 file:로 넣어준다. 어떤 요청 패턴을 지원할 것인가 어디서 리소스를 찾을 것인가 캐싱 ResourceResolver: 요청에 해당하는 리소스를 찾는 전략 캐싱, 인코딩(gzip, brotli), WebJar, … ResourceTransformer: 응답으로 보낼 리소스를 수정하는 전략 캐싱, CSS 링크, HTML5 AppCache, … ResourceResolver, ResourceTransformer 관련 내용은 reference를 참고 스프링 부트 기본 정적 리소스 핸들러와 캐싱 제공 HTTP 메세지 컨버터 요청 본문에서 메시지를 읽어들이거나(@RequestBody), 응답 본문에 메시지를 작성할 때(@ResponseBody) 사용한다. RestController는 모든 메소드에 @ResponseBody가 생략되어있는 것. @RequestBody 요청 본문의 문자열을 받는다. 요청 본문의 문자열을 변환 xml, JSON등을 객체로 변환 기본 HTTP 메시지 컨버터 바이트 배열 컨버터 문자열 컨버터 Resource 컨버터 Form 컨버터 (폼 데이터 to/from MultiValueMap&lt;String, String&gt;) Map → 폼 데이터 or 폼 데이터 → Map 의존성이 있을 때 등록이되는 메세지 컨버터 xml (JAXB2 컨버터) Json (Jackson2 컨버터) (Jackson 컨버터) (Gson 컨버터) feed (Atom 컨버터) (RSS 컨버터) … 설정 방법 기본으로 등록해주는 컨버터에 새로운 컨버터 추가하기: extendMessageConverters reference 문서 기본으로 등록해주는 컨버터는 다 무시하고 새로 컨버터 설정하기: configureMessageConverters reference 문서 의존성 추가로 컨버터 등록하기 (제일 많이 사용하게 될 것이며 추천한다.) 메이븐 또는 그래들 설정에 의존성을 추가하면 그에 따른 컨버터가 자동으로 등록된다. WebMvcConfigurationSupport (이 기능 자체는 스프링 프레임워크의 기능임, 스프링 부트 아님.)참고 JSON용 HTTP 메세지 컨버터 스프링부트를 사용하지 않는 경우 사용하고 싶은 JSON 라이브러리를 의존성으로 추가 GSON JacksonJSON JacksonJSON 2 스프링 부트를 사용하는 겨우 기본적으로 JacksonJSON2가 의존성에 들어있다. 즉, JSON용 HTTP 메세지 컨버터가 등록되어있다. ObjectMapper는 스프링부트에서 의존성을 자동으로 주입해준다.(spring-boot-starter-web 추가 시) TestCode JsonPath문법 https://github.com/json-path/JsonPath http://jsonpath.com/ XML용 HTTP 메세지 컨버터 OXM(Object-XML Mapper) 라이브러리 중에 스프링이 지원하는 의존성 추가 JacksonXML JAXB Mashaller : 객체 → xml UnMashaller : xml → 객체 스프링 부트가 기본으로 관련 의존성을 추가해주지 않는다. 의존성 추가 12345678910111213&lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt; &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring-framework.version}&lt;/version&gt;&lt;/dependency&gt; Marshaller 등록 xml로 변환할 클래스의 패키지이름을 설정해준다. 도메인 클래스에 @XmlRootElement 애노테이션 추가 TestCode Xpath 문법 https://www.w3schools.com/xml/xpath_syntax.asp https://www.freeformatter.com/xpath-tester.html 그밖에 WebMvcConfigurer 설정 reference 문서 CORS 설정 Cross Origin 요청 처리 설정 같은 도메인에서 온 요청이 아니더라도 처리를 허용하고 싶다면 설정한다. 리턴 값 핸들러 설정 스프링 MVC가 제공하는 기본 리턴 값 핸들러 이외에 리턴 핸들러를 추가하고 싶을 때 설정한다. 아큐먼트 리졸버 설정 스프링 MVC가 제공하는 기본 아규먼트 리졸버 이외에 커스텀한 아규먼트 리졸버를 추가하고 싶을 때 설정한다. 뷰 컨트롤러 단순하게 요청 URL을 특정 뷰로 연결하고 싶을 때 사용할 수 있다. 비동기 설정 비동기 요청 처리에 사용할 타임아웃이나 TaskExecutor를 설정할 수 있다. 뷰 리졸버 설정 핸들러에서 리턴하는 뷰 이름에 해당하는 문자열을 View 인스턴스로 바꿔줄 뷰 리졸버를 설정한다. Content Negotiation 설정 요청 본문 또는 응답 본문을 어떤 (MIME) 타입으로 보내야 하는지 결정하는 전략을설정한다.","link":"/2019/06/24/spring/spring_web_mvc07/"},{"title":"스프링 부트 활용11 - SpringBoot_Devtools","text":"스프릥 부트 개념과 활용11(inflearn) - 백기선Spring boot SpringBoot_Devtools devtools 의존성 추가가 필요하다. 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 캐시설정을 개발 환경에 맞게 변경 캐시 적용 시, 변경사항을 바로바로 반영하지 않음.(캐시를 꺼준다.) devtools 사용보다는 설정만 복사하여 property 설정을 하는것을 추천한다.(restart, 라이브 릴로드 등의 기능은 오류가 많음) 클래스패스에 있는 파일이 변경 될 때마다 자동으로 재시작 직접 껐다 켜는거 (cold starts)보다 빠르다. 스프링 부트는 클래스 로더를 2개 사용한다.(devtools에서는 restart만 재시작하기 때문에 더 빠르다.) base classloader : 우리가 변경하지 않는 의존성을 읽는다. restart classloader : 애플리케이션을 읽는다. 릴로딩 보다는 느리다. (JRebel 같은건 아님) 리스타트 하고 싶지 않은 리소스는? spring.devtools.restart.exclude 리스타트 기능 끄려면? spring.devtools.restart.enabled = false 파일 변경 후, 빌드하면 저절로 재시작된다. 에러가 많다. (추천하지 않음) 라이브릴로드 리스타트했을때브라우저자동리프레시하는기능 브라우저 플러그인 설치해야 함. 라이브 릴로드 서버 끄려면? spring.devtools.liveload.enabled = false 글로벌설정 ~/.spring-boot-devtools.properties (우선순위 1등) 리모트 애플리케이션 과정이 복잡하고 위험함으로 운영용에서 사용하지 않는것을 추천한다.","link":"/2019/04/11/spring/springboot11/"},{"title":"스프링 부트 운영16 - Actuator","text":"스프릥 부트 개념과 활용16(inflearn) - 백기선Spring boot Actuator 스프링 부트는 애플리케이션 운영 환경에서 유용한 기능을 제공한다. 스프링 부트가 제공하는 엔드포인트와 메트릭스 그 데이터를 활용하는 모니터링 기능 reference 문서 의존성 추가 spring-boot-starter-actuator 애플리케이션의 각종 정보를 확인할 수 있는 Endpoints 다양한 Endpoints 제공. auditevents : 인증정보 conditions : 자동설정 및 조건 env : environment안에 property health : 잘 구동중인지.. httptrace : 최근 100개의 http요청과 응답 loggers : 로그와 레벨 정보, 수정도 가능하다. metrics : 메모리, cpu등 핵심정보, 알림설정도 가능하다. (모니터링 중 어느 수치를 넘거나..) shutdown : 애플리케이션을 off 할 수 있다. web jolokia : JMX 빈을 http 화면에서 확인할 수 있다. JMX 또는 HTTP를 통해 접근 가능 함. shutdown을 제외한 모든 Endpoint는 기본적으로 활성화 상태. 활성화(enable)랑 공개(Exposing)는 다르다.보안상의 이유로 노출 health, info 외 비공개이다. 활성화 옵션 조정 management.endpoints.enabled-by-default=false management.endpoint.info.enabled=true JMX와 HTTP JConsole 사용하기 terminal에서 jconsole https://docs.oracle.com/javase/tutorial/jmx/mbeans/ https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html VisualVM 사용하기 [다운로드 사이트]https://visualvm.github.io/download.html JConsole보다 가시적이고 다양한 플러그인을 지원한다. HTTP 사용하기 /actuator health와 info를 제외한 대부분의 Endpoint가 기본적으로 비공개 상태 공개 옵션 조정 management.endpoints.web.exposure.include=* management.endpoints.web.exposure.exclude=env,beans Spring-Boot-Admin 스프링 부트가 제공하는것이 아닌 제 3자가 오픈소스로 제공하는 어플리케이션 Actuator 정보를 간단한 UI로 제공한다. github : https://github.com/codecentric/spring-boot-admin Admin 서버 설정 의존성 추가 12345&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt;&lt;/dependency&gt; @EnableAdminServer 클라이언트 설정 (운영될 프로젝트) 의존성 추가 12345&lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;version&gt;2.1.4 &lt;/version&gt;&lt;/dependency&gt; spring.boot.admin.client.url=http://localhost:8080 management.endpoints.web.exposure.include=* 포트를 같은걸 쓸 수 없기 때문에 포트 변경해준다. 설정했던 localhost:8080 접속 시, 아래와같은 화면이 나오고 아래 버튼 클릭 시, 기능들을 사용할 수 있다. 가시적으로 정보들을 확인할 수 있고, 운영중에 로거 변경등의 기능이 있다. 스프링부트 개념과 활용 강좌를 모두 수강하였습니다.😁제가 원했던 내용보다 자세하고 깊숙하게 알려주셔서 너무너무 만족스러웠습니다.제가 알게된 내용들로 프로젝트를 진행할 생각을 하니 설레기도 합니다.다음 정리 블로깅은 아마 스프링 JPA되지 않을까합니다.스프링 JPA는 ORM의 구현체로 객체와 관계형 데이터베이스의 연결을 해주는 api며 많은 기업에서 사용하고 있는것으로 알고있습니다.빨리 수강하고 싶네요 😁","link":"/2019/04/18/spring/springboot16/"},{"title":"스프링 MVC 활용08 - HTTP 요청 맵핑하기","text":"스프링 웹 MVC(inflearn) - 백기선SpringMVC 활용 스프링 MVC 핵심 기술 소개 reference 문서 애노테이션 기반의 스프링 MVC 요청 맵핑하기 핸들러 메소드 모델과 뷰 데이터 바인더 예외 처리 글로벌 컨트롤러 사용할 기술 스프링 부트 스프링 프레임워크 웹 MVC 타임리프 학습 할 애노테이션 @RequestMapping @GetMapping, @PostMapping, @PutMapping, … @ModelAttribute @RequestParam, @RequestHeader @PathVariable, @MatrixVariable @SessionAttribute, @RequestAttribute, @CookieValue @Valid @RequestBody, @ResponseBody @ExceptionHandler @ControllerAdvice HTTP요청 맵핑하기 - 요청 메소드 Handler : 요청을 처리할 수 있는 메소드를 보통 핸들러라고 부른다. HTTP Method GET, POST, PUT, PATCH, DELETE, … GET 요청 클라이언트가 서버의 리소스를 요청할 때 사용한다. 캐싱 할 수 있다. 캐시와 관련된 헤더를 응답에 실어 보낼 수 있다. 동일한 요청을 보낼 때 조건적인 GET으로 바뀔 수 있다. 304 not modified 라고 응답하면, body를 보내지 않아도 클라이언트 쪽에서 캐싱하고 있던 그정보 드대로 보여준다. 브라우저 기록에 남는다. 북마크 할 수 있다. 민감한 데이터를 보낼 때 사용하지 말 것. (URL에 다 보이니까) idempotent (동일한 요청 시, 동일한 응답) POST 요청 클라이언트가 서버의 리소스를 수정하거나 새로 만들 때 사용한다. (idempotent X) 서버에 보내는 데이터를 POST 요청 본문에 담는다. 캐시할 수 없다. 브라우저 기록에 남지 않는다. 북마크 할 수 없다. 데이터 길이 제한이 없다. PUT 요청 URI에 해당하는 데이터를 새로 만들거나 수정할 때 사용한다. POST와 다른 점은 “URI”에 대한 의미가 다르다. POST의 URI는 보내는 데이터를 처리할 리소스를 지칭하며 PUT의 URI는 보내는 데이터에 해당하는 리소스를 지칭한다. Idempotent PATCH 요청 PUT과 비슷하지만, 기존 엔티티와 새 데이터의 차이점만 보낸다는 차이가 있다. 일부의 데이터만 수정하고 싶을 때, 사용 Idempotent DELETE 요청 URI에 해당하는 리소스를 삭제할 때 사용한다. Idempotent 스프링 웹 MVC에서 HTTP method 맵핑하기● @RequestMapping(method=RequestMethod.GET)● @RequestMapping(method={RequestMethod.GET, RequestMethod.POST})● @GetMapping, @PostMapping, … 참고 https://www.w3schools.com/tags/ref_httpmethods.asp https://tools.ietf.org/html/rfc2616#section-9.3 https://tools.ietf.org/html/rfc2068 HTTP 요청 맵핑하기 - URI패턴 맵핑URI, URL, URN 참고 요청 맵팽하기 @RequestMapping은 다음의 패턴을 지원합니다. ? : 한 글자 (“/author/???” =&gt; “/author/123”) * : 여러 글자 (“/author/*” =&gt; “/author/keesun”) ** : 여러 패스 (“/author/** =&gt; “/author/keesun/book”) @RequestMapping은 클래스에도 선언이 가능하며, 조합도 가능하다. 정규표현식 맵핑도 가능하다. (띄어쓰기 주의) 패턴이 중복되는 경우 가장 구체적으로 맵핑되는 핸들러를 선택한다. URI 확장자 맵핑 지원 스프링 mvc는 기본적으로 지원한다. 예를 들어 “/bong”으로 매핑 시, “/bong.*”을 함께 맵핑 “/bong.json”, “/bong.html”, “/bong.xml”등을 암묵적으로 맵핑해준다. 이 기능은 권장하지 않음 (스프링부트에서는 기본적으로 이 기능을 사용하지 않도록 설정해준다.) 보안 이슈(RFD Attack) Reflected File Download https://www.trustwave.com/en-us/resources/blogs/spiderlabs-blog/reflected-file-download-a-new-web-attack-vector/ https://www.owasp.org/index.php/Reflected_File_Download https://pivotal.io/security/cve-2015-5211 URI변수, Path 매개변수, URI 인코딩을 사용할 때 불명확함. 최근에는 accept header에 요청할 파일의 확장자를 설정해준다. header를 통해 응답의 유형을 판단할 수 있다.(권장) request parameter를 통해 설정할수도 있다.(차선책) ex).. “/bong?type=xml” HTTP 요청 맵핑하기 - 미디어 타입 맵핑 특정한 타입의 데이터를 담고 있는 요청만 처리하는 핸들러 @RequestMapping(consumes=MediaType.APPLICATION_JSON_UTF8_VALUE) 문자열을 입력하는 대신 MediaType을 사용하면 상수를 (IDE에서) 자동 완성으로 사용할 수있다. MediaType.APPLICATION_JSON_UTF8_VALUE은 문자열로 직접 넣어줄 수 있으나 type safe하지 않다. Content-Type 헤더로 필터링 매치 되는 않는 경우에 415 Unsupported Media Type 응답 특정한 타입의 응답을 만드는 핸들러 @RequestMapping(produces=”application/json”) Accept 헤더로 필터링 (하지만 살짝… 오묘함) 매치 되지 않는 경우에 406 Not Acceptable 응답 클래스에 선언한 @RequestMapping에 사용한 것과 조합이 되지 않고 메소드에 사용한 @RequestMapping의 설정으로 덮어쓴다. Not (!)을 사용해서 특정 미디어 타입이 아닌 경우로 맵핑 할 수도 있다. HTTP 요청 맵핑하기 - 헤더와 매개변수 특정한 헤더가 있는 요청을 처리하고 싶은 경우 @RequestMapping(headers = “key”) 특정한 헤더가 없는 요청을 처리하고 싶은 경우 @RequestMapping(headers = “!key”) 특정한 헤더 키/값이 있는 요청을 처리하고 싶은 경우 @RequestMapping(headers = “key=value”) 특정한 요청 매개변수 키를 가지고 있는 요청을 처리하고 싶은 경우 @RequestMapping(params = “a”) 특정한 요청 매개변수가 없는 요청을 처리하고 싶은 경우 @RequestMapping(params = “!a”) 특정한 요청 매개변수 키/값을 가지고 있는 요청을 처리하고 싶은 경우 @RequestMapping(params = “a=b”) HTTP 요청 맵핑하기 - HEAD와 OPTIONS 요청 처리우리가 구현하지 않아도 스프링 웹 MVC에서 자동으로 처리하는 HTTP Method HEAD OPTIONS HEAD GET 요청과 동일하지만 응답 본문을 받아오지 않고 응답 헤더만 받아온다. OPTIONS 사용할 수 있는 HTTP Method 제공 서버 또는 특정 리소스가 제공하는 기능을 확인할 수 있다. 서버는 Allow 응답 헤더에 사용할 수 있는 HTTP Method 목록을 제공해야 한다. 참고 https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/standalone/resultmatchers/HeaderAssertionTests.java HTTP 요청 맵핑하기 - 커스텀 애노테이션@RequestMapping 애노테이션을 메타 애노테이션으로 사용하기 @GetMapping 같은 커스텀한 애노테이션을 만들 수 있다. 메타(Meta) 애노테이션 애노테이션에 사용할 수 있는 애노테이션 스프링이 제공하는 대부분의 애노테이션은 메타 애노테이션으로 사용할 수 있다. 조합(Composed) 애노테이션 한개 혹은 여러 메타 애노테이션을 조합해서 만든 애노테이션 코드를 간결하게 줄일 수 있다. 보다 구체적인 의미를 부여할 수 있다. @Retention 해당 애노테이션 정보를 언제까지 유지할 것인가. Source: 소스 코드까지만 유지. 즉, 컴파일 하면 해당 애노테이션 정보는 사라진다는 이야기. Class: 컴파인 한 .class 파일에도 유지. 즉 런타임 시, 클래스를 메모리로 읽어오면 해당 정보는 사라진다. Runtime: 클래스를 메모리에 읽어왔을 때까지 유지! 코드에서 이 정보를 바탕으로 특정 로직을 실행할 수 있다. @Target 해당 애노테이션을 어디에 사용할 수 있는지 결정한다. 배열로 여러 엘리먼트도 지정 가능하다. @Documented 해당 애노테이션을 사용한 코드의 문서에 그 애노테이션에 대한 정보를 표기할지 결정한다. 메타 애노테이션 https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beansmeta-annotations https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/annotation/AliasFor.html","link":"/2019/06/24/spring/spring_web_mvc08/"},{"title":"스프링 부트 활용14 - 스프링 시큐리티","text":"스프릥 부트 개념과 활용14(inflearn) - 백기선Spring boot스프링 시큐리티 참고 - 뷰 컨트롤러 사용 Webconfigure 생성 @Configuration implements @Overide - addViewControllers registry.addViewController(““).setViewName(“&lt;View_name&gt;”); 추가적인 일이 있다면 @Controller를 쓰는것이 유리하다. spring-boot-starter-security 스프링 시큐리티 웹 시큐리티 메소드 시큐리티 다양한 인증 방법 지원 LDAP, 폼 인증, Basic 인증, OAuth, … spring-boot-starter-security 의존성 추가 의존성을 추가하게 되면 정상작동하던 컨트롤러테스트가 실패하게 된다. 401 Unauthorized 스프링 부트가 제공하하는 스프링 시큐리티 자동설중 하나이다. 모든요청에 스프링 시큐리티로 인해 인증이 필요하다. Basic Authenticate, form 인증이 둘다 적용된다.(상기 이미지는 Basic Authenticate 오류) Basic 인증은 Accept 헤더에 따라 달라진다. accept 헤더에 text/html을 보내게 되면 form 인증으로 넘어간다. 보통 브라우저에서 accpet 헤더를 text/html을 쓴다. 브라우저에서 루트를 요청해도 로그인으로 이동된다. 인증정보가 없기 때문에 스프링 시큐리티에서 만들어준 로그인 form페이지로 이동된다.(스프링 부트 자동설정) 스프링 부트 시큐리티 자동 설정 SecurityAutoConfiguration DefaultAuthenticationEventPublisher 빈 등록 여러상황에 대해 이벤트를 발생시킨다.ex) 비빌번호 오류, 아이도 오류, …. 다양한 인증 에러 핸들러 등록 가능 SpringBootWebSecurityConfiguration WebSecurityConfigurerAdapter가 빈으로 등록되어 있지 않을때 WebSecurityConfigurerAdapter의 내용을 그대로 쓰고있다.(상속만하고 아무것도 정의되어 있지않음) WebSecurityConfigurerAdapter 핵심내용 WebSecurityConfigurerAdapter를 상속하는 Configuration클래스(@Configuration 빈등록)를 만들면 거의 동일하게 동작하는 나만의 시큐리티 설정을 가질 수 있다. UserDetailsServiceAutoConfiguration UserDetailsService, AuthenticationManager,AuthenticationProvider가 없을 때 inMemoryDetailsManager 객체를 만든다. 기본 유저 객체만드는 역할 spring-boot-starter-security 스프링 시큐리티 5.* 의존성 추가 모든 요청에 인증이 필요함. 사용자 설정 기본 Username: user 기본 Password: 애플리케이션을 실행할 때 마다 랜덤 값 생성 (콘솔에 출력 됨.) spring.security.user.name spring.security.user.password test 방법 의존성 추가 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; @WithMockUser 사용 설정한 유저로 테스트 대부분의 서비스들은 UserDetailsService를 등록하고 사용하며, WebSecurityConfigurerAdapter를 이용하여 보다 쉽게 설정을 하기 때문에 스프링 부트에서 지원하는 시큐리티는 사실상 사용 할 일이 없다. 커스터 마이징 웹 시큐리티 설정 WebSecurityConfigurerAdapter를 상속하는 Configuration을 빈으로 등록한다. 이미지 이 순간 스프링부트에서 자동 설정해주는 SecurityAutoConfiguration은 동작하지 않는다. http configure을 오버라이딩 한다. 12345678@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&quot;/&quot;, &quot;/hello&quot;).permitAll() .anyRequest().authenticated() .and().formLogin() .and().httpBasic(); } 루트 및 “/hello” 요청에 대하여 접근을 허락한다. 그 외 모든 요청에 대하여 인증을 한다. formLogin 인증 httpBasic 인증 결과 루트 hello my UserDetailsServie 구현 User Entity 및 Repository를 생성한다. User관련 서비스를 생성한다. implements UserDetailsService @Override loadByUsername username을 가지고 user객체를 불러와서 인증 return 될 UserDetails라는 인터페이스 구현체는 제 각각 구현되어있는 유저정보이다.스프링 시큐리티는 User라는 이름으로 UserDetails의 구현체를 제공한다. User의 파라미터로 name, password를 넣고 세번째 인자로 authorities()메서드를 생성해서 넣어준다. 더이상 임의의 User를 만들어주지 않는다. PasswordEncoder를 설정하지 않아서 에러가 발생할 것으로 예상되어진다. PasswordEncoder 설정 및 사용 인코딩을 안하고 로그인을 하면.. 오류 발생 패스워드를 직접 DB에 넣으면 안된다. 인코딩 필수 Security 설정했던 클래스에서패스워드 인코더를 아무것도 인코딩하지 않는 NoOpPasswordEncoder를 리턴하는 PasswordEncoder를 빈으로 등록하면 로그인이 가능하다.그러나, 절대로 이런 방법을 사용하면 안된다. 패스워드 인코더를 사용해야한다. 스프링 시큐리티 권장 패스워드 인코더 사용 패스워드 인코더 빈 등록 12PasswordEncoder passwordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder() 패스워드 인코딩 인코딩 결과 bcrypt로 인코딩된 것이 보여진다.","link":"/2019/04/16/spring/springboot14/"},{"title":"스프링 부트 활용12 - 스프링 웹 MVC","text":"스프릥 부트 개념과 활용12(inflearn) - 백기선Spring boot 스프링 웹 MVC 스프링 웹 MVC reference문서 스프링 부트 MVC 자동 설정으로 제공하는 여러 기본 기능 스프링 MVC 확장 부분적 설정 추가 @Configuration + WebMvcConfigurer 스프링 MVC 재정의 웹 MVC에 대해 전체 재정의 (잘안쓴다.) @Configuration + @EnableWebMvc HttpMessageConverters reference문서 스프링 프레임워크에서 제공하는 인터페이스 HTTP 요청 본문을 객체로 변경하거나, 객체를 HTTP 응답 본문으로 변경할 때 사용. {“username”:”keesun”, “password”:”123”} User HttpMessageConverter를 사용하는데 어떤요청인지, 또는 어떤 응답인지에 따라서 HttpMessageConverter는 달라진다. @RequestBody @ResponseBody @RestController 사용 시, 메소드에 @ResponseBody를 포함하고 있다. 예제@RequestBody 및 @RestController를 활용하여 테스트 코드 작성하기 User UserController UserControllerTest contentType : 요청 타입 accept : 응답 타입 content : 요청 is(), equalTo()는 Matchers 메소드 사용 ViewResolver ContentNegotiationViewResolver ViewResolver중 하나로, 들어오는 요청 accept 헤더에 따라 응답이 달라진다. accept 헤더는 클라이언트가 어떤타입의 응답을 원한다고 알려주는 것. accept 헤더를 제공하지 않는 경우도 많다. format 매개 변수를 이용하여 처리한다. 스프링 초기에는 url에 .json 등도 지원했지만, 현재는 지원하지 않는다. xml 메세지 컨버터 추가하기 accpet 헤더만 xml로 설정 후, 위의 예제 테스트를 실행하면 오류 발생 이유는 .. xml 메세지 컨버터가 없기 때문에 HttpMessageConvertersAutoConfiguration → JacksonHttpMessageConvertersConfiguration에 들어가 보면 XmlMapper.class가 없어서 설정이 안 된 것을 볼 수 있다. XmlMapper.class를 추가하기 위해 의존성을 추가한다. 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; 정상작동 정적 리소스 지원 웹 브라우저나 클라이언트에 요청이 들어왔을 때, 그것에 해당하는 리소스가 만들어져 있고 그것을 응답하는 것 정적 리소스 맵핑 : “/**” 기본 리소스 위치 classpath:/static classpath:/public classpath:/resources/ classpath:/META-INF/resources 예) “/hello.html” =&gt; /static/hello.html spring.mvc.static-path-pattern: 맵핑 설정 변경 가능 매핑이 루트(/)부터 시작하지 않고 싶을 때 사용할 수 있다.예) “localhost:8080/static/hello.html” spring.mvc.static-locations: 리소스 찾을 위치 변경 가능 서버의 Last-Modified 헤더를 보고 304 응답을 보냄. if-modified-since 이후에 바귀었으면 리소르를 새로 받는다.(200) 이후에 바뀌지 않았으면 리소를 새로 받지않고 이전에 받은것을 사용한다.(304)응답이 훨씬 빠르다. ResourceHttpRequestHandler가 처리함. WebMvcConfigurer의 addRersourceHandlers로 커스터마이징 할 수 있음 웹 jar 스프링 부트는 웹 jar에 대한 기본 매핑을 지원한다. 예제 jQuery 추가 의존성 추가 사용 할 파일에서 webjar를 사용하여 참조 버전을 생략하고 사용하려면.. webjars-locator-core 의존성 추가 필요 버전을 사용해도 되고 안해도 된다. index페이지(welcome페이지)와 파비콘 웰컴 페이지 index.html 찾아 보고 있으면 제공. 기본 리소스 위치 index.템플릿 찾아 보고 있으면 제공. 둘다없으면에러페이지. 스프링부트 에러핸들러에서 만든 파비콘 파비콘이란? favicon.ico 파일을 추가한다. 기본 리소스 위치 파이콘 만들기 파비콘이 안 바뀔 때.. https://stackoverflow.com/questions/2208933/how-do-i-force-a-favicon-refresh 브라우저에서 favicon.ico를 읽고 브라우저를 재시작 Thymeleaf 템플릿 엔진코드 제너레이션, 이메일 템플릿등에 사용할 수 있으나, 주로 뷰를 만들 때, 사용한다.기본적인 템플릿은 같으나, 안에 값들만 달라진다.(동적 컨텐츠) 스프링 부트가 자동 설정을 지원하는 템플릿 엔진 FreeMarker Groovy Thymeleaf Mustache JSP를 권장하지 않는 이유 스프링부트가 지향하는 바와 다르다. JAR패키징 할때는 동작하지 않고, WAR패키징 해야함. Undertow는 JSP를 지원하지 않음. reference문서 Thymeleaf 사용하기 https://www.thymeleaf.org/ https://www.thymeleaf.org/doc/articles/standarddialect5minutes.html 의존성 추가: spring-boot-starter-thymeleaf 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 템플릿 파일 위치: /src/main/resources/​template/ Thymeleaf 네임스페이스 추가 th를 사용할 수 있다. (name 값이 있으면 사용한다.) Thymeleaf test 예제 HTML Unit HTML 템플릿 뷰 테스트를 보다 전문적하기 위해 도와주는 툴 스프링 부트는 HTML Unit 기능 및 자동설정 지원한다. http://htmlunit.sourceforge.net/ http://htmlunit.sourceforge.net/gettingStarted.html 의존성 추가가 필요하다. 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;htmlunit-driver&lt;/artifactId&gt; &lt;version&gt;2.34.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.htmlunit&lt;/groupId&gt; &lt;artifactId&gt;htmlunit&lt;/artifactId&gt; &lt;version&gt;2.34.1&lt;/version&gt;&lt;/dependency&gt; WebClient를 주입받아 사용한다. WebClient를 만들 때, MockMvc를 사용하기 때문에 MockMvc도 주입받아 사용할 수 있다. ExceptionHandler 스프링 부트 애플리케이션 실행하면 기본적으로 에러핸들러가 등록이 되어있다.그리고 그 에러핸들러에 의해 메세지가 보인다. 브라우저 요청 시 머신핸들러 요청 시 (Json 응답) 스프링 @MVC 예외 처리 방법 @ExchangepHandler @ControllerAdvice 여러 컨트롤러에서 사용하기위해 @ExceptionHandler @ControllerAdvice내에서 정의한다. 스프링 부트가 제공하는 기본 예외 처리기 BasicErrorController HTML과 JSON 응답 지원 error.path라는 키값에 값이 있으면 값사용, 없으면 /error사용server.error.path 키값에 값이 있으면 값사용, 없으면 이전 값 사용(/error 또는 error.path) 커스터마이징 방법 ErrorController 구현 스프링부트에서는 BasicErrorController를 상속받아 만드는것을 추천한다. 커스텀 에러 페이지 상태 코드 값에 따라 에러 페이지 보여주기 src/main/resources/static||template/error/ html파일 이름은 상태값과 같아야한다. 404.html 5xx.html ErrorViewResolver 구현 Spring HATEOAS HATEOAS : Hypermedia As The Engine Of Application State Understanding HATEOAS 문서 서버: 현재 리소스와 연관된 링크 정보를 클라이언트에게 제공한다. 클라이언트: 연관된 링크 정보를 바탕으로 리소스에 접근한다. 연관된 링크 정보 Relation Hypertext Reference) spring-boot-starter-hateoas 의존성 추가 https://spring.io/understanding/HATEOAS https://spring.io/guides/gs/rest-hateoas/ https://docs.spring.io/spring-hateoas/docs/current/reference/html/ 사용 Selflink추가 및 테스트 ObjectMapper 제공 우리가 제공하는 리소르를 Json으로 변환할 때, 사용하는 인터페이스 커스터마이징 : spring.jackson.* Jackson2ObjectMapperBuilder web만 의존성에 추가되어도 빈으로 등록된다. LinkDiscovers 제공 클라이언트 쪽에서 링크 정보를 Rel 이름으로 찾을때 사용할 수 있는 XPath 확장 클래스 CORS SOP과 CORS Single-Origin Policy 하나의 origin.. 오리진이 다르면 호출이 불가능 Cross-Origin Resource Sharing 서로 다른 origin끼리 리소스를 쉐어할 수 있는 방법을 제공하는 표준 Origin(아래 3개를 합친것이 하나의 origin) URI 스키마 (http, https) hostname (whiteship.me, localhost) 포트 (8080, 18080) @CrossOrigin reference 문서 미적용 포트가 다른 서버에 요청 @Controller나 @RequestMapping에 추가 WebMvcConfigurer 사용해서 글로벌 설정(여러 컨트롤러에서 적용)","link":"/2019/04/11/spring/springboot12/"},{"title":"스프링 부트 활용15 - 스프링 REST 클라이언트","text":"스프릥 부트 개념과 활용15(inflearn) - 백기선Spring boot 스프링 REST 클라이언트 스프링 부트가 REST 클라이언트 관련해서 직접적인 기능을 제공하는것은 아니다. REST 클라이언트는 스프링 프레임워크에서 지원한다. 스프링부트는 REST 클라이언트를 쉽게 사용할 수 있도록 빈을 등록해준다. REST Client, WebClient 빈을 등록하는것이 아니고, 빌더를 등록해준다. RestTemplate 와 WebClient RestTemplate Blocking I/O 기반의 Synchronous API RestTemplateAutoConfiguration 프로젝트에 spring-web 모듈이 있다면 RestTemplateBuilder를 빈으로 등록해준다. reference 문서 WebClient Non-Blocking I/O 기반의 Asynchronous API WebClientAutoConfiguration 프로젝트에 spring-webflux 모듈이 있다면 WebClient.Builder를 빈으로 등록해준다. reference 문서 비교 테스트 사정 동일한 작업 RestController 생성 및 매핑 hello → 스레드 타임슬립 5초 world → 스레드 타임슬립 3초 RestTemplate RestTemplate builder 주입받는다.(spring-boot-web 의존성 추가 시, 빈으로 등록된다.) builder를 통해 build 한다. 빌드된 RestTemplate를 통해 실행한다. 결과 5초 뒤 hello 출력 3초 뒤 world 출력 stopwatch가 꺼진다. WebClient Webflux를 의존성 추가한다. builder를 통해 build 한다. Mono를 세팅하고 subscribe() 한다. 결과 stopwatch 꺼진다. world 출력 hello 출력 비동기적인(Asyncronous한) 결과가 발생한다. API들의 유연한 조합을 위해선 WebClient를 사용하는 것을 추천한다. 좀 더 활용적인 예제를 보고 싶다면 .. 백선 youtube 커스터 마이징 RestTemplate 기본으로 java.net.HttpURLConnection 사용. 커스터마이징 로컬 커스터마이징 빌더 전에 baseUrl등 여러 설정이 가능하다. 글로벌 커스터마이징 전역적으로 사용하기 위해서.. RestTemplateCustomizer 빌더 자체를 빈 재정의 aphache httpclient 사용하기 의존성 주입 1234&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt;&lt;/dependency&gt; RestTemplate.setRequestFactory(); WebClient 기본으로 Reactor Netty의 HTTP 클라이언트 사용. 커스터마이징 로컬 커스터마이징 빌더 전에 baseUrl등 여러 설정이 가능하다. 글로벌 커스터마이징 전역적으로 사용하기 위해서.. WebClientCustomizer 빌더 자체를 빈 재정의","link":"/2019/04/17/spring/springboot15/"},{"title":"스프링 핵심기술01 - IoC 컨테이너와 빈","text":"스프링 프레임워크 핵심기술01(inflearn) - 백기선Springframework 백기선님의 Spring 시리즈 두번째 강좌 ‘스프링프레임워크 핵심기술‘ 수강을 시작하였습니다.해당강좌는 스프링프레임워크 입문에 이어서 좀 더 심화적인 과정이며, 초급에서 중급수준으로 넘어가는 사람들에게 추천하느 강좌라고 소개하고 있습니다.kosta에서 xml방식을 주로 사용하고 설명했었으나, 그 방법은 오래전에 사용되던 방법이라고 합니다..이번에는 Java Class방식을 다루도록 하겠습니다. IoC 컨테이너와 빈IoC 컨테이너 Inversion of Control 의존 관계 주입(Dependency Injection)이라고도 한다. 어떤 객체가 사용하는 의존객체를 직접 만들어 사용하는게 아니라 주입받아 사용하는 방법 스프링 초기에느 xml로 설정하는것이 대세였지만, annotation기반의 의존성 주입을 지원 최상위 인터페이스 : BeanFactory POJO객체POJO(Plain Old Java Object) 특정 자바모델이나, 프레임워크 등을 따르지 않는 자바객체 빈(Bean) IoC 컨테이너가 관리하는 객체 장점 의존성 관리 스코프 싱글톤 : 하나만 사용(항상 같은 객체) 프로토타입 : 매번 다른 객체 라이프사이클 인터페이스 ex) 빈이 생성될 때, 무언가를 행함 Application ContextBeanFactory를 상속받는다. 즉, BeanFactory의 기능을 하면서 추가적인 기능을 가진다. BeanFactory 기능 메세지 소스 처리기능 (18n) 리소스 로딩 기능 이벤트 발행기능 Application Context와 다양한 빈 설정방법스프링 IoC 컨테이너의 역할 빈 인스턴스 생성 의존 관계 설정 빈제공 ApplicationContext ClassPathXmlApplicationContext(XML) AnnotationConfigApplicationContext(Java)최근에는 아래와 같이 Java형식을 사용한다. ComponentScanAnnotation이 붙은 객체를 빈 등록 xml 설정 → context:componen-scan Java → @ComponentScan Autowired 필요한 의존 객체의 타입에 해당하는 빈을 찾아 주입한다. 사용위치 생성자 setter 필드 생성자 해당 타입의 빈이 한개인 경우 정상 해당 타입의 빈이 없는 경우 에러발생 해당 타입의 빈이 여러 개인 경우 @Primary 사용하면 여러 개인경우 해당 빈을 주입 setter, 필드 해당 타입의 빈이 한개인 경우 정상 해당 타입의 빈이 없는경우 required = false 설정 시, 없을경우 의존성을 주입하지 않는다. 해당 타입의 빈이 여러 개인 경우 @Primary 사용하면 여러 개인경우 해당 빈을 주입 @Qualifier 사용하여 빈이름 지정Qualifier을 사용으로 해결 할 수 있지만, @Primary를 쓰는것을 추천한다. 해당 타입의 빈을 모두 받고 싶을때 List&lt;&gt;로 받는다. 동작 원리 라이프사이클에 의해 동작 BeanPostProcessor 새로 만든 빈 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스 AutowiredAnnotationBeanPostProcessor extends BeanPostProcessor 스프링이 제공하는 @Autowired와 @Value 애노테이션 그리고 JSR-330의 @Inject 애노테이션을 지원하는 애노테이션 처리기. @Component와 ComponentScan컨포넌트 스캔 주요 기능 스캔 위치 설정(basePackage, basePackageClasses를 통해 위치 설정)Myservice는 @Service를 사용했지만 스캔 범위에서 벗어나기 때문에 빈으로 등록되지 않는다. 필터: 어떤 애노테이션을 스캔 할지 또는 하지 않을지 @Component다음 Annotation들은 @Component를 참조한다. @Repository @Service @Controller @Configuration 동작원리 실제 스캐닝은 ConfigurationClassPostProcessor라는 BeanFactoryPostProcessor에 의해 처리 됨. 즉, 다른 빈(직접등록하는)들이 등록되기전에 빈으로 등록된다. → 초기 시간이 오래걸릴 수 있다.(싱글톤타입의 경우) 펑션을 사용한 빈 등록 ComponentsSan을 대체하는 것이 아닌, 직접 빈을 등록하는 경우를 아래와 같이 사용하는것이 좋다. 12345678public static void main(String[] args) { SpringApplication app = new SpringApplication((SpringcoreApplication.class)); app.addInitializers((ApplicationContextInitializer&lt;GenericApplicationContext&gt;) ctx -&gt; ctx.registerBean(MyService.class)); app.run(args);} ComponentScan 범위 밖이지만 위와같은 방법으로 빈을 등록해줬기 때문에 빈으로 등록이된 것을 볼 수 있다. 빈의 스코프스코프 싱글톤 프로퍼티가 공유 여러곳에서 사용 시, thread safe 하지 않다. ApplicationContext 초기 구동시 인스턴스 생성 프로토 타입 @Scope를 사용하여 설정 Request Session WebSocket … 프로토타입 빈이 싱글톤 빈을 참조하면 아무 문제 없다. 싱글톤 빈이 프로토타입 빈을 참조하면 프로토타입 빈이 업데이트되지 않는다. (싱글톤처럼 계속 같은 값) 업데이트 scoped-proxy Object-Provider 예제 싱글톤 및 프로토타입 싱글톤 빈이 프로토타입을 참조할 때 프로토 타입은 전부 다른값을 가르켜야하는데 같은 값을 가르키는 문제가 발생(없데이트가 안됨) 프록시 시용 프록시를 사용하여 상기 문제를 해결하였다. ScopedProxyMode의 Default는 프록시를 사용하지 않는다.우리예제에서는 class로 설정되어 있어 TARGET_CLASS 로 변경해주었다. Object provider 사용 코드자체를 건드리기때문에 추천하지는 않는다. Environment ApplicationContext는 EnvironmentCapable을 상속받는다. Environment가 가지는 기능 Profile Property getEnvironment()를 통해 확인할 수 있다.123ApplicationContext ctx;Environment environment = ctx.getEnvironment(); Profile 빈들의 그룹 특정 상황에서의 환경을 활성화하고 싶을 때, 사용한다. ex)테스트 환경에서는 A라는 빈을 사용하고, 배포 환경에서는 B라는 빈을 쓰고 싶다. 이 빈은 모니터링 용도니까 테스트할 때는 필요가 없고 배포할 때만 등록이 되면 좋겠다. Profile 정의하기 클래스에 정의 @Configuration @Profile(“[profile_name]“) @Component @Profile(“[profile_name]“) 메소드에 정의 Bean @Profile(“[profile_name]“) Profile 설정하기 -Dspring.prifiles.active=”[profile_name]“ ActivePrifiles Profile 표현식 ! (not) &amp; (and) | (or) Property 다양한 방법으로 정의할 수 있는 설정값 Environment의 역할은 프로퍼티 소스 설정 및 프로퍼티 값 가져외기 우선순위 StandardServletEnvironment의 우선순위 ServletConfig 매개변수 ServletContext 매개변수 JNDI (java:comp/env/) JVM 시스템 프로퍼티 (-Dkey=”value”) JVM 시스템 환경 변수 (운영 체제 환경 변수) @PropertySource Environment를 통해 프로퍼티 추가하는 방법 JVM 시스템 프로퍼티 vs @PropertySource MessageSource국제화(i18n) 기능을 제공하는 인터페이스 ApplicationContext는 MessageSource인터페이스를 상속한다. 스프링 부트를 사용한다면 별다른 설정 필요없이 messages.properties 사용할 수 있음 messages.properties messages_ko_KR.properties 릴로딩 기능이 있는 메세지 소스 사용하기 직접 빈등록을 해준다. 1234567891011@Beanpublic MessageSource messageSource(){ ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasename(&quot;classpath:/messages&quot;); messageSource.setDefaultEncoding(&quot;UTF-8&quot;); messageSource.setCacheSeconds(3); /*최대3초까지만 캐싱*/ return messageSource;} 테스트 코드 작성 1234567891011121314151617@Componentpublic class AppRun implements ApplicationRunner { @Autowired MessageSource messageSource; @Override public void run(ApplicationArguments args) throws Exception { while (true) { Locale.setDefault(Locale.CANADA); System.out.println(messageSource.getMessage (&quot;greeting&quot;, new String[]{&quot;Bong!&quot;}, Locale.KOREA)); System.out.println(messageSource.getMessage (&quot;greeting&quot;, new String[]{&quot;Bong!&quot;}, Locale.getDefault())); Thread.sleep(1000); /*1초마다 찍어*/ } }} 실행결과 ApplicationEventPublisher 이벤트 프로그래밍에 필요한 인터페이스 제공 옵저버 패턴 구현체 옵저버 패턴객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴 이벤트 만들기 ApplicationEvent 상속 스프링 4.2 부터는 이 클래스를 상속받지 않아도 이벤트로 사용할 수 있다. 스프링 프레임워크의 클래스를 상속받지 않아 깔끔한 POJO객체가 되었다. 스프링 프레임워크의 철학 → 비침투성 이벤트 발생시키기 ApplicationEventPublisher.publishEvent(); 이벤트 처리하는 방법 ApplicationListener&lt;이벤트&gt; implements한 클래스 만들어서 빈으로 등록하기. 스프링 4.2 부터는 @EventListener를 사용해서 빈의 메소드에 사용할 수 있다. 이벤트 핸들러가 여러개일 경우 모두 실행 기본적으로는 순차적 (순서는 잘모르겠으나, 순처작으로 실행된다.) 순서를 정하고 싶다면 @Order와 함께 사용. 비동기적으로 실행하고 싶다면 @Async와 함께 사용.(멀티쓰레드) 스프링이 제공하는 기본 이벤트 ContextRefreshedEvent: ApplicationContext를 초기화 했더나 리프래시 했을 때 발생. ContextClosedEvent: ApplicationContext를 close()하여 싱글톤 빈 소멸되는 시점에 발생. ContextStartedEvent: ApplicationContext를 start()하여 라이프사이클 빈들이 시작신호를 받은 시점에 발생. ContextStoppedEvent: ApplicationContext를 stop()하여 라이프사이클 빈들이 정지신호를 받은 시점에 발생. RequestHandledEvent: HTTP 요청을 처리했을 때 발생. ResourceLoader 리소스를 읽어오는 기능을 제공하는 인터페이스 ApplicationContext는 ResourceLoader를 상속받는다.","link":"/2019/03/20/spring/springframework-core01/"},{"title":"스프링 핵심기술02 - Resource / Validation","text":"스프링 프레임워크 핵심기술02(inflearn) - 백기선Springframework Resource 추상화 org.springframework.core.io.Resource 스프링 내부에서 많이 사용하는 인터페이스. java.net.URL을 추상화 한 것. 추상화 한 이유 클래스패스 기준으로 리소스 읽어오는 기능 부재 ServletContext를 기준으로 상대 경로로 읽어오는 기능 부재 새로운 핸들러를 등록하여 특별한 URL 접미사를 만들어 사용할 수는 있지만 구현이 복잡하고 편의성 메소드가 부족하다. 상속 받은 인터페이스 주요 메소드 getInputStream() exitst() isOpen() getDescription(): 전체 경로 포함한 파일 이름 또는 실제 URL 구현체 UrlResource: java.net.URL 참고, 기본으로 지원하는 프로토콜 http, https, ftp, file, jar. ClassPathResource: 지원하는 접두어 classpath: FileSystemResource ServletContextResource: 웹 애플리케이션 루트에서 상대 경로로 리소스 찾는다. 대부분 ServletContextResource를 사용할 것이다. 리소스 읽어오기 Resource의 타입은 locaion 문자열과 ApplicationContext의 타입에 따라 결정 된다. ClassPathXmlApplicationContext -&gt; ClassPathResource FileSystemXmlApplicationContext -&gt; FileSystemResource WebApplicationContext -&gt; ServletContextResource ApplicationContext의 타입에 상관없이 리소스 타입을 강제하려면 java.net.URL 접두어(+ classpath:)중 하나를 사용할 수 있다. classpath:me/whiteship/config.xml -&gt; ClassPathResource file:///some/resource/path/config.xml -&gt; FileSystemResource 좀 더 명시적으로 사용하기 위해 이 방법을 추천한다. 예제 WebApplicationContext인것으로 보아 기본적으로 ServletContextResource 이어야한다. classpath: 라는 prefix를 사용했기 때문에 ClassPathResource가 나온다. 여기서 만약 classpath라는 prefix를 지운다면… ServletContextResource 가 나온다. 스프링부트가 띄어주는 기본적인 내장 톰캣은 ContextPath가 지정되어있지 않다.때문에 resource파일이 존재하지 않는다고 결과가 나온다. 스프링부트 기반으로 어플리케이션을 작성할 시, 특히 JSP를 사용하지 않는경우 classpath 접두어 사용을 추천한다. Validation 추상화 애플리케이션에서 사용하는 객체 검증용 인터페이스. 어떤한 계층과도 관계가 없다. → 모든 계층(웹, 서비스, 데이터)에서 사용해도 좋다. DataBinder에 들어가 바인딩 할 때 같이 사용되기도 한다. 인터페이스 boolean supports(Class clazz): 어떤 타입의 객체를 검증할 때 사용할 것인지 결정한다.(검증 대상) void validate(Object obj, Errors e): 실제 검증 로직을 이 안에서 구현한다.(검증 내용) 구현할 때 ValidationUtils 사용하면 편리하다. ValidationUtils를 사용하지 않고, rejectValue를 통해서 직접 만들어 사용할 수 있다.특정필드값에 대한 검증이 아니라면 reject사용 스프링 부트 2.0.5 이상 버전을 사용할 때 JSR-380(Bean Validation 2.0.1) 구현체로 hibernate-validator 사용.() LocalValidatorFactoryBean 빈으로 자동 등록","link":"/2019/03/21/spring/springframework-core02/"},{"title":"스프링 핵심기술03 - 데이터 바인딩","text":"스프링 프레임워크 핵심기술03(inflearn) - 백기선Springframework 데이터바인딩 추상화 기술적인 관점: 프로퍼티 값을 타겟 객체에 설정하는 기능 사용자 관점: 사용자 입력값을 애플리케이션 도메인 모델에 동적으로 변환해 넣어주는 기능. 해석하자면: 입력값은 대부분 “문자열”인데, 그 값을 객체가 가지고 있는 int, long, Boolean, Date 등 심지어 Event, Book 같은 도메인 타입으로도 변환해서 넣어주는 기능. Spring web MVC에만 특화된것이 아니다. 여러 Interface로 추상화 했다. PropertyEditor 스프링 3.0 이전까지 DataBinder가 변환 작업에 사용하던 인터페이스 쓰레드-세이프 하지 않음 (상태 정보 저장 하고 있음, 따라서 싱글톤 빈으로 등록하면 안된다.) 여러 쓰레드들이 상태정보를 공유한다. 만약 빈을 사용한다면 Thread-Scope로 사용할 수 있겠지만, 빈으로 등록 안하는것이 좋다. 그럼 어떻게 사용하는가→ InitBinder를 사용하는것이 좋다. Object와 String 간의 변환만 할 수 있어, 사용 범위가 제한적이다. 예제 객체 생성 PropertyEditor를 implements 하는것은 오버라이딩할 메소드가 많다.PropertyEditorSupport를 상하여 필요에 맞도록 적용 이벤트 컨트롤러 작성 테스터 작성매칭되는 에디터가 없어서 에러가 발생한다. 앞선 설명과 같이 빈으로 등록하지 않고 InitBinder사용하여 메소드 생성 및 테스트를 실행한다.Evnet 클래스를 EventEditor를 사용하여 데이터바인딩하겠다는 뜻 Converter와 FormatterConverter S 타입을 T 타입으로 변환할 수 있는 매우 일반적인 변환기. 상태 정보 없음 = Stateless = 쓰레드세이프 (→ bean으로 등록이 가능하다.) ConverterRegistry에 등록해서 사용(빈으롱 등록하지 않았을 때 사용방법이다.) 기본적인 Integer 등의 타입은 기본적으로 지원해준다. Formatter PropertyEditor 대체제 Object와 String 간의 변환을 담당한다. 쓰레드 세이프하여 빈등록이 가능하다. 즉, 다른빈들도 등록이 가능하다.(예시의 이미지의 MessageSource와 같은) 문자열을 Locale에 따라 다국화하는 기능도 제공한다. (optional) FormatterRegistry에 등록해서 사용(빈으롱 등록하지 않았을 때 사용방법이다.) ConversionService 실제 변환 작업은 이 인터페이스를 통해서 쓰레드-세이프하게 사용할 수 있음. 스프링 MVC, 빈 (value) 설정, SpEL에서 사용한다. DefaultFormattingConversionService FormatterRegistry는 ConverterResgistry를 상속하여, Converter의 기능도 할 수 있다.따라서, Formatter를 쓰는것을 추천한다. ConversionService 여러 기본 컴버터와 포매터 등록 해 줌. 스프링 부트 웹 애플리케이션인 경우에 DefaultFormattingConversionSerivce를 상속하여 만든 WebConversionService를 빈으로 등록해 준다. WebConversionService의 경우 좀 더 많은 기능을 제공한다. (money, JODA타임 등) Formatter와 Converter 빈을 찾아 자동으로 등록해 준다. 테스트방법 계층형 테스트로 웹과 관련된 빈만 테스트로 등록해준다.주로 Controller만.. 즉, Converter나 Formatter 제대로 등록이 안되면 오류발생직접등록이 필요하다. 등록되어있는 ConversionService 많은 converter와 formatter가 기본적으로 등록되어있다.","link":"/2019/03/22/spring/springframework-core03/"},{"title":"스프링 핵심기술04 - SpEL","text":"스프링 프레임워크 핵심기술04(inflearn) - 백기선Springframework SpEL(스프링 Expression Language)스프링 EL이란? 객체 그래프를 조회하고 조작하는 기능을 제공한다. Unified EL과 비슷하지만, 메소드 호출을 지원하며, 문자열 템플릿 기능도 제공한다. OGNL, MVEL, JBOss EL 등 자바에서 사용할 수 있는 여러 EL이 있지만, SpEL은 모든 스프링 프로젝트 전반에 걸쳐 사용할 EL로 만들었다. 스프링 3.0 부터 지원. 문법 #{“표현식”} ${“프로퍼티”} 표현식은 프로퍼티를 가질 수 있지만, 반대는 안 됨. #{${my.data} + 1} 레퍼런스 참고 실제로 어디서 쓰나? @Value 애노테이션 @ConditionalOnExpression 애노테이션 스프링 시큐리티 메소드 시큐리티, @PreAuthorize, @PostAuthorize, @PreFilter, @PostFilter XML 인터셉터 URL 설정 … 스프링 데이터 @Query 애노테이션 Thymeleaf … SpEL 구성 ExpressionParser parser = new SpelExpressionParser() 예제에서 확인 StandardEvaluationContext context = new StandardEvaluationContext(bean) Expression expression = parser.parseExpression(“SpEL 표현식”) String value = expression.getvalue(context, String.class) 예제","link":"/2019/03/26/spring/springframework-core04/"},{"title":"스프링 핵심기술06 - Null-safety","text":"스프링 프레임워크 핵심기술06(inflearn) - 백기선Springframework Null-safety 스프링 프레임워크 5에 추가된 Null 관련 애노테이션 @NonNull @Nullable @NonNullApi (패키지 레벨 설정) @NonNullFields (패키지 레벨 설정) 목적 (툴의 지원을 받아) 컴파일 시점에 최대한 NullPointerException을 방지하는 것 IDE설정 (IntelliJ) preference → Compiler → Configure annotation → annotation추가 NonNull에 Nonnull Nullable에 Nullable 추 IDE 재시작 @패키지 레벨 설정 package-info 파일생성 @NonNullapi or NonNullFields 어노테이션 추가 해당 어노테이션을 사용하면 패키지 전체 NonNull적용, 널이 필요한 경우 Nullable 어노테이션 사용하여 null값 가능하도록 활용할 수 있다. SpringFramework 핵심기술 강좌를 모두 수강하였습니다.강의 내용들은 대부분 해당 어노테이션 및 기능들이 어떻게 구현되는지 설명이었습니다.대부분 기능에 대해서 알고는 있었지만, 어떻게 구현되는지 몰랐던 저에게는 매우 알찬 강의였으며 만족스러웠습니다.😆 학원에서 한번 배운 것이 이해하는데 큰 도움이 된 것 같습니다.해당 강좌를 들으시려는 분들에게 먼저 책 등을 이용하여 스프링을 사용해보고 수강하는것을 추천드립니다!😀","link":"/2019/03/27/spring/springframework-core06/"},{"title":"스프링 핵심기술05 - 스프링 AOP","text":"스프링 프레임워크 핵심기술05(inflearn) - 백기선Springframework AOP 개념 Aspect-oriendted Programming (AOP)은 OOP를 보완하는 수단으로, 흩어진 Aspect를 모듈화 할 수 있는 프로그래밍 기법. 주요개념 Aspect : 분류된 모듈 Target : 대상ex) class A, B, C Advice : 해야할 일 Pointcut : 어디에 적용해야 하는지 정보를 가지고 있다. Join Point : 메소드 실행 시점 (끼어들 수 있는 시점) AOP 구현체 ↑ implementation으로 검색 시, 언어별 구현체들을 확인할 수 있다. 자바 AspectJ 스프링 AOP AOP 적용방법 컴파일 java파일을 class파일로 만들때 조작된 바이트 파일을 생성 로드타임 AspectJ에서 적용 다양한 join point 제공 로트 타임 위빙 : 로딩할 때, 끼워넣는다. 런타임 SpringAOP에서 적용 빈을 만들 때, 즉 런타임시에 프록시 빈을 만들어서 구현 (뒤에서 다시 설명 할 예정) 별도의 설정이 필요없고, 문법이 쉽다. 프록시 기반 AOP스프링 AOP 특징 프록시 기반의 AOP 구현체 스프링 빈에만 AOP를 적용할 수 있다. 모든 AOP 기능을 제공하는 것이 목적이 아니라, 스프링 IoC와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제에 대한 해결책을 제공하는 것이 목적. 프록시 패턴 기존 코드를 건드리지 않고 접근제어 부가기능 예제 프록시 미적용 프록시 적용 문제점 매번 프록시 클래스를 작성해야 하는가? 여러 클래스 여러 메소드에 적용하려면? 객체들 관계도 복잡하고… 이러한 문제점 때문에 스프링 AOP가 등장하였다. 스프링 IoC 컨테이너가 제공하는 기반 시설과 Dynamic 프록시를 사용하여 여러 복잡한 문제 해결. 동적 프록시: 동적으로 프록시 객체 생성하는 방법 자바가 제공하는 방법은 인터페이스 기반 프록시 생성. CGlib은 클래스 기반 프록시도 지원. 스프링 IoC: 기존 빈을 대체하는 동적 프록시 빈을 만들어 등록 시켜준다. 클라이언트 코드 변경 없음. AbstractAutoProxyCreator implements BeanPostProcessor @AOP애노테이션 기반의 스프링 AOP 의존성 추가 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; Aspect 정의 @Aspect 빈으로 등록해야 하니까 (컴포넌트 스캔을 사용한다면) @Component도 추가. 포인트컷 정의 @Pointcut(표현식) 주요 표현식 execution @annotation bean 포인트컷 조합 &amp;&amp;, ||, !","link":"/2019/03/26/spring/springframework-core05/"},{"title":"스프링 데이터 JPA01 - 관계형 데이터 베이스와 자바, ORM","text":"스프링 데이터 JPA(inflearn) - 백기선핵심 개념 이해 스프링 웹 MVC와 함께 JPA 강좌를 수강하고 있습니다.JPA는 Java Persistence API ORM(Object Relational Mapping)을 위한 표준 기술입니다.ORM이란 RDB 테이블을 객체지향적으로 사용하기 위한 기술을 말합니다.모든 예제는 github에 올리고 있습니다. 관계형 데이터 베이스와 자바 관계형 데이터 베이스 현재 가장 많이 사용되고 있는 데이터베이스의 한 종류 테이블(table)로 이루어져 있으며, 이 테이블은 키(key)와 값(value)의 관계를 나타낸다. 데이터의 종속성을 관계(relationship)로 표현하는 것이 관계형 데이터베이스의 특징 JDBC : 데이터 베이스와 자바의 연결고리 어플리케이션에 데이터를 영속화(persistence)하기 위함 기본 JDBC를 사용한 프로젝트 예제 메이븐 프로젝트 생성 의존성 추가 12345&lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;version&gt;42.2.5&lt;/version&gt;&lt;/dependency&gt; 커넥션 생성 1234567891011public class Application { public static void main(String[] args) throws SQLException { String url = &quot;jdbc:postgresql://localhost:5432/springdata&quot;; String username = &quot;bong&quot;; String password = &quot;pass&quot;; try (Connection connection = DriverManager.getConnection(url, username, password)){ } }} try with resource : 자바7 이부터 사용할 수 있는 문법으로, try 문 사용시 ()안의 리소스를 정리해준다. (close해줌) maven 프로젝트로 생성 시, 자바 5버전으로 생성되었으 확률이 크다. 오류 발생시 project Structure에서 자바7버전 이후 버전으로 변경해준다. 그래도 오류가 발생한다면.. pom.xml에서 자바 버전을 설정해준다.(참고) 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; sql 작성 및 커넥션 사용 참고 : postgresql 사용법 무엇이 문제인가? SQL을 실행하는 비용이 비싸다. SQL이 데이터베이스 마다 다르다. 스키마를 바꿨더니 코드가 너무 많이 바뀌네… 반복적인 코드가 너무 많아. 당장은 필요가 없는데 언제 쓸 줄 모르니까 미리 다 읽어와야 하나… ORM(Object-Relation Mapping) ORM은 애플리케이션의 클래스와 SQL 데이터베이스의 테이블 사이의 맵핑 정보를 기술한 메타데이터를 사용하여, 자바 애플리케이션의 객체를 SQL 데이터베이스의 테이블에 자동으로 (또 보다 비침투적으로) 영속화 해주는 기술이다.JDBC와 도메인 모델 사용의 차이점 JDBC 사용 12345678try(Connection connection = DriverManager.getConnection(url, username, password)) { System.out.println(&quot;Connection created: &quot; + connection); String sql = &quot;INSERT INTO ACCOUNT VALUES(1, &apos;keesun&apos;, &apos;pass&apos;);&quot;; try(PreparedStatement statement = connection.prepareStatement(sql)){ statement.execute(); }} 도메인 모델 사용 12Account account = new Account(&quot;bong&quot;, &quot;pass&quot;);accountRepository.save(account); JDBC 대신 도메인 모델 사용하려는 이유 객체 지향 프로그래밍의 장점을 활용하기 좋으니까. 각종 디자인 패턴 코드 재사용 비즈니스 로직 구현 및 테스트 편함(코드 간결) 도메인 모델을 사용하기 위해서 ORM툴인 JPA를 쓴다고 할 수 있다. ORM툴 사용의 장단점 장점 생산성 유지보수성 성능 하나의 예를 들면.. Hibernate는 객체와 테이블에 들어있는 데이터 사이의 캐쉬가 존재한다. 불필요한 쿼리를 날리지 않는다. 예).. 한 트랜잭션안에서 하나의 데이터에 대하여 하나의 트랜잭션에서 값을 여러번 변경했을 때, 마지막 값이 초기값과의 변경사항을 체크하고 쿼리를 날린다. 밴더 독립성 DB의 종류에 따라서 변경될 코드가 없다.(방언(diarect)만 설정) 단점 학습비용 sql을 포함한 학습이 반드시 필요하다. ORM: 패러다임 불일치객체를 릴레이션에 맵핑하려니 발생하는 문제(ORM으로 해결이 가능하다.) 밀도(Granularity) 문제 객체 다양한 크기의 객체를 만들 수 있음. 커스텀한 타입 만들기 쉬움. 릴레이션 테이블 기본 데이터 타입 (UDT는 비추) 서브타입(Subtype) 문제 객체 상속 구조 만들기 쉬움 다형성 릴레이션 테이블 상속이라는게 없음 상속 기능을 구현했다 하더라도 표준 기술이 아님 다형적인 관계를 표현할 방법이 없음 식별성(Identity) 문제 객체 레퍼런스 동일성 (==) 인스턴스 동일성 (equals() 메소드) 릴레이션 주키 (primary key) 관계(Association) 문제 객체 객체 레퍼런스로 관계 표현 근본적으로 ‘방향’이 존재 한다. 다대다 관계를 가질 수 있음 릴레이션 외래키(foreign key)로 관계 표현 ‘방향’이라는 의미가 없음. (그냥 Join으로아무거나 묶을 수 있음.) 태생적으로 다대다 관계를 못만들고, 조인 테이블 또는 링크 테이블을 사용해서 두개의 1대다 관계로 풀어야 함 데이터 네비게이션(Navigation)의 문제 객체 레퍼런스를 이용해서 다른 객체로 이동 가능 콜렉션을 순회할 수도 있음. 릴레이션 하지만 그런 방식은 릴레이션에서 데이터를 조회하는데 있어서 매우 비효율적이다. 데이터베이스에 요청을 적게 할 수록 성능이 좋다.(따라서 Join을 쓴다.) 하지만, 너무 많이 한번에 가져오려고 해도 문제다. 그렇다고 lazy loading을 하자니 그것도 문제다. (n+1 select)","link":"/2019/04/29/spring/springjpa01/"},{"title":"스프링 프레임워크 입문01 - IOC, IOC컨테이너","text":"스프링 프레임워크 입문01(inflearn) - 백기선Springframework kosta에서 스프링 프레임워크에 대해서 배웠지만.. 저는 스프링 프레임워크가 정확히 무엇인지 잘 모르고 있다는 생각이 들었습니다.책을 사서 공부해야 하나, 인터넷 강의를 들어야하나 고민을 했는데 책보다는 시청각 자료와 친했던 저는 강을 선택했습니다..여러 강좌들을 고민하다가 유투브에서 종종 보았던 백기선님의 강의가 눈에 들어왔습니다.입문강좌를 비롯해 핵심기술, 웹MVC, 스프링 부트의 개념과 활용, Rest API개발 까지 여러 스프링에대한 여러 강의들이 있는것이 마음에 들었고, 저는 충동적으로 강의를 모두 구매하였습니다…😂기억보단 기록을 남기기 위해 강의를 듣고 정리하며 초보 개발자의 시선에서 기록을 남겨보려 합니다. 😀예제는 spring-projects/spring-petclinic 으로 진행하였습니다. (petclinic) IoC(Inversion of Control)IOC란 Inversion of Control 즉, 제어의 뒤밖임이라고 직역할 수 있다.의존성에 관하여 말하자면 기존에는 자신이 필요한 객체에 대하여 자신이 만들어서 사용하였다.그러나 스프링을 사용하면 보다 간단하게 필요한 객체를 생성자에 매개변수로 주었다고 생각하고 사용할 수있다. 기존에 스프링 사용전에는 다음과 같은 코드를 사용했다면…1234567class OwnerController { private OwnerRepository repo; class OwnerController { private OwnerRepository repository = new OwnerRepository(); }} 스프링에서는 누군가 repository를 주었다고 생각하고 다음과 같이 작성할 수 있다.1234567class OwnerController { private OwnerRepository repo; public OwnerController(OwnerRepository repo) { this.repo = repo; } // repo를 사용합니다. } IoC 컨테이너 빈(Bean)을 만들어주고 엮어주고 제공해준다. 이 부분을 설명하실 때, 충격받았던것이 아주 오래전에는 web.xml을 사용하여 설정해주었으나 sevlet3.5부터 Java설정을 지원하면서 xml이 사라졌고 스프링부트가 나오면서 그마저도 기본설정으로 감춰줘있다고 한 부분이다.kosta에서 교육을 받을 때, xml에 이것저것 Bean설정 및 여러 설정을 해주었는데… 아주 오래된 구식방법을 사용하고 있었던것 같다.😂 Bean 스프링 IoC 컨테이너가 관리하는 객체 Bean 등록 Componnent Scanning(@Repository, @Service, @Controller) 직접등록(xml or Java) Componnent 아래 Repository, Service, Controller 모두 있다. 직접등록방법 1234@Beanpublic String young(){ return &quot;Young Rack&quot;;} Bean 사용12@Autowired // or @InjectString young @Autowired 해당이름의 Bean 객체를 찾아서 넣어준다. @Inject @Autowired 와 Inject의 차이점@Autowired와 @Inject의 경우에도 @Qualifier 어노테이션을 사용하면, 타입 이외의 방법으로도 연결 할 수 있다.123@Autowired@Qualifier(&quot;chicken&quot;)pirvate Brid penguin; //chicken타입으로 연결 의존성 주입(Dependency Injection) @Autowired, @Injection을 붙이는 우치 생성자 필드 Setter 최근버전은 어떤빈이되는 클래스의 생성자가 1개만 존재하며 생성자안의 매개변수 타입이 빈으로 등록되어있다면 Autowired를 생략할 수 있다. DI의 우선순위 생성자 → Setter(있다면) → 필드 반드시 필요하다면 생성자를 만들어서 의존성 주입 Setter가 있다면 Setter에 의존성 주입(필요하지 않은 Setter를 만들어 의존성을 주입하면 Setter에 의해 의존성 변경의 여지를 주는것으로 위험한 코딩이다.) Setter가 없다면 필드","link":"/2019/03/05/spring/springframework-introduction01/"},{"title":"스프링 부트 활용13 - 스프링 데이터","text":"스프릥 부트 개념과 활용13(inflearn) - 백기선Spring boot 스프링 데이터 인메모리 데이터베이스 스프링 부트가 지원하는 인-메모리 데이터베이스 H2 (추천, 콘솔 때문에…) HSQL Derby Spring-JDBC가 클래스패스에 있으면 자동 설정이 필요한 빈을 설정 해줍니다. DataSource JdbcTemplate 스프링부트는 인메모리 데이터베이스 의존성이 설정이 되있고, Data Source를 설정하지 않으면 스프링 부트는 자동으로 인메로리 데이터베이스를 설정해준다. 인-메모리 데이터베이스 기본 연결 정보 확인하는 방법 URL: “testdb” username: “sa” password: “” table 생성 예시 createStatement() 데이터베이스로 SQL 문을 보내기 위한 SQLServerStatement 개체를 만듭니다. 위와 같이 connection객체에서 getMetaData를 통해서도 연결정보를 확인할 수 있다. H2 콘솔 사용하는 방법 spring-boot-devtools를 추가하거나… spring.h2.console.enabled=true 만 추가. /h2-console로 접속 (이 path도 바꿀 수 있음) Data Source뿐만 아니라 JdbcTemplate도 빈으로 등록됨으로 사용할 수 있다. Jdbc api(connection등)를 사용하는것보다 JdbcTemplate를 사용하는것을 추천한다. 보다 간결한 코드를 사용한다. 보다 안전한다. (리소스 반납처리가 잘 되어있다.(try catch finally등)) 보다 가독성 좋은 에러메세지도 확인할 수 있다. MySQL 지원하는 DBCP(DataBaseConnectionPool) HikariCP (기본) 기본적인 설정 Tomcat CP Commons DBCP2 JDBC와 DBCPJava에서 Database와 연결하기 위해선 JDBC를 필요로 하며, JDBC를 이용해 생성한 Connection을 효율적으로 활용하기 위해 Connection 객체를 관리하는 것을 DBCP 스프링 부트 DBCP 설정 spring.datasource.hikari.* spring.datasource.tomcat.* spring.datasource.dbcp2.* DBCP 확인 MySQL 커넥터 의존성 추가 1234&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; MySQL 실치 및 서버 실행 (도커사용) 12docker run -p 3306:3306 --name mysql_boot -e MYSQL_ROOT_PASSWORD=1 -e MYSQL_DATABASE=springboot -e MYSQL_USER=keesun -e MYSQL_PASSWORD=pass -d mysql docker를 실행한다. (mysql 이미지가 없으면 다운받는다.) 컨테이너 3306포트를 로컬호스트 3306포트에 연결 컨테이너이름 = mysql_boot MYSQL_ROOT 비밀번호 : 1 사용자 : bong 비밀번호 : pass MySQL bash로 실행 1docker exec -i -t mysql_boot bash MySQL 접속 123mysql -u root -p/*or*/mysql -u &lt;username&gt; -p root로 접속 시 root 비밀번호(1), user로 접속 시 user비밀번호(pass) MySQL 명령어 참고 블로그 MySQL용 Datasource 설정 spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useSSL=false spring.datasource.username=keesun spring.datasource.password=pass MySQL 라이센스 (GPL) 주의 소스 코드 공개 의무 여부 확인 유료 대안 MySQL 대신 MariaDB 사용 검토 무료지만 MariaDB 또한 GPL로 소스 코드 공개가 필요하다. PostgreSQL 사용이 가장 안전하다. 오픈소스 라이센스GPL : 소스코드 공개 의무 OMIT : 소스코드 공개 의무 X PostgreSQL(포스트그레스) 의존성 추가 1234&lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt;&lt;/dependency&gt; PostgreSQL 설치 및 서버 실행 (docker) 12docker run -p 5432:5432 -e POSTGRES_PASSWORD=pass -e POSTGRES_USER=bong -e POSTGRES_DB=springboot --name postgres_boot -d postgres mysql과 같은 방식으로 진행한다. PostgreSQL bash로 실행 1docker exec -i -t postgres_boot bash PostgreSQL 접속 1234567891011121314/*유저를 postgres로 변경*/su - postgres/*DB접속*/psql -d &lt;DBname&gt; -U &lt;username&gt;/*password 를 쓰고 싶다면*/psql -d &lt;DBname&gt; -U &lt;username&gt; -W/*전체 데이터베이스 조회*/\\l or \\list/*전체 테이블 조회*/\\dt DB접속이 안될 때 (role에러) 1psql -U &lt;username&gt; &lt;DBname&gt; ex) psql -U bong springboot 맥북도 발생한다.. os문제는 아닌것 같음. PostgreSQL용 Datasource 설정 spring.datasource.url=jdbc:postgresql://localhost:5432/springboot spring.datasource.username=bong spring.datasource.password=pass Postgres 주의사항 user명칭을 사용할 수 없다. user가 키워드로 사용된다. org.postgresql.jdbc.PgConnection.createClob() is not yet implemented 경고 spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true프로퍼티에 추 인텔리제이 DataBase기능 활용 docker가 실행되고 있는 상태에서 진행 우측의 DataBase 탭에서 progreSQL을 추가한다. DB이름 , user, password 설정 테이블 더블클릭으로 내용 확인 가능하며 쿼리문도 작성하여 확인할 수 있다. 스프링 데이터 JPA ORM(Object-Relational Mapping)과 JPA (Java Persistence API) 객체와 릴레이션을 맵핑할 때 발생하는 개념적 불일치를 해결하는 프레임워크 http://hibernate.org/orm/what-is-an-orm/ JPA: ORM을 위한 자바 (EE) 표준 스프링 데이터 JPA JPA 표준스펙을 아주 쉽게 사용할 수 있게 추상화 시켜놓은것. 구현체는 hibernate를 사용 Repository 빈 자동 생성 쿼리 메소드 자동 구현 @EnableJpaRepositories (스프링 부트가 자동으로 설정 해줌.) SDJ -&gt; JPA -&gt; Hibernate -&gt; Datasource 기존 jdbc를 모두 활용할 수 있다. (의존성을 보면 확인이 가능하다.) JPA 연동 스프링 데이터 JPA 의존성 추가 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 스프링 데이터 JPA 사용하기 @Entity 클래스 만들기 @GernerateValue 자동으로 값을 생성 lombok을 사용하면 보다 쉽게 만들 수 있다. Lombok자바에서 Model Object를 만들 때, getter/setter, Tostring등 반본적으로 사용되는 코드를 어노테이션을 통해 줄여주는 라이브러리참고 블로그 : 갓대희의 작은공간 Repository 만들기 Interface extends JpaRepository 스프링 데이터 리파지토리 테스트 만들기 슬라이스 테스트를 할때는 인메모리 데이터베이가 반드시 필요하다. H2 DB를 테스트 의존성에 추가하기12345&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; @DataJpaTest (슬라이스 테스트) 작성 레퍼지토리를 포함한 레퍼지토리와 관련된 빈들만 등록을 하여 테스트 DataSource JdbcTemplate 해당 Repository … 테스트 결과 어플리케이션 정상 작동을 위해서는 DataBase설정이 필요하다. DB 드라이버 의존성 추가(PostgreSQL) DataSource 설정 SpringBootTest 적용 시, 모든 빈들이 등록됨으로 프로퍼티값들도 등록된다.(즉, postgreSQL이 적용된다.) 테스트 DB가 하나 필요하게 됨으로 추천하지 않는다. JPA 활용 기본 JPA api Repostiry에 원하는 메소드 추가 후 활용 직접 SQL쿼리문을 사용하고 싶을 때 Optional 사용 데이터베이스 초기화 스키마 자동생성 테스트 코드에선 스키마가 자동 생성된다.(embeded DB사용) 실제로 구동했을 때, 스키마에 생성되지 않는다. JPA를 사용한 데이터베이스 초기화 spring.jpa.hibernate.ddl-auto update : 수정 및 추가된것만 수정된다. 데이터가 남기때문에 자주 사용 컬럼명이 변경되는것은 알지못함으로 필드명은 변경하면 안된다. create : 있는것을 지우고 만든다. create-drop : 생성하고 애플리케이션 종료시 지워준다. spring.jpa.generate-ddl=true 기본값이 false이기 때문에 설정해주지 않으면 상기사항이 적용되지 않는다. 운영 DB의 경우 validate 설정이 보다 안정적이다. spring.jpa.hibernate.ddl-auto=validatespring.jpa.generate-ddl=false 릴레이션이 잘 설정되어있는지 확인해준다. 클래스와 잘 매핑되있으면 오류없이 실행된다. 매핑이 되지않으면 오류발생 따라서 DB수정이 필요 시, 업데이트 환경으로 진행 SQL 스크립트를 사용한 데이터베이스 초기화 테스트 코드를 돌려 쿼리문을 사용하면 간편하다. jpa관 설정들은 테스트 코드에도 적용됨으로 주의할 것. schema.sql 또는 schema-${platform}.sql empty값이 아니어야 한다. data.sql 또는 data-${platform}.sql schema.sql 먼저 호출된다. ${platform} 값은 spring.datasource.platform 으로 설정 가능. schema.sql과 공존하면 우선순위는 schema.sql schema.sql과 공존할 때, 둘 다 empty값이 아니어야한다. 데이터베이스 마이그레이션 Flyway와 Liquibase가 대표적인데, Flyway를 사용하겠습니다 의존성 추가 1234&lt;dependency&gt; &lt;groupId&gt;org.flywaydb&lt;/groupId&gt; &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;&lt;/dependency&gt; 마이그레이션 디렉토리 db/migration 또는 db/migration/{vendor} 파일들의 쿼리문 문법을 잘 지켜야한다. (;까지) spring.flyway.locations로 변경 가능 마이그레이션 파일 이름 V숫자__이름.sql V는 꼭 대문자로. 숫자는 순차적으로 (타임스탬프 권장) 숫자와 이름 사이에 언더바 두 개. 이름은 가능한 서술적으로. 적용된 스크립트 파일(sql)은 절대로 건들면 안된다. 수정사항 발생 시, 새로운 파일을 작성한다. 변경사항 새로운 스크립트 작성 Redis 캐시, 메시지 브로커, 키/밸류 스토어 등으로 사용 가능. spring-boot-data-redis 의존성 추가 Redis 설치 및 실행 (도커) docker run -p 6379:6379 –name redis_boot -d redis docker exec -i -t redis_boot redis-cli 스프링 데이터 Redis https://projects.spring.io/spring-data-redis/ StringRedisTemplate 또는 RedisTemplate extends CrudRepository Redis 주요 커맨드 https://redis.io/commands keys * get {key} hgetall {key} hget {key} {column} 커스터마이징 spring.redis.* url : localhost가아니면 설정이 필요하다. port : 기본포트번호(6379) 사용안하면 설정이 필요하다. MongoDB MongoDB는 JSON 기반의 도큐먼트 데이터베이스 스키마가 없다 Webflux를 사용하는 경우, MongoDB reactive를 사용하여 reactive한 repository를 만들 수 있다. 참고 : ApplicationRunner를 만드는 새로운 방법 ApplicationRunner를 리턴하는 메소드를 빈으로 등록한다. 람다를 사용하면 보다 간결하게 사용가능 collections 생성 RDB(Relation Data Base)의 테이블로 보면 된다. MongoDB 설치 및 실행 (도커) docker run -p 27017:27017 –name mongo_boot -d mongo docker exec -i -t mongo_boot bash mongo 스프링 데이터 몽고DB MongoTemplate MongoRepository 내장형 MongoDB (테스트용) 의존성 추가 12345&lt;dependency&gt; &lt;groupId&gt;de.flapdoodle.embed&lt;/groupId&gt; &lt;artifactId&gt;de.flapdoodle.embed.mongo&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; @DataMongoTest 운영용 MongoDB에 영향을 주지 않는다. 운영용 DB를 포함하지만, test에서 만든 데이터는 운영 DB에 추가 되지않는다. Neo4j Neo4j는 노드간의 연관 관계를 표현하는데 빠르고 다양한 기능을 제공하는 그래프 데이터베이스ex) 친구의친구의친구를 찾는다거나.. 친구의 세번째링크에 관련된 모든 친구를 불러온다거나.. 의존성 추가 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;/artifactId&gt;&lt;/dependency&gt; Neo4j 설치 및 실행 (도커) docker run -p 7474:7474 -p 7687:7687 -d –name noe4j_boot neo4j 포트를 두개 설정해주어야 한다. HTTP(앞) → 서버에서 사용한다. 볼트 프로토 (뒤) http://localhost:7474/browser 바로 접속할 수 있다. 기본 패스워드 Neo4j 비밀번호를 바꿔야한다. 기본 패스워드가 변경되었기 때문에 설정해줘야한다. NodeEntity 생성 id 는 숫자값만 줄수 있다. 스프링 데이터 Neo4J 최신버전으로 오면서 등록되던 빈들이 사라졌다. Neo4jTemplate Neo4jOpertion SessionFactory Neo4jRepository 관계보기 NodeEntity 생성 및 데이터입력 (이전과정에서 진행하였다.) 브라우저에서 확인 가능하다. Relationship을 가질 NodeEntity를 하나 더 만든다. Relationship 설정 (Account가 Role을 가지도록 설정하였다.) 롤 부여 및 실행 브라우저에서 확인","link":"/2019/04/15/spring/springboot13/"},{"title":"스프링 프레임워크 입문02 - AOP","text":"스프링 프레임워크 입문02(inflearn) - 백기선Springframework AOP(Aspect Oriented Programming)흩어져있는 코드를 한곳에 모으는 코딩 기법 바이트코드 조작 클래스파일을 조작 프록시패턴 12class AProxy extends A {} 내부적으로 위와같은 클래스를 생성한다. 스프링 AOP는 프록시 패턴을 사용한다. 예제어떤메소드가 실행됬을 때, 시간을 로그로 남기는 예제 @LogExecutionTime 애노테이션 (어디에 적용할지 표시 해두는 용도) 생성annotation 자체는 어떠한 기능도 없다. 1234@Target(ElementType.METHOD) //메소드에 사용할것이다. @Retention(RetentionPolicy.RUNTIME) //런타임동안 해당 annotation을 유지 할 것이다.public @interface LogExecutionTime {} 실제 Aspect (@LogExecutionTime 애노테이션 달린곳에 적용) 1234567891011121314151617@Component@Aspectpublic class LogAspect { Logger logger = LoggerFactory.getLogger(LogAspect.class); // 로그를 찍기 위해 로거 객체 생성 @Around(&quot;@annotation(LogExecutionTime)&quot;) public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable { StopWatch stopWatch = new StopWatch(); stopWatch.start(); Object proceed = joinPoint.proceed(); // 어노테이션이 적용된 메소드를 실행 stopWatch.stop(); logger.info(stopWatch.prettyPrint()); return proceed; }} PSA(Portable Service Abstraction) 잘 만든 인터페이스 테스트에 유리하다. 변경하기 좋다. 스프링이 제공하는 API는 모두 PSA라고 본다. 스프링프레임워크가 제공하는 API의 90%는 추상화된 인터페이스로 모든영역을 수용할 수 있다. 예제@TransactionalPlatformTransactionManager 구현체들중 하나는 또는 다수는 빈으로 등록이 된다.(Spring boot의 자동설정에 의해서) 트랜잭션을 처리하는 Aspect는 빈의 바뀌더라도 Aspect는 변화하지 않으므로, 코드의 변경이 없다. @Controller | @RequestMapping 해당코드만 봐서는 Servlet을 사용하는 것인지, Reactive를 사용하는 것인지 판단이 불가능하다. 즉, 추상화 (의존성을 봐야한다.) 추상화 되있으므로 기술이 변경되어도 대부분의 코드들은 변경없이 사용이 가능하다. 강의를 들으며 느낀것이 기초 개념 부분이지만 상당히 잘못알고있던 부분도 있었고, 부분적으로만 알고 있었던 부분도 있었습니다.좋은 강의를 듣고 정리할 수 있는 시간이 되어서 좋았습니다. 😀","link":"/2019/03/08/spring/springframework-introduction02/"},{"title":"스프링 데이터 JPA03 - 엔티티 맵핑, Value 타입 맵핑, 관계 맵핑","text":"스프링 데이터 JPA(inflearn) - 백기선핵심 개념 이해 엔티티 맵핑 xml, @어노테이션으로 맵핑하는 방법 2가지가 있다. 일반적으로 어노테이션을 활용하는 방법을 사용한다. @Entity “엔티티”는 객체 세상에서 부르는 이름. 보통 클래스와 같은 이름을 사용하기 때문에 값을 변경하지 않음. 기본값은 클래스 이름을 쓴다. 변경하고 싶을 때는 @Entity(name=”변경이름”) User라는 이름을 사용하지 못하는 DB가 있다. 그럴경우 변경해야한다. 엔티티의 이름은 JQL에서 쓰임. @Table “릴레이션” 세상에서 부르는 이름. @Entity의 이름이 기본값. 테이블의 이름은 SQL에서 쓰임. @Id 엔티티의 주키를 맵핑할 때 사용. 자바의 모든 primitive 타입(int, long..)과 그 랩퍼 타입(Integer, Long..)을 사용할 수 있음 Date랑 BigDecimal, BigInteger도 사용 가능. 복합키를 만드는 맵핑하는 방법도 있지만 그건 논외로.. @GeneratedValue 주키의 생성 방법을 맵핑하는 애노테이션 생성 전략과 생성기를 설정할 수 있다. 기본 전략은 AUTO: 사용하는 DB에 따라 적절한 전략 선택 TABLE, SEQUENCE, IDENTITY 중 하나. @GenerateValue(strategy=) 로 변경이 가능 @Column 멤버변수에는 @Column이 붙어있는거랑 마찬가지이다. 여러설정이 가능하다. unique nullable length columnDefinition … @Temporal 타입으로 날짜, 시간, 날짜+시간(TIMESTAMP) 설정가능 현재 JPA 2.1까지는 Date와 Calendar만 지원. 커스텀한 컨버터를 등록하면 사용이 가능하다. @Transient 컬럼으로 맵핑하고 싶지 않은 멤버 변수에 사용. 쿼리문 확인하기 application.properties spring.jpa.show-sql=true 쿼리문 보여주기 spring.jpa.properties.hibernate.format_sql=true 가독성 높이기 로거설정을 통해 value값을 확인하는 법도 있다. Value 타입 맵핑엔티티 타입과 Value 타입 구분 식별자가 있어야 하는가. 독립적으로 존재해야 하는가. Value 타입 종류 기본 타입 (String, Date, Boolean, …) Composite Value 타입 Collection Value 타입 기본 타입의 콜렉션 컴포짓 타입의 콜렉션 Composite Value 타입 맵핑 @Embeddable @Embedded @AttributeOverrides @AttributeOverride 관계 맵핑 관계에는 항상 두 엔티티가 존재 합니다. 둘 중 하나는 그 관계의 주인(owning)이고 다른 쪽은 종속된(non-owning) 쪽입니다. 해당 관계의 반대쪽 레퍼런스를 가지고 있는 쪽이 주인. 단방향 관계를 정의한 쪽이 그 관계의 주인입니다. @ManyToOne 기본값은 FK 생성 @OneToMany 기본값은 조인 테이블 생성 hibernate.ddl-auto=create로 되어있어도 조인테이블은 삭제되지 않는다.엔티티로 정의 된 테이블만 삭제 ManyToOne 인지 OneToMany인지 헷갈린다면 필드객체를 보아라. 양방향 FK 가지고 있는 쪽이 오너 따라서 기본값은 @ManyToOne 가지고 있는 쪽이 주인. 주인이 아닌쪽(@OneToMany쪽)에서 mappedBy 사용해서 관계를 맺고 있는 필드를 설정해야 합니다. 주인한테 관계를 설정해야 DB에 반영이 됩니다. 양쪽모두에 설정해주는것이 제일 좋다. 이렇게 메소드를 만들어 쓰는것을 추천한다. 1234public void add(Study study) { this.getStudies().add(study); study.setOwner(this);} 사용 issue JSON 변환 시, 무한루프 @Entity 와 @Data(lombok) 양방향 관계를 사용하는 이유","link":"/2019/04/30/spring/springjpa03/"},{"title":"스프링 데이터 JPA02 - 프로젝트 세팅","text":"스프링 데이터 JPA(inflearn) - 백기선핵심 개념 이해 프로젝트 세팅 데이터 베이스 실행(PostgreSQL로 진행) 참고 : 스프링 데이터 PostgreSQL 드라이버 추가 (postgres 의존성 추가) 프로젝트 생성 의존성 추가 스프링 부트 스프링 부트 v2.* 스프링 프레임워크 v5.* 스프링 부트 스타터 JPA JPA 프로그래밍에 필요한 의존성 추가 JPA v2.* Hibernate v5.* 자동 설정: HibernateJpaAutoConfiguration 컨테이너가 관리하는 EntityManager (프록시) 빈 설정 PlatformTransactionManager 빈 설정 JPA사용하는데 필요한 모든 빈들이 자동으로 등록된다. JDBC 설정 jdbc:postgresql://localhost:5432/springboot username = bong password = pass application.properties 설정 spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true createclob()이라는 메소드를 구현하지 않아 warning이 발생하는데 그것을 방지함 spring.jpa.hibernate.ddl-auto=create 매번 스키마를 생성한다.(기존에 있던것을 삭제하고..) update로 정의 시, 데이터들이 남아있고 추가된것만 추가된다.(컬럼 및 데이터) 그러나, 컬러명 변경 또는 삭제는 해결할 수 없다.(DB 마이그레이션 툴 사용이 필요하다.) Entity 생성 모든 필드값에 @Column이 생략되어있다고 생각하면 된다. lombok 사용하였음 데이터 저장 JPA 사용 springjpa EntityManager는 JPA에 가장 핵심 클래스이다. EntityManager와 관련된 모든 작업은 한 트랜잭션 안에서 일어나야한다. @Transactional 사용하여 적용 클래스에 적용하여 모든 메소드에 적용 메소드에 적용 시, 해당 메소드에만 작 Hibernate 사용 springjpa Hibernamte의 가장 핵심적인 api는 Session이다. Session을 꺼내서 사용하여 데이터를 저장한다.","link":"/2019/04/30/spring/springjpa02/"},{"title":"스프링 데이터 JPA05 - 스프링 데이터 Common","text":"스프링 데이터 JPA(inflearn) - 백기선스프링 데이터 Common 스프링 데이터 JPA 활용 파트 소개 스프링 데이터 : 하나의 프로젝트를 말하는것이 아니고, 여러개의 프로젝트들의 묶음을 말하는것.(SQL &amp; NoSQL 저장소 지원 프로젝트의 묶음.) 스프링 데이터 Common : 여러 저장소 지원 프로젝트의 공통 기능 제공. 스프링 데이터 REST : 저장소의 데이터를 하이퍼미디어 기반 HTTP 리소스로(REST API로) 제공하는 프로젝트. 스프링 데이터 JPA : 스프링 데이터 Common이 제공하는 기능에 JPA 관련 기능 추가 참고문서 Repository 앞서 JpaRepository를 상속하는 클래스를 만들어 사용한적이 있었는데.. 사실 해당 부분은 JpaRepository가 스프링데이터 Common의 PagingAndSortingRepostiory를 상속받고 있다. 이미지 PagingAndSortingRepostiory : paging, sorting 메소드를 지원 CrudRepository : CRUD 메소드를 지원 @NoRepositoryBean가 붙어있는데.. 실제 빈을 만들어 등록하지 않도록한다.(중간단계의 Repository에는 붙어있다. 실제 Repository가 아님을 표현한다.) Repository : marker 인터페이스, 실질적인 기능을 하진 않는다. CrudRepository 메소드 save(entity); 하나의 엔티티를 저장하고 그 엔티티를 리턴해준다. saveall(Iterable&lt;&gt; entities); 여러개의 엔티티를 저장하고 리턴(Iterable타입으로..) findById(id); id로 엔티티를 찾아서 리턴한다. Optional&lt;&gt;로 리턴된다.(null방지..) existById(id); 해당 id에 해당하는 엔티티의 유무를 확인한다. findAll(); 어떤 한 엔티티의 모든 정보를 불러온다. 거의 테스트용으로 사용된다. Iterable로 리턴한다. (List&lt;&gt;로 리턴하는경우는 스프링 데이터 JPA를 사용하는것) findAllById(Iterable&lt;&gt; ids); 여러id에 해당하는 목록을 가져온다. count(); 갯수 delete(id); 삭제 deleteAll() 도 있다. test 기본적으로 데이터 테스트들은 @Transactional을 가지고 있는데.. 기본적으로 롤백을 한다. 어자피 롤백할 쿼리이기 때문에 test클래스 실행 시, insert쿼리문은 날라가지 않는다. 보고 싶다면 @Rollback(false)를 추가하자. CRUD PagingAndSorting Repository 인터페이스 정의하기Repository 인터페이스로 공개할 메소드를 직접 일일히 정의하고 싶을 때 특정 레퍼지토리 정의 @RepositoryDefinition test(정의한 Repository인터페이스는 모두 테스트를 해주어야한다.) 공통 인터페이스 정의 @NoRepositoryBean 사용할 인터페이스에서 상속 Null 처리하기Optional 자바8 부터 지원 Null을 리턴하지 않고, 비어있는 콜렉션을 리턴한다. 예시 Optional 메소드 예시 Null 어노테이션 스프링 프레임워크 5.0부터 지원하는 Null 애노테이션 지원. @NonNullApi package-info.java파일 생성 후, 어노테이션 사용 패키지안의 모든 파라미터 및 리턴타입 및 모두 Null이 아니어야한다. Null이 필요한곳에 @Nullable을 사용 해야한다. @NonNull Null이 아니길 바랄때 사용한다. @Nullable. 툴의 도움을 받을 수 있다. NonNullApi는 불가능 쿼리 만들기 개요스프링 데이터 저장소의 메소드 이름으로 쿼리 만드는 방법 메소드 이름을 분석해서 쿼리 만들기 (CREATE) 미리 정의해 둔 쿼리 찾아 사용하기 (USE_DECLARED_QUERY) 우선순위 Query &gt; Procedure &gt; NamedQuery 기본적으로 JPQL을 써야하나, SQL을 쓰고 싶다면 nativequery를 true로 변경한다. 미리 정의한 쿼리 찾아보고 없으면 만들기 (CREATE_IF_NOT_FOUND) (기본전략) @EnableJpaRepositories(queryLookupStrategy = )로 변경 가능하다. 쿼리 만드는 방법 리턴타입 {접두어}{도입부}By{프로퍼티 표현식}(조건식)[(And|Or){프로퍼티표현식}(조건식)]{정렬 조건} (매개변수) 접두어 : Find, Get, Query, Count, … 도입부 : Distinct, First(N), Top(N) 프로퍼티 표현식 : Person.Address.ZipCode =&gt; find(Person)ByAddress_ZipCode(…) 조건식 : IgnoreCase, Between, LessThan, GreaterThan, Like, Contains, … 정렬 조건 : OrderBy{프로퍼티}Asc|Desc 리턴 타입 : E, Optional, List, Page, Slice, Stream 매개변수 : Pageable, Sort 쿼리 만들기 실습기본예제1List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname); distinct12List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname); ignoring case12List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname); 정렬12List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname); 페이징1234Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);Slice&lt;User&gt; findByLastname(String lastname, Pageable pageable);List&lt;User&gt; findByLastname(String lastname, Sort sort);List&lt;User&gt; findByLastname(String lastname, Pageable pageable); 스트리밍 try-with-resource 사용할 것. (Stream을 다 쓴다음에 close() 해야 함)1Stream&lt;User&gt; readAllByFirstnameNotNull(); 그 외 실습내용Repository classtest class 비동기 쿼리Future12@AsyncFuture&lt;User&gt; findByFirstname(String firstname); Java5에서 생김 @EnableAsync 해주어야한다. CompletableFuture12@Async CompletableFuture&lt;User&gt; findOneByFirstname(String firstname); Java8에서 들어옴 @EnableAsync 해주어야한다. ListenableFuture12@Async ListenableFuture&lt;User&gt; findOneByLastname(String lastname); 스프링에서 만들었다. 가장 깔끔함. 해당 메소드를 스프링 TaskExecutor에 전달해서 별도의 쓰레드에서 실행함. Reactive랑은 다른 것임 권장하지 않는 이유 테스트 코드 작성이 어려움. 코드 복잡도 증가. 성능상 이득이 없음. DB 부하는 결국 같고. 메인 쓰레드 대신 백드라운드 쓰레드가 일하는 정도의 차이. 단, 백그라운드로 실행하고 결과를 받을 필요가 없는 작업이라면 @Async를 사용해서 응답 속도를 향상 시킬 수는 있다. 커스텀 리포지토리 쿼리 메소드(쿼리 생성과 쿼리 찾아쓰기)로 해결이 되지 않는 경우 직접 코딩으로 구현 가능. 스프링 데이터 리포지토리 인터페이스에 기능 추가. 스프링 데이터 리포지토리 기본 기능 덮어쓰기 가능. 구현방법 커스텀 리포지토리 인터페이스 정의 인터페이스 구현 클래스 만들기 (기본 접미어는 Impl) EntityManager, JdbcTemplate 등을 주입받아 사용할 수 있다. 엔티티 리포지토리에 커스텀 리포지토리 인터페이스 추가 기본 기능을 덮어쓰고 싶다면 기본기능 메소드를 그대로 정의하고 위와 같은 방법으로 구현한다. 접미어 설정하기 @EnableJpaRepositories(repositoryImplementationPostfix = “변경값”) 기본값은 “Impl” 이다. 기본 리포지토리 커스터마이징 모든 리포지토리에 공통적으로 추가하고 싶은 기능이 있거나 덮어쓰고 싶은 기본 기능이 있을때 구현방법 JpaRepository를 상속 받는 인터페이스 정의 @NoRepositoryBean 기본 구현체를 상속 받는 커스텀 구현체 만들기 @EnableJpaRepositories에 설정 repositoryBaseClass 엔티티 레포지토리에 설정 도메인 이벤트도메인 관련 이벤트를 발생시키기에 대하여 스프링 프레임워크 사용방법 및 스프링 데이터 사용방법에 대해 알아보자. 스프링 프레임워크의 이벤트 관련 기능 참고문서 이벤트를 만들때는 ApplicationEvent를 상속받도록한다. (extends ApplicationEvent) ApplicationContext는 BeanFactory와 더불어 ApplicationEventPublisher도 상속받고 있다. (이벤트 등록 기능 지원) 리스너 (하기 두가지 방법중 선택하여 사용한다.) implements ApplicationListener @EventListener 스프링 데이터의 도메인 이벤트 Publisher extends AbstractAggregateRoot AbstractAggregateRoot안에 두 어노테이션이 있다. @DomainEvents @AfterDomainEventPublication registerEvent() 메소드를 사용할 수 있게된다. (이벤트 등록) 현재는 save() 할 때만 발생 합니다. QueryDSL(Domain Specific Language)QueryDSL을 사용하는 이유 조건문을 표현하는 방법이 타입세이프하다. 조건문을 Predicate 인터페이스로 조건문을 표현하는데, 조합 및 별도 관리가 가능하다. 여러 쿼리 메소드는 대부분 두 가지 중 하나 Optional findOne(Predicate): 이런 저런 조건으로 무언가 하나를 찾는다. List|Page|.. findAll(Predicate): 이런 저런 조건으로 무언가 여러개를 찾는다. QuerydslPredicateExecutor 인터페이스 QueryDSL 참고문서 타입 세이프한 쿼리 만들 수 있게 도와주는 라이브러리 JPA, SQL, MongoDB, JDO, Lucene, Collection 지원 QueryDSL JPA 연동 가이드 연동 방법 기본 리포지토리 커스터마이징 안 했을 때. 의존성추가(스프링 부트가 버전관리 해줌) querydsl-apt : 쿼리용 Domain Specific Laguage를 생성해준다. 플러그인 설정이 필요하다. queydsl-jpa123456789&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.querydsl&lt;/groupId&gt; &lt;artifactId&gt;querydsl-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 플러그인 추가 12345678910111213141516&lt;plugin&gt; &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt; &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/generated-sources/java&lt;/outputDirectory&gt; &lt;processor&gt;com.querydsl.apt.jpa.JPAAnnotationProcessor&lt;/processor&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; compile 시, 해당 파일이 생성된다.(QAccount) Repostiory 인터페이스에 QuerydslPredicateExecutor&lt;도메인타입&gt; 상속을 추가한다. predicate를 사용하여 조건문을 만들고 사용한다. 기본 리포지토리 커스타마이징 했을 때. 기존에는 만든 커스터마이징 구현체에 SimpleJpaRepository를 상속하지 않도록하고 QuerydslJpaRepository를 상속하도록 함으로 해결 할 수 있었다. 현재는 상기 방법가 동일하게 해도 구현되는것을 확인하였다. DomainClassConverter스프링 Converter 참고문서 DomainClassConverter 사용 전 123456@GetMapping(&quot;/posts/{id}&quot;) public String getAPost(@PathVariable Long id) { Optional&lt;Post&gt; byId = postRepository.findById(id); Post post = byId.get(); return post.getTitle(); } 사용 해당아이디 값으 찾아서 Domain객체로 변환해준다. 1234@GetMapping(&quot;/posts/{id}&quot;) public String getAPost(@PathVariable(“id”) Post post) { return post.getTitle(); } Formatter 문자열 기반 문자열 -&gt; 다른타입 어떤타입 -&gt; 문자열 프린팅 Pageable과 Sort 매개변수스프링 MVC HandlerMethodArgumentResolver 스프링 MVC 핸들러 메소드의 매개변수로 받을 수 있는 객체를 확장하고 싶을 때 사용하는 인터페이스 참고문서 페이징과 정렬 관련 매개변수 page: 0부터 시작. size: 기본값 20. sort: property,property(,ASC|DESC) 예) sort=created,desc&amp;sort=title (asc가 기본값) 예제 컨트롤러 1234@GetMapping(&quot;/posts&quot;) public Page&lt;Post&gt; getPost(Pageable pageable){ return postRepository.findAll(pageable);} test 123456789101112131415@Testpublic void getPosts() throws Exception { Post post = new Post(); post.setTitle(&quot;jpa&quot;); postRepository.save(post); mockMvc.perform(get(&quot;/posts/&quot;) .param(&quot;page&quot;, &quot;0&quot;) .param(&quot;size&quot;, &quot;10&quot;) .param(&quot;sort&quot;, &quot;created,desc&quot;) .param(&quot;sort&quot;, &quot;title&quot;)) .andDo(print()) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$.content[0].title&quot;, is(&quot;jpa&quot;)));} HATEOASPage를 PagedResource로 변환하기 일단 HATEOAS 의존성 추가 (starter-hateoas) 핸들러 매개변수로 PagedResourcesAssembler 예제 컨트롤러 1234@GetMapping(&quot;/posts&quot;)public PagedResources&lt;Resource&lt;Post&gt;&gt; getPosts (Pageable pageable, PagedResourcesAssembler&lt;Post&gt; assembler){ return assembler.toResource(postRepository.findAll(pageable));} test 123456789101112131415161718192021222324@Testpublic void getPosts() throws Exception { createPost(&quot;jpa&quot;); mockMvc.perform(get(&quot;/posts/&quot;) .param(&quot;page&quot;, &quot;0&quot;) .param(&quot;size&quot;, &quot;10&quot;) .param(&quot;sort&quot;, &quot;created,desc&quot;) .param(&quot;sort&quot;, &quot;title&quot;)) .andDo(print()) .andExpect(status().isOk()) .andExpect(jsonPath(&quot;$.content[0].title&quot;, is(&quot;jpa&quot;)));} private void createPost(String title) { int postcount = 0; while(postcount &lt;= 100){ Post post = new Post(); post.setTitle(title); postRepository.save(post); postcount++; } 결과 123456789101112131415161718192021222324252627282930313233343536373839 &quot;_embedded&quot;:{ &quot;postList&quot;:[ { &quot;id&quot;:140, &quot;title&quot;:&quot;jpa&quot;, &quot;created&quot;:null },... { &quot;id&quot;:109, &quot;title&quot;:&quot;jpa&quot;, &quot;created&quot;:null } ] }, &quot;_links&quot;:{ &quot;first&quot;:{ &quot;href&quot;:&quot;http://localhost/posts?page=0&amp;size=10&amp;sort=created,desc&amp;sort=title,asc&quot; }, &quot;prev&quot;:{ &quot;href&quot;:&quot;http://localhost/posts?page=1&amp;size=10&amp;sort=created,desc&amp;sort=title,asc&quot; }, &quot;self&quot;:{ &quot;href&quot;:&quot;http://localhost/posts?page=2&amp;size=10&amp;sort=created,desc&amp;sort=title,asc&quot; }, &quot;next&quot;:{ &quot;href&quot;:&quot;http://localhost/posts?page=3&amp;size=10&amp;sort=created,desc&amp;sort=title,asc&quot; }, &quot;last&quot;:{ &quot;href&quot;:&quot;http://localhost/posts?page=19&amp;size=10&amp;sort=created,desc&amp;sort=title,asc&quot; } }, &quot;page&quot;:{ &quot;size&quot;:10, &quot;totalElements&quot;:100, &quot;totalPages&quot;:20, &quot;number&quot;:2 }}","link":"/2019/05/03/spring/springjpa05/"},{"title":"스프링 데이터 JPA06 - 스프링 데이터 JPA","text":"스프링 데이터 JPA(inflearn) - 백기선스프링 데이터 JPA JPA Repository@EnableJpaRepositories 스프링 부트 사용할 때는 사용하지 않아도 자동 설정 됨. 스프링 부트 사용하지 않을 때는 @Configuration과 같이 사용. @Repository 안붙여도 된다. (실제 구현체에서 가지고 있다. 중복임..) @Repository SQLExcpetion 또는 JPA 관련 예외를 스프링의 DataAccessException으로 변환 해준다. 엔티티 저장하기Transient인지 Detached 인지 어떻게 판단 하는가? 엔티티의 @Id 프로퍼티를 찾는다. 해당 프로퍼티가 null이면 Transient 상태로 판단하고 id가 null이 아니면 Detached 상태로 판단한다. 엔티티가 Persistable 인터페이스를 구현하고 있다면 isNew() 메소드에 위임한다. JpaRepositoryFactory를 상속받는 클래스를 만들고 getEntityInfomration()을 오버라이딩해서 자신이 원하는 판단 로직을 구현할 수도 있다. EntityManager.persist() 참고문서 Persist() 메소드에 넘긴 그 엔티티 객체를 Persistent 상태로 변경한다. EntityManager.merge() 참고문서 Merge() 메소드에 넘긴 그 엔티티의 복사본을 만들고, 그 복사본을 다시 Persistent 상태로 변경하고 그 복사본을 반환한다. JpaRepository의 save() JpaRepository의 save()는 단순히 새 엔티티를 추가하는 메소드가 아님 Transient 상태의 객체라면 EntityManager.persist() Detached 상태의 객체라면 EntityManager.merge() merge / persist 관련 오류 발생이 있을 수 있음으로 언제나 Repository에서 리턴되는 값을 사용하자. 테스트 범위에 따라서 달라지는 결과 @SpringBootTest postRepository.save()에만 트랜잭션이 적용됨 테스트 내에서는 entitymanager가 객체를 모른다. @DataJpaTest 트랜잭션이 테스트 단위이다. postRepository의 오퍼레이션과 EntityManager 모두 한 트랜잭션 entitymanager가 객체를 안다. 쿼리 메소드쿼리 생성하기 참고문서 And, Or Is, Equals LessThan, LessThanEqual, GreaterThan, GreaterThanEqual After, Before IsNull, IsNotNull, NotNull Like, NotLike StartingWith, EndingWith, Containing OrderBy Not, In, NotIn True, False IgnoreCase 쿼리 찾아쓰기 엔티티에 정의한 쿼리 찾아 사용하기 JPA Named 쿼리 @NamedQuery @NamedNativeQuery 리포지토리 메소드에 정의한 쿼리 사용하기 @Query @Query(nativeQuery=true) Sort 이전과 마찬가지로 Pageable이나 Sort를 매개변수로 사용할 수 있는데, @Query와 같이 사용할 때 제약 사항이 하나 있다. Sort는 그 안에서 사용한 프로퍼티 또는 alias가 엔티티에 없는 경우에는 예외가 발생합니다. Order by 절에서 함수를 호출하는 경우에는 Sort를 사용하지 못합니다. 그 경우에는 JpaSort.unsafe()를 사용 해야 합니다. JpaSort.unsafe()를 사용하면 함수 호출을 할 수 있습니다. JpaSort.unsafe(“LENGTH(firstname)”); Named Parameter과 SpELNamed Parameter @Query에서 참조하는 매개변수를 \\?1, \\?2 이렇게 채번으로 참조하는게 아니라 이름으로 \\:title 이렇게 참조할 수 있다. 12@Query(&quot;SELECT p FROM Post AS p WHERE p.title = :title&quot;)List&lt;Post&gt; findByTitle(@Param(&quot;title&quot;) String title, Sort sort); SpEL 스프링 표현 언어 참고문서 @Query에서 엔티티 이름을 아래와같이 표현할 수 있습니다(entityName) 12@Query(&quot;SELECT p FROM #{#entityName} AS p WHERE p.title = :title&quot;)List&lt;Post&gt; findByTitle(@Param(&quot;title&quot;) String title, Sort sort); Update 쿼리 메소드Update 또는 Delete 쿼리 직접 정의하기 객체의 변화를 인지하고 데이터베이스에 동기화 (flush) update쿼리를 직접만들일이 별로 없다. 하지만 update가 자주 일어나는 경우, 만들어 쓸수 있다.(추천하진 않는다.) 123@Modifying@Query(&quot;UPDATE Post p SET p.title = ?2 WHERE p.id = ?1&quot;)int updateTitle(Long id, String title); 추천하지 않는 이유 1차캐싱때문에 Persistent 상태의 객체를 select 하지 않고 그냥 가져온다.(트랜잭션이 끝나지 않았다.) 문제를 해결하려면… clearAutomatically = true 실행 후, Persistent Context에 들어있던 캐쉬를 비워준다.그래야 find할 때, 다시 새로 읽어온다. flushAutomatically = true 실행 전, Persistent Context상태를 flush 한다.데이터 변경사항을 update하기위해 EntityGraph 쿼리 메소드 마다 연관 관계의 Fetch 모드를 설정 할 수 있다. 예).. fetch = FetchType.LAZY를 기본으로 하되 필요한 경우에따라 EAGER로 사용하고 싶을때 @NamedEntityGraph @Entity에서 재사용할 여러 엔티티 그룹을 정의할 때 사용 @EntityGraph @NamedEntityGraph에 정의되어 있는 엔티티 그룹을 사용 함. 그래프 타입 설정 가능 (기본값) FETCH: 설정한 엔티티 애트리뷰트는 EAGER 패치 나머지는 LAZY 패치. LOAD: 설정한 엔티티 애트리뷰트는 EAGER 패치 나머지는 기본 패치 전략 따름. @NamedEntityGraph 정의 되어있지않아도 attributePaths를 설정하여 사용할 수 있다. 비교 Projection 엔티티의 일부 데이터만 가져오기. 인터페이스 기반 프로젝션 Nested 프로젝션 가능. 인터페이스에 메소드 정의 타입을 해당 인터페이스 타입으로 변경 Open 프로젝션 @Value(SpEL)을 사용해서 연산을 할 수 있다. 스프링 빈의 메소드도 호출 가능. 쿼리 최적화를 할 수 없다. SpEL을 엔티티 대상으로 사용하기 때문에. Closed 프로젝션 (추천) 쿼리를 최적화 할 수 있다. 가져오려는 애트리뷰트가 뭔지 알고 있으니까. Java 8의 디폴트 메소드를 사용해서 연산을 할 수 있다. 클래스 기반 프로젝션 DTO 롬복 @Value로 코드 줄일 수 있음 다이나믹 프로젝션 프로젝션 용 메소드 하나만 정의하고 실제 프로젝션 타입은 타입 인자로 전달하기. 그러나 오버로딩이 안됨으로 제네릭을 사용하자. Specifications에릭 에반스의 책 DDD에서 언급하는 Specification 개념을 차용 한 것으로 QueryDSL의 Predicate와 비슷하다. 조건을 하나의 스펙으로 등록이 가능하다. 설정 참고문서 의존성 설정 1234&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt;&lt;/dependency&gt; 플러그인 설정 1234567891011121314151617181920212223242526&lt;plugin&gt; &lt;groupId&gt;org.bsc.maven&lt;/groupId&gt; &lt;artifactId&gt;maven-processor-plugin&lt;/artifactId&gt; &lt;version&gt;2.0.5&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;process&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;process&lt;/goal&gt; &lt;/goals&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;configuration&gt; &lt;processors&gt; &lt;processor&gt;org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor&lt;/processor&gt; &lt;/processors&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-jpamodelgen&lt;/artifactId&gt; &lt;version&gt;${hibernate.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/plugin&gt; IDE에 애노테이션 처리기 설정 org.hibernate.jpamodelgen.JPAMetaModelEntityProcessor 사용 JpaSpecificationExecutor 상속 추가 12public interface CommentRepository extends JpaRepository&lt;Comment, Long&gt;, JpaSpecificationExecutor&lt;Comment&gt; { } Spec 클래스 12345678910111213141516171819202122public class CommentSpec { public static Specification&lt;Comment&gt; isBest(){ return new Specification&lt;Comment&gt;(){ @Override public Predicate toPredicate(Root&lt;Comment&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder builder) { return builder.isTrue(root.get(Comment_.best)); } }; //여기서 root comment 코멘트가 베스트인지 } public static Specification&lt;Comment&gt; isGood(){ return new Specification&lt;Comment&gt;() { @Override public Predicate toPredicate(Root&lt;Comment&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder builder) { return builder.greaterThan(root.get(Comment_.up), 10); } }; // 코멘트의 up이 10개보다 큰것 }} - 람다 사용 시 123456789101112public class CommentSpec { public static Specification&lt;Comment&gt; isBest(){ return (Specification&lt;Comment&gt;) (root, criteriaQuery, builder) -&gt; builder.isTrue(root.get(Comment_.best)); //여기서 root comment 코멘트가 베스트인지 } public static Specification&lt;Comment&gt; isGood(){ return (Specification&lt;Comment&gt;) (root, criteriaQuery, builder) -&gt; builder.greaterThan(root.get(Comment_.up), 10); // 코멘트의 up이 10개보다 큰것 }} test 여러 조건들에 대하여 조합도 가능하여, 메소드를 많이 늘리지 않고, 사용할 수 있어 편리하다.(단, 테스트는 필수이다.) Query by Example필드 이름을 작성할 필요 없이 단순한 인터페이스를 통해 동적으로 쿼리를 만드는 기능을 제공하는 사용자 친화적인 쿼리 기술입니다. 참고문서Example Example = Probe + ExampleMatcher Probe는 필드에 어떤 값들을 가지고 있는 도메인 객체. ExampleMatcher는 Prove에 들어있는 그 필드의 값들을 어떻게 쿼리할 데이터와 비교할지 정의한 것. Example은 그 둘을 하나로 합친 것. 이걸로 쿼리를 함. 사용방법 Repository에 QueryByExampleExecutor 상속 추가 12public interface CommentRepository extends JpaRepository&lt;Comment, Long&gt;, QueryByExampleExecutor&lt;Comment&gt; {} 사용 장점 별다른 코드 생성기나 애노테이션 처리기 필요 없음. 도메인 객체 리팩토링 해도 기존 쿼리가 깨질 걱정하지 않아도 됨.(실질적으로는 아니다.) 단점 nested 또는 프로퍼티 그룹 제약 조건을 못 만든다. 조건이 제한적이다. 문자열은 starts/contains/ends/regex 가 가능하고 그밖에 propery는 값이 정확히 일치해야 한다. 추천하지 않는다. QueryByDSL predicate 또는 Specification을 사용하는것을 추천한다. 트랜잭션 스프링 프레임워크에서 지원하는 트랜잭션과 거의 유사하다. 기본적으로 Repository 기본 메소드들은 기본적으로 @Transactional이 적용되어있다. 직접 선언하는 메소드에는 @Transactional 이 필요하다. @Transactional 참고문서 클래스, 인터페이스, 메소드에 사용할 수 있으며, 메소드에 가장 가까운 애노테이션이 우선 순위가 높다. 기본적으로 RuntimeException 또는 Error 발생 시, 롤백을 한다. checked Exception은 롤백 하지 않음. 롤백을 시키고 싶다면 rollbackfor에 설정해주어야한다. 롤백을 하고싶지 안핟면 norollbackfor등의 설정 timeout 설정가능 트랜잭션 매니저 지정가능 JPA트랜잭션 매니저를 쓸 것이다. readoOnly (최적화 위해서 사용) Flush 모드를 NEVER로 설정하여, Dirty checking을 하지 않도록 한다. Dirty Checking이란 상태 변경 검사JPA에서는 트랜잭션이 끝나는 시점에 변화가 있는 모든 엔티티 객체를 데이터베이스에 자동으로 반영해줍니다. Isolation 여러개의 트랜잭션이 동시에 데이터에 접근했을 때, 설정 기본값은 데이터베이스에 따라서 정해진다. Read Uncommitted 한 트랜잭션에서 커밋하지 않은 데이타에 다른 트랜잭션이 접근 가능하다. 즉, 커밋하지 않은 데이타를 읽을 수 있다. 이 수준은 당연히 위에서 언급한 모든 문제에 대해 발생가능성이 존재한다. 대신, 동시 처리 성능은 가장 높다. 발생 문제점 : Dirty Read, Non-Repeatable Read, Phantom Read Read Committed 커밋이 완료된 데이타만 읽을 수 있다. Dirty Read가 발생할 여지는 없으나, Read Uncommitted 수준보다 동시 처리 성능은 떨어진다. 대신 Non-Repeatable Read 및 Phantom Read는 발생 가능하다.데이타베이스들은 보통 Read Committed를 디폴트 수준으로 지정한다. 발생 문제점 : Non-Repeatable Read, Phantom Read Repeatable Read 트랜잭션 내에서 한번 조회한 데이타를 반복해서 조회해도 같은 데이타가 조회 된다 이는 개별 데이타 이슈인 Dirty Read나 Non-Repeatable Read는 발생하지 않지만, 결과 집합 자체가 달라지는 Phantom Read는 발생가능하다. 발생 문제점 : Phantom Read Serializable 가장 엄격한 격리 수준 위 3가지 문제점을 모두 커버 가능하다. 하지만 동시 처리 성능은 급격히 떨어질 수 있다. Isolation 관련 문제점 Dirty Read한 트랜잭션(T1)이 데이타에 접근하여 값을 ‘A’에서 ‘B’로 변경했고 아직 커밋을 하지 않았을때, 다른 트랜잭션(T2)이 해당 데이타를 Read 하면?T2가 읽은 데이타는 B가 될 것이다. 하지만 T1이 최종 커밋을 하지 않고 종료된다면, T2가 가진 데이타는 꼬이게 된다. Non-Repeatable Read한 트랜잭션(T1)이 데이타를 Read 하고 있다. 이때 다른 트랜잭션(T2)가 데이타에 접근하여 값을 변경 또는, 데이타를 삭제하고 커밋을 때려버리면?그 후 T1이 다시 해당 데이타를 Read하고자 하면 변경된 데이타 혹은 사라진 데이타를 찾게 된다. Phantom Read트랜잭션(T1) 중에 특정 조건으로 데이타를 검색하여 결과를 얻었다. 이때 다른 트랜잭션(T2)가 접근해 해당 조건의 데이타 일부를 삭제 또는 추가 했을때, 아직 끝나지 않은 T1이 다시 한번 해당 조건으로 데이타를 조회 하면 T2에서 추가/삭제된 데이타가 함께 조회/누락 된다. 그리고 T2가 롤백을 하면? 데이타가 꼬인다 참고, 출처 - wmJun Propagation 트랜잭션을 어떻게 전파시킬 것 인지 대한 설정 Dirty Checking(더티체킹) 시, 변경된 필드값만 updqte 하기위해서는 @DynamicUpdate를 사용한다. Auditing 엔티티의 변경 시점에 언제, 누가 변경했는지에 대한 정보를 기록하는 기능. 스프링 데이터 JPA의 Auditing 스프링 부트가 자동 설정 해주지 않는다. 엔티티 클래스 위에 @EntityListeners(AuditingEntityListener.class) 추가 AuditorAware 구현체 만들기 security를 사용하여 현재 유저정보를 가져올 수 있지만 print문으로 대체하였다. @EnableJpaAuditing 및 AuditorAware 빈 이름 설정하기. 빈 이름은 첫글자를 소문자로 변경한것이다. 라이프 사이클 이벤트 참고문서 엔티티에 변화가 일어났을 때, 특정한 콜백을 실행할 수 있는 이벤트를 발생시켜준다. @PrePersist 엔티티가 저장이 되기전에 호출 예).. @PreUpdate 여러개가 있다. 살펴보길..","link":"/2019/05/03/spring/springjpa06/"},{"title":"스프링 데이터 JPA04 - Cascade, Fetch, Query, 스프링 데이터 JPA 소개 및 원리","text":"스프링 데이터 JPA(inflearn) - 백기선핵심 개념 이해엔티티의 상태와 Cascade 엔티티의 상태 Transient: JPA가 모르는 상태 ex) new 사용하여 객체생성 상태 Persistent: JPA가 관리중인 상태 (1차 캐시, Dirty Checking(변경사항을 계속체크), Write Behind, …) ex) session.save()를 통해 저장한 상태 1차 캐시(persistent context(session, entitiymanager등)에 저장된다.) 바로 쿼리문을 날리지 않고 1차캐싱 후, 트랜잭션 종료 시 객체를 체크하여 쿼리문을 날린다.(불필요한 쿼리문 날리지 않는다.) Detached: JPA가 더이상 관리하지 않는 상태. session이 끝난상태 Removed: JPA가 관리하긴 하지만 삭제하기로 한 상태. Cascade 엔티티의 상태 변화를 전파 시키는 옵션 참조하고 있던 객체들도 함께 변화한다.(설정을 해주어야한다.) remove 옵션을 주면 함께 사라진다. Fetch 연관 관계의 엔티티의 정보를 어떻게 가져올것인가에 대한 설정 지금 : Eager @ManyToOne (기본값) comment를 통해서 post를 호출할때 쿼리를 두개 날라지 않는다. 조인쿼리문을 사용하여 출력 @OneToMany의 fetch모드를 eager로 변경하게 되면 comment정보 까지 가져오는것을 확인 할 수 있다. 나중에 : Lazy @OneToMany (기본값) Hibernate API (get vs load)session.get();, session.load();과 같이 사용이 가능하다.get - DB에서 정보를 가져온다. (Null이 나올 수 있음.) load - DB뿐만 아니라 프록시에서도 정보를 가져올 수 있다. - 정보가 없으면 예외를 던진다. Query지금까지 Hibernate를 사용하여(entitymanager.unwrap(Session.class);) Session객체를 사용하였다.(save(), get() 등의 api를 사용했다.)(JPA를 사용하여 EntityManager의 persist(), find()를 사용할 수도 있다.)이제 JPA를 사용하여 Query하는 방법에 대해 알아보자. JPQL12TypedQuery&lt;Post&gt; query = entityManager.createQuery(&quot;SELECT p FROM Post As p&quot;, Post.class);List&lt;Post&gt; posts = query.getResultList(); Java Persistence Query Language / Hibernate Query Language 데이터베이스 테이블이 아닌, 엔티티 객체 모델 기반으로 쿼리 작성. JPA 또는 하이버네이트가 해당 쿼리를 SQL로 변환해서 실행함. 참고문서 단점 오타발생이 가능 타입세이프하지 않다.(문자열이기 때문에..) Criteria12345CriteriaBuilder builder = entityManager.getCriteriaBuilder();CriteriaQuery&lt;Post&gt; criteria = builder.createQuery(Post.class);Root&lt;Post&gt; root = criteria.from(Post.class);criteria.select(root);List&lt;Post&gt; posts = entityManager.createQuery(criteria).getResultList(); 타입 세이프 쿼리 참고문서 Native Query123List&lt;Post&gt; posts = entityManager.createNativeQuery(&quot;SELECT * FROM Post&quot;, Post.class).getResultList(); 타입을 지원하지 않지만 타입을 받긴한다.. 참고문서 스프링 데이터 JPA 소개 및 원리JpaRepository&lt;Entity, Id&gt; 인터페이스 매직 인터페이스 @Repository가 없어도 빈으로 등록해 줌. @EnableJpaRepositories 매직의 시작은 여기서 부터 매직은 어떻게 이뤄지나? 시작은 @Import(JpaRepositoriesRegistrar.class) 핵심은 ImportBeanDefinitionRegistrar 인터페이스 tip sql 문 보이도록 하기 logging.level.org.hibernate.SQL=debug spring.jpa.show-sql=true sql문에서 value값 보기 logging.level.org.hibernate.type.descriptor.sql=trace","link":"/2019/04/30/spring/springjpa04/"},{"title":"스프링 기반 REST API 개발05 - RestAPI 보안 적용(@Enumerated, @ElementCollection, 스프링 시큐리티 설정, auth서버, 리소스서버, @ConfigurationProperties, form-data  request body, 현재 사용자 조회, @JsonSerialize)","text":"스프링 기반 REST API 개발(inflearn)5 - 백기선RestAPI 보안 적용 Account 도메인 추가 SpirngSecurity Auth2 사용 Grant Type : password Account 도메인 생성123456789101112131415161718@Entity@Getter @Setter @Builder@NoArgsConstructor @AllArgsConstructor@EqualsAndHashCode(of = \"id\")public class Account { @Id @GeneratedValue private Integer id; private String email; private String password; @ElementCollection(fetch = FetchType.EAGER) @Enumerated(EnumType.STRING) private Set&lt;AccountRole&gt; roles;} id email password Account Roles ADMIN USER JPA 맵핑 User라는 이름은 PostgreSQL에서 예약어이다. 예약어를 피해서 도메인 클래스이 이름을 Account로 결정하였다.\\ @Tables(“Users”) 이런식으로 테이블에 저장 될 테이블 명을 변경하는 방법도 있다. JPA enumeration collection mapping123@ElementCollection(fetch = FetchType.EAGER)@Enumerated(EnumType.STRING)private Set&lt;AccountRole&gt; roles; @ElementCollection : collection 속성 (여러개의 enum이 들어갈 수 있다.) @Enumerated(EnumType.STRING)를 선언하면 Enum 필드가 테이블에 저장시 숫자형인 1,2,3이 아닌, Enum의 name이 저장된다. 스프링 시큐리티 적용스프링 시큐리티 웹 시큐리티 (Filter 기반 시큐리티) 웹요청에 보안인증 메소드 시큐리티 웹과 상관없이 메소드가 호출됬을 때 보안인증 둘 다 Security Interceptor를 사용한다. 리소스에 접근을 허용할 것이냐, 말것이냐를 결정하는 로직이 들어있다. 인증, 인가의 로직을 처리한다. 의존성 추가12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt; UserDetailsService 구현 AccountService 1234567891011121314151617@Service@RequiredArgsConstructorpublic class AccountService implements UserDetailsService { private final AccountRepository accountRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Optional&lt;Account&gt; optionalAccount = accountRepository.findByEmail(username); Account account = optionalAccount.orElseThrow(() -&gt; new UsernameNotFoundException(username)); return new User(account.getEmail(), account.getPassword(), authorities(account.getRoles())); } private Collection&lt;? extends GrantedAuthority&gt; authorities(Set&lt;AccountRole&gt; roles) { return roles.stream().map(r -&gt; new SimpleGrantedAuthority(\"ROLE_\" + r.name())).collect(Collectors.toSet()); }} 해당 username에 해당하는 Account를 찾아서 스프링 시큐리티에서 제공하는 User(UserDetails를 구현하는)로 만들어서 return한다. Test 123456789101112131415161718192021222324@Testpublic void loadUserByUsername() { // given Set&lt;AccountRole&gt; accountRoleSet = new HashSet&lt;&gt;(); accountRoleSet.add(ADMIN); accountRoleSet.add(USER); String username = \"bong@email.com\"; String password = \"bong\"; Account account = Account.builder() .email(username) .password(password) .roles(accountRoleSet) .build(); accountRepository.save(account); // when UserDetailsService userDetailsService = accountService; UserDetails userDetails = userDetailsService.loadUserByUsername(username); // then assertThat(userDetails.getPassword()).isEqualTo(password);} 원래는 유저 저장 시, PasswordEncoder를 사용하여 인코딩해야하지만 이후에 하기로하고 생략하겠다. 예외 테스트 @Test(expected) 12345@Test(expected = UsernameNotFoundException.class)public void findByUserNameFail() { String username = \"random@email.com\"; accountService.loadUserByUsername(username);} @Test에 예상되는 Exception을 기재한다. try-catch 123456789@Testpublic void findByUserNameFail() { String username = \"random@email.com\"; try { accountService.loadUserByUsername(username); fail(\"fail\"); } catch (UsernameNotFoundException e) { assertThat(e.getMessage()).containsSequence(username);} @Rule ExpectedException 12345678910111213@Rulepublic ExpectedException expectedException = ExpectedException.none();@Testpublic void findByUserNameFail() { //expected String username = \"random@email.com\"; expectedException.expect(UsernameNotFoundException.class); expectedException.expectMessage(Matchers.containsString(username)); //when accountRepository.findByEmail(username);} ExpectedException을 public으로 주입 받는다. 먼저 발생될 Exception에 대해서 예상한다. (후에 넣으면 안됨 반드시 먼저) 스프링 시큐리티 기본 설정 스프링 시큐리티가 의존성에 들어있다면, 스프링 부트는 모든요청에 스프링 시큐리티용 자동설정을 적용한다. 사용자를 임의로 인메모리로 만들어준다. 계획 시큐리티 필터를 적용하지 않음 /docs/index.html 로그인 없이 접근 가능 GET /api.events GET /api/events/{id} 로그인 접근 나머지 다.. 스프링 시큐리티 OAuth2.0 사용 스프링 시큐리티 설정 @EnableWebSecurity + extends WebSecurityCOnfigurerAdapter 1234@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter {} 스프링 부트에서 설정하는 시큐리티 설정을 적용하지 않고 직접 설정한다. 스프링 시큐리티의 기본설정을 상속받는다. PasswordEncoder 1234@Beanpublic PasswordEncoder passwordEncoder() { return PasswordEncoderFactories.createDelegatingPasswordEncoder();} 패스워드 인코더 빈등록 PasswordEncoderFactories.createDelegatingPasswordEncoder(); prefix로 인코딩 방식 기입 및 prefix에 따라 매칭확인 TokenStore 1234@Beanpublic TokenStore tokenStore() { return new InMemoryTokenStore();} 토큰을 저장하는 곳. (OAuth 토큰을 저장) InMemoryTokenStore AuthenticationManagerBean 12345@Bean@Overridepublic AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean();} AuthenticationManager를 빈으로 노출시켜준다. AuthorizationServer나 ResourceServer에서 참조할 수 있도록 configure(AuthenticationManagerBuidler auth) 1234@Overrideprotected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(accountService).passwordEncoder(passwordEncoder);} AuthenticationManager를 어떻게 만들지 설정 UserDetailsService PasswordEncoder configure(WebSecurty web) 12345@Overridepublic void configure(WebSecurity web) throws Exception { web.ignoring().mvcMatchers(\"/docs/index.html\"); web.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations());} SecurityFilter를 적용할지 말지를 설정 (http로 가기전…) PathRequest.toStaticResources().atCommonLocations() 스프링 부트에서 지원(Servlet, Reactive) 정적 리소스들에 대한 기본위치(favicon, image등..) configure(HttpSecurity http) 1234567@Overrideprotected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .mvcMatchers(\"/docs/index.html\").permitAll() .requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll() ;} SpirngSecurity로 들어와서 Filter는 탄다. 그외 권한에 대한 설정을 준다. “/docs/index.html”, 정적 리소스 요청에 대해 모든접근을 허락하겠다. configure(HttpSecurity http) vs configure(WebSecurty web) web에서 거를 경우, SecurityFilter자체를 타지 않고, http에서 거를 경우 SecurityFIlter는 적용되나 모든권한을 허용하는것이다. 확인하기 위해 logging.level.org.springframework.security=DEBUG 설정 후 확인해 보자. web http 같은 요청에 대하여 http가 더 많은 시큐리티 관련 filterchain 로그가 찍히는 것을 확인 할 수 있었다. 스프링 시큐리티 폼 인증 설정123456789101112@Overrideprotected void configure(HttpSecurity http) throws Exception { http .anonymous() .and() .formLogin() .and() .authorizeRequests() .mvcMatchers(HttpMethod.GET, \"/api/**\").permitAll() .anyRequest().authenticated() ;} 익명 사용자를 허용 폼 로그인 사용 loginpage() 등을 설정 가능하다. get 방식 api에 대해서 익명사용자를 허용한다. permitAll()을 사용하도 인증 필요없이 접근 가능하게 할 수 있다. 나머지 요청(anyRequest)에 관하여는 인증을 요청한다. 스프링 시큐리티 OAuth 2 설정: 인증 서버 설정GrantType Spring OAuth2.0이 인증하는 6가지 인증 방법중 하기 2가지 인증방식을 사용할 것이다. password 최초 oauth 토큰 발급 다른 GrantType과 다르게 홉이 한번(요청과 응답이 한쌍) 인증을 제공하는 서비스 오너가 만든 클라이언트에서만 사용 인증정보를 보유하고 있는… 우리서비스에 가입한 유저에 대한 인증토큰 https://developer.okta.com/blog/2018/06/29/what-is-the-oauth2-password-grant refreshToken AuthorizationServer 설정 @EnableAuthorizationServer AuthorizationServer 설정 extends AuthorizationServerConfigurerAdapter와 함께 사용 configure 메소드들을 오버라이드 한다. configurer security 1234@Overridepublic void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security.passwordEncoder(passwordEncoder);} password encoder 설정 clients 1234567891011@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(\"myApp\") .authorizedGrantTypes(\"password\", \"refresh_token\") .scopes(\"read\", \"write\") .secret(passwordEncoder.encode(\"pass\")) .accessTokenValiditySeconds(10 * 60) .refreshTokenValiditySeconds(6 * 10 * 60) ;} clients 관련 내용 설정 id password grant_type scope accessTokenValiditySeconds(액세스 토큰 유지 시간) refreshTokenValiditySeconds(리프레시 토큰 유지 시간) endpoints 123456@Overridepublic void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authenticationManager(authenticationManager) .userDetailsService(accountService) .tokenStore(tokenStore);} AuthentiacationManager 설정 UserDetailsService설정 TokenStored설정 응답결과 리소스 서버 설정 리소스 서버는 이벤트 리소스를 제공하는 서버와 같이 있는게 맞다. 인증서버는 분리하는게 맞으나, 작은서비스는 같이 있어도 무방하다. 설정 @EnableResourceServer + extends ResourceServerConfigurerAdapter configure(ResourceServerSecurityConfigurer resources) 1234@Overridepublic void configure(ResourceServerSecurityConfigurer resources) throws Exception { resources.resourceId(\"event\");} configure(HttpSecurity http) 1234567891011121314@Overridepublic void configure(HttpSecurity http) throws Exception { http .anonymous() .and() .authorizeRequests() .mvcMatchers(HttpMethod.GET, \"/api/**\") .permitAll() .anyRequest() .authenticated() .and() .exceptionHandling() .accessDeniedHandler(new OAuth2AccessDeniedHandler());} anonymous GET /ap/** : permit all POST : authenticated PUT : authenticated 에러처리 accessDeninedHandler(OAuth2AccessDeninedHandler()) 기존엑 작성한 EventControllerTest 테스트 결과 GET을 제외한 나머지 테스트 실패 -&gt; 실패 테스트에 대해서 액세스 토큰을 가지고 요청하도록 테스트 수정 123456789101112131415161718192021222324252627private String getBaererToken() throws Exception { //given Set&lt;AccountRole&gt; accountRoleSet = new HashSet&lt;&gt;(); accountRoleSet.add(ADMIN); accountRoleSet.add(USER); Account account = Account.builder() .email(\"bong@email.com\") .password(\"bong\") .roles(accountRoleSet) .build(); accountService.saveAccount(account); String clientId = \"myApp\"; String clientSecret = \"pass\"; //when &amp;&amp; then ResultActions perform = this.mockMvc.perform(post(\"/oauth/token\") .with(httpBasic(clientId, clientSecret)) .param(\"username\", \"bong@email.com\") .param(\"password\", \"bong\") .param(\"grant_type\", \"password\")); String responseBody = perform.andReturn().getResponse().getContentAsString(); Jackson2JsonParser parser = new Jackson2JsonParser(); String access_token = parser.parseMap(responseBody).get(\"access_token\").toString(); return \"Bearer \" + access_token;} 12345678public void createEvent() { mockMvc.perform(post(\"/api/events\") .header(HttpHeaders.AUTHORIZATION, getBaererToken()) .contentType(MediaType.APPLICATION_JSON_UTF8) .accept(MediaTypes.HAL_JSON) .content(objectMapper.writeValueAsString(event))) .andDo(print());} 단일 테스트는 성공하나 EventControllerTest 전체를 테스트할 때는 실패한다. 같은 유저가 생성되면서 오류 발생 어플리케이션 컨텍스트를 공유하고 인메모리 DB도 공유하고 있다. 매 테스트 마다 DB를 비워준다. 12345@Beforepublic void setUp() { this.eventRepository.deleteAll(); this.accountRepository.deleteAll();} 문자열을 외부 설정으로 빼내기@ConfiguationProperties1234567891011121314151617181920212223@Component@ConfigurationProperties(prefix = \"my-app\")@Getter @Setterpublic class AppProperties { @NotEmpty private String adminUsername; @NotEmpty private String adminPassword; @NotEmpty private String userUsername; @NotEmpty private String userPassword; @NotEmpty private String clientId; @NotEmpty private String clientSecret;} 문자열을 외부설정에서 적용가능하도록 해준다. spring-boot-configuration-processor 의존성 추가 필요 (인텔리제이의 경우 레퍼런스 문서를 참조하는 알림이 발생한다.) 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 필드값 적용 시, properties파일에서 자동완성이 가능하다. 이벤트 API 점검이벤트 목록 조회 /api/events 인증없이 GET요청 인증 -&gt; access token 인증 후, GET요청 모두 정상 작동 이벤트 생성 /api/events 이벤트 조회 /api/events/{id} 로그인 했을 때 링크 부족 이벤트 Manager인 경우 수정 링크를 제공하고 싶다.. 뒤에서 알아보자. 현재 사용자 조회SecurityContext 자바 ThreadLocal 기반 구현으로 인증 정보를 담고 있다. 인증정보 꺼내기 12Authentication authentication = SecurityContextHolder.getContext().getAuthentication();Object principal = authentication.getPrincipal(); 여기서 pricipal 객체는 UserDetailsService에서 리턴한 SpringSecurity.User이다. @AuthenticationPricinpal 인증안한 경우에는 null 인증 한 경우에는 username, authorities 참조가능 spring.security.User를 파라미터로 받을 수 있다. 1234567891011@GetMappingpublic ResponseEntity queryEvents(Pageable pageable, PagedResourcesAssembler&lt;Event&gt; assembler, @AuthenticationPrincipal User currentUser) { Page&lt;Event&gt; page = eventRepository.findAll(pageable); PagedResources&lt;Resource&lt;Event&gt;&gt; pagedResources = assembler.toResource(page, e -&gt; new EventResource(e)); pagedResources.add(new Link(\"/docs/index.html#resources-events-list\").withRel(\"profile\")); if (currentUser != null) { pagedResources.add(linkTo(EventController.class).withRel(\"create-events\")); } return ResponseEntity.ok(pagedResources);} spring.security.User를 상속받는 클래스를 구현하면 도메인 User를 얻을 수 있다. 1234567891011121314@Getterpublic class AccountAdapter extends User { private Account account; public AccountAdapter(Account account) { super(account.getEmail(), account.getPassword(), authorities(account.getRoles())); this.account = account; } private static Collection&lt;? extends GrantedAuthority&gt; authorities(Set&lt;AccountRole&gt; roles) { return roles.stream().map(r -&gt; new SimpleGrantedAuthority(\"ROLE_\" + r.name())).collect(Collectors.toSet()); }} SpEL을 사용하면 도메인 User를 파라미터로 받을 수 있다. 위와 같은 작업을 annotation을 생성하여 코드를 줄일 수 있다. 12345@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)@AuthenticationPrincipal(expression = \"account\")public @interface CurrentUser {} @Target : 파라미터에 사용하겠다. @Retention : 런타임까지 유지 시키겠다. 인증을 안하고 접근하면…. ‘anonymousUser’라는 문자열로 principal을 리턴한다. expression이 제대로 동작할 수 없다. SpEL을 잘 활용하면 이러한 문제를 피할 수 있다. 12345@Target(ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)@AuthenticationPrincipal(expression = \"#this == 'anonymousUser' ? null : account\")public @interface CurrentUser {} 현재 인증 정보가 ‘anonymousUser’라는 문자열이면 null을 리턴하고 아니면 account를 리턴하라. Event API 개선 : 출력값 제한하기문제점 Event create 응답결과 매니저에 대한 과도한 정보를 가지고 있음 -&gt; id값만을 응답하고 싶다. 해결 JsonSerializer 사용 ErrorSerializer에서 사용했던 JsonSerializer 사용(com.fasterxml.jackson.databind.JsonSerializer) 12345678public class AccountSerializer extends JsonSerializer&lt;Account&gt; { @Override public void serialize(Account account, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { jsonGenerator.writeStartObject(); jsonGenerator.writeNumberField(\"id\", account.getId()); jsonGenerator.writeEndObject(); }} 그러나, @JsonComponent로 등록 시, 모든 Account에 대한 응답이 id값만 응답한다.-&gt; @JsonComponent를 사용하여 등록하지 않는다. 사용을 원하는곳에서만 @JsonSerialize를 사용하여 해결한다. 응답결과 VO or DTO등을 사용하여 Response를 만든다.","link":"/2019/09/23/RestAPI/restapi05/"}],"tags":[{"name":"Etc","slug":"Etc","link":"/tags/Etc/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Seminar","slug":"Seminar","link":"/tags/Seminar/"},{"name":"JPA","slug":"JPA","link":"/tags/JPA/"},{"name":"JSP","slug":"JSP","link":"/tags/JSP/"},{"name":"Interview","slug":"Interview","link":"/tags/Interview/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Process","slug":"Process","link":"/tags/Process/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"DataBase","slug":"DataBase","link":"/tags/DataBase/"},{"name":"OracleDB","slug":"OracleDB","link":"/tags/OracleDB/"},{"name":"프로젝트_회고","slug":"프로젝트-회고","link":"/tags/프로젝트-회고/"},{"name":"RestAPI","slug":"RestAPI","link":"/tags/RestAPI/"},{"name":"SpringSecurity","slug":"SpringSecurity","link":"/tags/SpringSecurity/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"정보처리기사_필기","slug":"정보처리기사-필기","link":"/tags/정보처리기사-필기/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Springframework_kosta","slug":"Springframework-kosta","link":"/tags/Springframework-kosta/"},{"name":"SpringWebMvc","slug":"SpringWebMvc","link":"/tags/SpringWebMvc/"},{"name":"Springframework","slug":"Springframework","link":"/tags/Springframework/"}],"categories":[]}