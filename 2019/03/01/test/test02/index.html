<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="개발공부 정리 블로그">
  <meta name="keyword" content="Java, Spring, SQL, JavaScript">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      정보처리기사 필기 - 3과목(운영체제) | Bong&#39;s blog
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>

</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Bong's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>정보처리기사 필기 - 3과목(운영체제)</h2>
  <p class="post-date">2019-03-01</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="정보처리기사-필기"><a href="#정보처리기사-필기" class="headerlink" title="정보처리기사 -필기"></a>정보처리기사 -필기</h1><h2 id="3과목-운영체제"><a href="#3과목-운영체제" class="headerlink" title="3과목 - 운영체제"></a>3과목 - 운영체제</h2><h3 id="시스템-소프트웨어의-구성"><a href="#시스템-소프트웨어의-구성" class="headerlink" title="시스템 소프트웨어의 구성"></a>시스템 소프트웨어의 구성</h3><ul>
<li><p>제어 프로그램(Control Program) : 시스템 전체의 작동상태 감시,  작업의 순서 지정(스케쥴링), 작업에 사용되는 데이터 관리, 인터럽트 처리 등의 역할을 수행하는 프로그램</p>
<ul>
<li>감시(Supervisor) 프로그램 : 프로그램의 실행과 시스템 전체의 작동상태를 감시, 감독하는 프로그램</li>
<li>작업제어(Job Control) 프로그램 : 어떤업무를 처리하고 다른업무로의 이행을 자동으로 수행하기 위한 준비 및 그 처리에 대한 완료를 담당하는 프로그램</li>
<li>자료관리(Data Management) 프로그램 : 주기억장치와 보조 기억 장치 사이의 데이터 전송과 보조기억장치의 자료 갱신 및 유지 보수 기능을 수행하는 프로그램</li>
</ul>
</li>
<li><p>처리 프로그램 : 제어프로그램의 지시를 받아 사용자가 요구한 문제를 해결하기 위한 프로그램</p>
<ul>
<li>언어 번역 프로그램 : 원시 프로그램을 기계어 형태의 목적 프로그램으로 번역하는 프로그램 (어셈블리, 컴파일러, 인터프리터)</li>
<li>서비스 프로그램 : 컴퓨터를 효율적으로 사용할 수 있는 사용빈도가 높은 프로그램</li>
<li>문제 프로그램 : 특정 업무 및 해결을 위해 사용자가 작성한 프로그램<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="운영체제의-개요"><a href="#운영체제의-개요" class="headerlink" title="운영체제의 개요"></a>운영체제의 개요</h3><h4 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h4><ul>
<li>시스템의 자원을 효율적으로 관리하며, 사용자가 컴퓨터를 효과적으로 사용할 수 있도록 환경을 제공</li>
<li>windows, ms-dos, unix, linux 등이 있다.</li>
</ul>
<h4 id="목적"><a href="#목적" class="headerlink" title="목적"></a>목적</h4><ul>
<li>처리능력, 신뢰도, 사용가능도 향상</li>
<li>반환시간 단축</li>
</ul>
<h4 id="성능평가기준"><a href="#성능평가기준" class="headerlink" title="성능평가기준"></a>성능평가기준</h4><ul>
<li>처리능력(Throughput) : 일정시간동안 처리하는 일의 양</li>
<li>반환시간(Turn Around Time) : 요청부터 처리가 완료될때 까지 걸린시간</li>
<li>사용 가능도(Availability) : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도</li>
<li>신뢰도(Reliability) : 시스템이 주어진 문제를 정확하게 해결하는 정도</li>
</ul>
<h4 id="기능"><a href="#기능" class="headerlink" title="기능"></a>기능</h4><ul>
<li>프로세스 관리<ul>
<li>사용자 및 시스템 프로세스 생성/제거</li>
<li>프로세스 스케쥴링</li>
</ul>
</li>
<li>자원관리</li>
<li>자원의 효과적인 경영 스케쥴링</li>
<li>사용자와 시스템간 편리한 인터페이스 제공</li>
<li>시스템의 각종 하드웨어와 네트워크 관리/제어</li>
<li>오류검사 및 복구, 데이터관리, 데이터 및 자원 공유</li>
<li>자원보호</li>
<li>가상 계산기 기능</li>
<li>병렬 수행을 위한 편의성<br><br><br></li>
</ul>
<h3 id="운영체제-운용-기법-및-발달-과정"><a href="#운영체제-운용-기법-및-발달-과정" class="headerlink" title="운영체제 운용 기법 및 발달 과정"></a>운영체제 운용 기법 및 발달 과정</h3><h4 id="운영체제-운용-기법"><a href="#운영체제-운용-기법" class="headerlink" title="운영체제 운용 기법"></a>운영체제 운용 기법</h4><ul>
<li>일괄처리(Batch Processing) 시스템<ul>
<li>초기의 컴퓨터에서 사용</li>
<li>일정량 또는 일정기간의 데이터를 모아서 한꺼번에 처리</li>
<li>효율적으로 사용할 수 있음</li>
<li>사용자 측면에서 응답시간이 늦지만, 하나의 작업이 모든 자원을 독점하여 CPU 유휴시간 줄어듦</li>
<li>급여계산, 지불계산, 연말 결산 등의 업무에 사용됨.</li>
</ul>
</li>
<li>다중 프로그래밍(Multi Programming)시스템<ul>
<li>하나의 CPU와 주기억장치를 이용하여 여러개의 프로그램을 동시에 처리하는 방식</li>
<li>하나의 주기억장치에 2개이상의 프로그램을 기억시켜놓고, 하나의 CPU와 대화하면서 동시처리</li>
</ul>
</li>
<li>시분할(Time Sharing) 시스템<ul>
<li>여러명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리해줌</li>
<li>라운드 로빈방식이라고도 함.</li>
<li>하나의 CPU는 같은시점에서 여러개의 작업을 동시에 수행할 수 없기 때문에 CPU의 전체 사용시간을 작은 작업 시간량으로 나누어 그시간량 동안만 번갈아 가면서 cpu를 할당하여 각 작업을 처리</li>
<li>다중 프로그래밍 방식과 결합하여 모든 작업이 동시에 처리되는것처럼 대화식 처리가 가능함.</li>
</ul>
</li>
<li>다중 처리(Multi Processing) 시스템<ul>
<li>여러개의 CPU와 하나의 주기억장치를 이용하여 여러 프로그램을 처리하느 방식</li>
<li>하나의 CPU가 고장나더라도 다른 CPU를 이용하여 업무를 처리할 수 있으므로 시스템의 신뢰성과 안정성이 높음.</li>
</ul>
</li>
<li>실시간 처리(Real Time Processing) 시스템<ul>
<li>데이터 발생 즉시, 또는 데이터 처리 요구 즉시 처리하여 결과를 산출</li>
<li>시간에 제한을 두고 수행되어야 하는 작업에 사용됨</li>
</ul>
</li>
<li>다중 모드 처리(Multi Mode Processing) : 일괄 처리 시스템, 시분할 시스템, 다중 처리 시스템, 실시간 처리 시스템을 한 시스템에서 모두 제공하는 방식</li>
<li>분산 처리 (Distributed Processing)<ul>
<li>여러개의 컴퓨터를 통신 회선으로 연결하여 하나의 작업을 처리하는 방식</li>
<li>각 단말장치 및 컴퓨터 시스템은 고유의 운영체제 및 CPU, 메모리를 가지고 있음</li>
</ul>
</li>
</ul>
<h4 id="운영체제-발달-과정"><a href="#운영체제-발달-과정" class="headerlink" title="운영체제 발달 과정"></a>운영체제 발달 과정</h4><p>일괄 처리 시스템 -&gt; 다중 프로그래밍, 다중 처리, 시분할, 실시간 처리 시스템 -&gt; 다중 모드 -&gt; 분산 처리 시스템<br><br><br></p>
<h3 id="매크로와-매크로-프로세서"><a href="#매크로와-매크로-프로세서" class="headerlink" title="매크로와 매크로 프로세서"></a>매크로와 매크로 프로세서</h3><ul>
<li>매크로 : 동일한 코드를 한번만 작성하여, 정의된 이름을 호출하여 사용하는 것</li>
<li>매크로 프로세서 : 원시 프로그램에 존재하는 매크로 호출 부분에 매크로 프로그램을 삽입하여 확장 된 원시 프로그램을 생성하는 시스템 소프트웨어</li>
</ul>
<h3 id="링커-로더"><a href="#링커-로더" class="headerlink" title="링커/로더"></a>링커/로더</h3><h4 id="링커"><a href="#링커" class="headerlink" title="링커"></a>링커</h4><ul>
<li>언어 번역 프로그램이 생성한 목적 프로그램들과 라이브러리, 또 다른 실행프로그램 등을 연결하여 실행 가능한 로드 모듈을 만드는 시스템소프트웨어</li>
<li>연결 기능만 수행하는 로더의 한 형태로 링커에 의해 수행되는 작업을 링킹이라고 한다.</li>
</ul>
<h4 id="로더"><a href="#로더" class="headerlink" title="로더"></a>로더</h4><h5 id="정의-1"><a href="#정의-1" class="headerlink" title="정의"></a>정의</h5><ul>
<li>컴퓨터 내부로 정보를 들여오거나, 로드모듈을 디스크 등의 보조 기억장치로부터 주기억장치에 적재하는 시스템 소프트웨어</li>
</ul>
<h5 id="기능-1"><a href="#기능-1" class="headerlink" title="기능"></a>기능</h5><ul>
<li>할당(Allocation) : 기억장치 내에 옮겨놓을 공간을 확보</li>
<li>연결(Linking) : 부프로그램 호출 시, 할당된 기억장소의 시작주소를 호출한 부분에 연결</li>
<li>재배치(Relocation) : 보조기억장치에 저장된 프로그램이 사용하는 각 주소들을 할당된 기억장소의 실제 주소로 배치시키는 기능</li>
<li>적재(Loading) : 실행 프로그램을 할당된 기억공간에 실제 옮기는 기능</li>
</ul>
<h5 id="종류"><a href="#종류" class="headerlink" title="종류"></a>종류</h5><ul>
<li>Compile And Go Loader : 별도의 로더 없이 언어 번역프로그램이 로더의 기능까지 수행</li>
<li>절대로더(Absolute Loader) <ul>
<li>목적 프로그램을 기억장소에 적재시키는 기능만 수행</li>
<li>가장 간단한 로더</li>
<li>기억장소 할당 및 연결을 프로그래머가 직접 지정</li>
<li>한번 지정한 주 기억장치의 장소를 변경하기 어려움</li>
</ul>
</li>
<li>직접 연결 로더(Direct Linking Loader) : 일반적인 기능의 로더로, 로더의 기능 4가지를 모두 수행하는 로더</li>
<li>동적 적재 로더(Dynamic Loading Loader) : 프로그램을 한꺼번에 적재하는것이 아니라, 필요한 일부분만을 적재하는 로더<br><br><br></li>
</ul>
<h3 id="프로세스"><a href="#프로세스" class="headerlink" title="프로세스"></a>프로세스</h3><p>일반적으로 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램을 의미한는것으로 프로세스는 필요한 각종 자원을 요구한다.</p>
<h4 id="정의-2"><a href="#정의-2" class="headerlink" title="정의"></a>정의</h4><ul>
<li>실행중인 프로그램, PCB를 가진 프로그램, 실 기억장치에 저장된 프로그램</li>
<li>프로세서가 할당되는 실체, 프로시저 활동중인것</li>
<li>비동기적 행위를 이으키는 주체, 지정된 결과를 얻기 위한 일련의 계통적 동작</li>
<li>목적 또는 결과에 따라 발생하는 사건들의 과정</li>
<li>프로세서가 할당하는 개체로서 디스패치가 가능한 단위<br><br><br></li>
</ul>
<h3 id="국부성-Locality-구역성"><a href="#국부성-Locality-구역성" class="headerlink" title="국부성(Locality, 구역성)"></a>국부성(Locality, 구역성)</h3><ul>
<li>실행중인 프로세스가 주기억장치를 참조할 때는 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론으로 Denning에 의해 증명됨.</li>
<li>스래싱을 방지하기 위한 워킹 셋 이론의 기반이 된다.</li>
<li>캐시 메모리 시스템의 이론적 근거이다.</li>
<li>프로세스가 집중적으로 사용되는 페이지를 알아내느 방법 중 하나로, 가상 기억장치 관리의 이론적인 근거가 된다.</li>
</ul>
<h4 id="종류-1"><a href="#종류-1" class="headerlink" title="종류"></a>종류</h4><ul>
<li>시간 구역성(Temporal Locality)<ul>
<li>프로세스가 실행되면서 하나의 페이지를 일정 시간동안 집중적으로 액세스하는 현상</li>
<li>한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음을 의미함</li>
<li>시간 구역성이 이루어지는 기억장소 : Loop, 스택, 부프로그램, couning, totaling</li>
</ul>
</li>
<li>공간 구역성(Spatial Locality)<ul>
<li>프로세스 실행 시, 일정 위치의 페이지를 집중적으로 액세스하는 현상</li>
<li>공간 구역성이 이루어지는 기억장소 : 배열순회, 순차적 코드의 실행, 프로그래머들이 관련된 변수들<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="디렉토리의-구조"><a href="#디렉토리의-구조" class="headerlink" title="디렉토리의 구조"></a>디렉토리의 구조</h3><ul>
<li>1단계 디렉토리<ul>
<li>가장 간단하고, 모든파일이 하나의 디렉토리 내에 위치하여 관리되는 구조</li>
<li>모든 파일들이 유일한 이름을 가지고 있어야 함.</li>
</ul>
</li>
<li>2단계 디렉토리<ul>
<li>중앙에 마스터 디렉토리(MFD)가 있고, 그 아래에 사용자별로 서로 다른 파일 디렉토리(UFD)가 있는 2 계층 구조</li>
</ul>
</li>
<li>트리 디렉토리<ul>
<li>하나의 루트 디렉토리, 여러개의 종속(서브) 디렉토리로 구성된 구조</li>
<li>DOS, windows, UNIX 등의 운영체제에서 사용되는 디렉토리 구조</li>
<li>디렉토리 생성, 파괴가 비교적 용이</li>
<li>포인터를 사용하여 디렉토리를 탐색</li>
<li>경로명은 절대경로와 상대경로명을 사용</li>
</ul>
</li>
<li>비순환 그래프 디렉토리<ul>
<li>하위 파일이나 하위 디렉토리를 공동으로 사용할 수 있는것으로 사이클이 허용되지 않는 구조</li>
<li>하나의 파일이나 디렉토리가 여러개의 경로 이름을 가질 수 있음</li>
<li>공유 된 파일을 삭제할 경우 고아 포인터(Dangling Pointer) 발생</li>
</ul>
</li>
<li>일반적인 그래프 디렉토리<ul>
<li>트리 구조에 링크(Link)를 첨가시켜 순환을 허용</li>
<li>디렉토리와 파일 공유에 완전한 융통성이 있음</li>
<li>불필요한 파일을 제거하여 사용 공간을 늘리기 위하여 참조 계수기가 필요함.<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="하이퍼-큐브"><a href="#하이퍼-큐브" class="headerlink" title="하이퍼 큐브"></a>하이퍼 큐브</h3><ul>
<li>하나의 프로세서에 연결되는 다른 프로세서의 수(연결점)가 n개일 경우 프로세서는 총 2의 n제곱승 개가 필요하다.<br><br><br></li>
</ul>
<h3 id="HRN-기법"><a href="#HRN-기법" class="headerlink" title="HRN 기법"></a>HRN 기법</h3><p>우선순위 공식 : (대기시간 + 서비스 시간)/ 서비스 시간<br>계산 된 숫자가 클수록 우선순위가 높다.<br><br><br></p>
<h3 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h3><h4 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h4><ul>
<li>시분할 시스템을 위해 설계된 대화식 운영체제</li>
<li>소스가 공개된 개방형 시스템이다.</li>
<li>대부분 C언어로 작성되어 있어 이식성이 높음, 장치 프로세스간 호환성 높음</li>
<li>크기가 작고 이해하기 쉬움</li>
<li>Multi-User, Multi-Tasking을 지원한다.</li>
<li>많은 네트워킹 기능을 제공하므로 통신망(Network)관리용 운영체제로 적합하다.</li>
<li>트리 구조의 파일 시스템</li>
<li>백그라운드에서 작업을 수행할 수 있으므로 여러개의 작업 병행 처리할 수 있다.</li>
<li>정보와 유틸리티들을 공유하여 편리하게 작업을 수행할 수 있다.</li>
</ul>
<h4 id="UNIX-시스템의-구성"><a href="#UNIX-시스템의-구성" class="headerlink" title="UNIX 시스템의 구성"></a>UNIX 시스템의 구성</h4><ul>
<li>커널(Kernel)<ul>
<li>UNIX의 가장 핵심</li>
<li>하드웨어를 보호(캡슐화)하고, 프로그램들과 하드웨어간 인터페이스를 담당</li>
<li>프로세스관리, 기억장치 관리, 파일관리등 여러가지 기능 수행</li>
<li>컴퓨터 부팅 시, 주기억장치에 적재되어 상주하면서 실행됨</li>
</ul>
</li>
<li>쉘(Shell)<ul>
<li>사용자의 명령어를 인식, 프로그램 호출하는 명령어 해석기</li>
<li>시스템과 사용자 간의 인터페이스를 담당함</li>
<li>DOS의 COMMAND.COM과 같은 기능을 수행함</li>
<li>주기억장치에 상주하지 않고 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능함</li>
</ul>
</li>
<li>유틸리티(Utility)<ul>
<li>일반 사용자가 작성한 응용 프로그램을 처리하는데 사용함</li>
<li>DOS에서 외부 명령어에 해당함</li>
</ul>
</li>
</ul>
<h4 id="명령어"><a href="#명령어" class="headerlink" title="명령어"></a>명령어</h4><ul>
<li>파일내용을 화면에 표시 : cat</li>
<li>파일의 소유자를 변경 : chown</li>
<li>새로운 프로세스를 생성 : fork<br><br><br></li>
</ul>
<h3 id="기억장치-관리-전략"><a href="#기억장치-관리-전략" class="headerlink" title="기억장치 관리 전략"></a>기억장치 관리 전략</h3><h4 id="반입전략-Fetch"><a href="#반입전략-Fetch" class="headerlink" title="반입전략(Fetch)"></a>반입전략(Fetch)</h4><p>반입 : 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할것인지 결정하는 전략</p>
<ul>
<li>요구 반입 : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할때 적재</li>
<li>예상 반입 : 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재</li>
</ul>
<h4 id="배치전략-Placement"><a href="#배치전략-Placement" class="headerlink" title="배치전략(Placement)"></a>배치전략(Placement)</h4><p>배치 : 주기억장치 어디에 위치시킬 것인지를 경정하는 전략</p>
<ul>
<li>최초적합(First Fit) : 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법</li>
<li>최적적합(Best Fit) : 빈 영역 중에서 단편화를 가장 작게 남기는 분할영역에 배치시키는 방법</li>
<li>최악적합(Worst Fit) : 빈 영역 중에서 단편화를 가장 크게 남기는 분할영역에 배치시키는 방법</li>
</ul>
<h4 id="교체전략"><a href="#교체전략" class="headerlink" title="교체전략"></a>교체전략</h4><p>교체(Replacement) 전략 : 주 기억장치의 모든 영역이 이미 사용중인 상태에서 기억장치의 필요한 페이지를 주기억장치에 배치하려고 할 때, 이미 사용되고있는 영역중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략으로 FIFO, OPT, LRU, LFU, NUR, SCR등이 있음<br><br><br></p>
<h3 id="스레싱-Thrashing"><a href="#스레싱-Thrashing" class="headerlink" title="스레싱(Thrashing)"></a>스레싱(Thrashing)</h3><p>하나의 프로세스가 작업수행과정에서 수행하는 기억장치 접근에서 지나치게 페이지 폴트가 발생하여 프로세스 수행에 소요되는 시간보다 페이지 이동에 소요되는 시간이 더커지는 현상<br><br><br></p>
<h3 id="워킹셋-Working-set"><a href="#워킹셋-Working-set" class="headerlink" title="워킹셋(Working set)"></a>워킹셋(Working set)</h3><ul>
<li>프로세스가 일정시간 동안 자주 참조하는 페이지들의 집합</li>
<li>데닝(Denning)이 제안한 구역성(Locality)특징을 이용한다.</li>
<li>자주 참조되는 워킹 셋을 주기억장치에 상주시켜, 페이지의 부재 및 교체를 줄인다.</li>
<li>워킹셋은 시간에 따라 변경된다.</li>
</ul>
<h4 id="페이지부재"><a href="#페이지부재" class="headerlink" title="페이지부재"></a>페이지부재</h4><ul>
<li>페이지 부재 : 참조할 페이지가 주기억장치에 없는 현상</li>
<li>페이지 부재 빈도 : 페이지 부재 현상 횟수</li>
<li>페이지 부재 빈도 방식 : 페이지 부재율에 따라 주기억장치에 있느 프레임의 수를 조절하여 부재율을 적정 수준으로 유지하는 방식<br><br><br></li>
</ul>
<h3 id="세마포어-Semaphore"><a href="#세마포어-Semaphore" class="headerlink" title="세마포어(Semaphore)"></a>세마포어(Semaphore)</h3><p>‘신호기’, ‘깃발’을 뜻하며, 각 프로세스에 제어 신호를 전달하여 순서대로 작업을 수행하도록 하는 기법<br><br><br></p>
<h3 id="교혼-Swapping"><a href="#교혼-Swapping" class="headerlink" title="교혼(Swapping)"></a>교혼(Swapping)</h3><p>하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법<br><br><br></p>
<h3 id="파일-디스크립터-File-Descriptor"><a href="#파일-디스크립터-File-Descriptor" class="headerlink" title="파일 디스크립터(File Descriptor)"></a>파일 디스크립터(File Descriptor)</h3><ul>
<li>파일을 관리하기 위해 시스템이 필요로 하는 파일에 대한 정보를 갖고 있는 제어 블록(파일 제어 블록, FCB)</li>
<li>보통 파일 디스크립터는 보조기억장치 내에 저장되어 있다가 해당파일이 Open될때 주기억장치로 옮겨진다.</li>
<li>파일마다 독립적으로 존재, 시스템에 따라 다른 구조를 가질 수 있다.</li>
<li>파일 시스템이 관리하므로 사용자가 직접 참조할 수 없다.</li>
<li>파일 디스크립터 정보<ul>
<li>파일 ID, 이름, 크기, 구조, 유형</li>
<li>보조기억장치 위치, 유형</li>
<li>액세스 제어정보, 횟수</li>
<li>생성 시간, 제거 시간, 최종 수정 시간,<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="직접-파일-Direct-File-직접-접근방식"><a href="#직접-파일-Direct-File-직접-접근방식" class="headerlink" title="직접 파일(Direct File), 직접 접근방식"></a>직접 파일(Direct File), 직접 접근방식</h3><ul>
<li>파일을 구성하는 레코드를 임의의 물리적 저장공간에 기록하는 것<h4 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h4></li>
<li>파일의 각 레코드에 직접 접근 및 기록 가능</li>
<li>접근시간 빠름</li>
<li>레코드 삽입, 삭제, 갱신이 용이함</li>
</ul>
<h4 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h4><ul>
<li>레코드의 주소 변환 과정이 필요하며, 이 과정으로 인해 시간 소요</li>
<li>기억공간의 효율 저하</li>
<li>기억장치의 물리적 구조에 대한 지식이 필요<br><br><br></li>
</ul>
<h4 id="다중-처리기의-운영체제-구조"><a href="#다중-처리기의-운영체제-구조" class="headerlink" title="다중 처리기의 운영체제 구조"></a>다중 처리기의 운영체제 구조</h4><ul>
<li>주/종 처리기<ul>
<li>하나의 프로세서를 Master로 지정하고, 나머지들을 Slave로 지정하는 비대칭 구조</li>
<li>주 프로세서가 고장나면 전체 시스템 다운</li>
<li>주 프로세서 : 입출력, 연산 담당 ,운영체제 수행</li>
<li>종 프로세서 : 연산만 담당</li>
</ul>
</li>
<li>분리 실행 처리기<ul>
<li>주/종 처리기의 비대칭성을 보완하여 각 프로세서가 독자적인 운영체제를 가지고 있도록 구성한 구조</li>
<li>각 프로세서 발생 인터럽트 해당 프로세서 해결</li>
<li>한 프로세서가 고장나더라도 전체 시스템 다운되지 않음</li>
</ul>
</li>
<li>대칭적 처리기<ul>
<li>여러 프로세서들이 완전한 기능을 갖춘 하나의 운영체제를 공유하여 수행하는 구조</li>
<li>가장 복잡한 구조를 가지고 있으나 가장 강력한 시스템</li>
<li>여러개의 프로세스가 동시에 수행가능하며, 시스템 전반적인 정보를 통일적이고 일관성있게 운영</li>
<li>프로세서의 수를 늘린다고 해도 시스템 효율은 향상되지 않음</li>
<li>프로세서 간의 통신은 공유 메모리를 통해 이루어짐<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="가상-기억장치-Virtual-Memory"><a href="#가상-기억장치-Virtual-Memory" class="headerlink" title="가상 기억장치(Virtual Memory)"></a>가상 기억장치(Virtual Memory)</h3><h4 id="구현기법"><a href="#구현기법" class="headerlink" title="구현기법"></a>구현기법</h4><ul>
<li>페이징 기법<ul>
<li>가상 기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 주기억장치 영역에 적재시켜 실행</li>
<li>외부단편화는 발생하지 않으나, 내부 단편화는 발생할 수 있음</li>
<li>페이지 맵 테이블이 필요함</li>
</ul>
</li>
<li>세그먼테이션 기법<ul>
<li>가상 기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후, 주기억장치에 적재시켜 실행</li>
<li>논리적인 크기로 나눈 단위를 세그먼트라고 부른다.</li>
<li>각 세그먼트는 고유한 이름과 크기를 가지며, 다른세그먼트에 할당된 영역을 침범할 수 없다. 이를위해 기억장치 보호키가 필요하다.</li>
<li>내부 단편화는 발생하지 않으나, 외부 단편화는 발생할 수 있다.</li>
<li>세그먼트 맵 테이블이 필요함<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="PCB-Process-Control-Block"><a href="#PCB-Process-Control-Block" class="headerlink" title="PCB(Process Control Block)"></a>PCB(Process Control Block)</h3><ul>
<li>운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳</li>
<li>프로세스가 생성될 때마다 고유의 PCB가 생성, 프로세스가 완료되면 PCB가 제거됨</li>
<li>PCB에 저장되어 있는 정보<ul>
<li>프로세스의 현재상태, 고유식별자, 우선순위, 스케줄링</li>
<li>포인터</li>
<li>CPU 레지스터 정보</li>
<li>주기억장치 관리정보, 입출력상태정보, 계정정보<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="디스크-스케줄링"><a href="#디스크-스케줄링" class="headerlink" title="디스크 스케줄링"></a>디스크 스케줄링</h3><ul>
<li>사용할 데이터가 디스크상의 여러 곳에 저장되어있는 경우, 데이터를 액세스하기위해 디스크 헤드가 움직이는 경로를 결정하는 기법</li>
</ul>
<h4 id="목적-1"><a href="#목적-1" class="headerlink" title="목적"></a>목적</h4><ul>
<li>처리량 최대화</li>
<li>평균응답시간 최소화</li>
<li>응답시간 편차 최소화</li>
</ul>
<h4 id="종류-2"><a href="#종류-2" class="headerlink" title="종류"></a>종류</h4><ul>
<li>FCFS(First Come First Service)<ul>
<li>가장 간단한 스케줄링</li>
<li>디스크 대기 큐에 가장먼저 들어온 트랙에 대한 요청을 먼저 서비스</li>
<li>공평성이 보장</li>
</ul>
</li>
<li>SSTF(Shortest Seek Time First)<ul>
<li>탐색거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스</li>
<li>현재 헤드위치에서 가장 가까운 거이에 있는 트랙으로 헤드를 이동</li>
<li>FCFS보다 처리량이 많고, 평균탐색시간 짧음</li>
<li>탐색패턴이 편중되어 안쪽 및 바깥쪽 트랙이 가운데보다 서비스를 덜받음, 기아상태 발생할 수 있음</li>
<li>처리량이 많은 일괄 처리 시스템에 유용함</li>
</ul>
</li>
<li>SCAN<ul>
<li>SSTF의 탐색편차를 해소</li>
<li>현재 헤드위치에서 진행방향 결정하여 탐색 걱리가 짧은 순서에 따라 요청을 서비스, 끝까지 이동후 역방향 요청 서비스 진행</li>
</ul>
</li>
<li>C-SCAN(Circular SCAN)<ul>
<li>항상 바깥쪽에서 안쪽으로 움직이면서 가장 짧은 탐색거리를 갖은 요청을 서비스하는 기법</li>
<li>끝까지 이동후 바깥쪽 끝으로 이동 후 다시 요청을 서비스함</li>
</ul>
</li>
<li>N-Step SCAN<ul>
<li>SCAN의 무한대기 가능성을 제거한 것</li>
<li>시작당시 요청에 대해서만 서비스하고, 진행도중 도착한 요청은 반대방향 진행시 서비스</li>
</ul>
</li>
<li>에션바흐(Eschenbach)<ul>
<li>부하가 매우 큰 항공 예약 시스템을 위해 개발</li>
<li>탐색시간과 회전 지연 시간을 최적화</li>
<li>헤드는 C-SCAN처럼 움직이며, 모든 실린더는 요청의 유무에 곤계없이 전체트랙이 한바퀴 회전할 동안 서비스를 받음</li>
</ul>
</li>
<li>SLTF(Shortest Latency Time First)<ul>
<li>섹터큐잉(Sector Queing)이라고 하며, 회전 시간의 최적화<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="분산운영체제-구조"><a href="#분산운영체제-구조" class="headerlink" title="분산운영체제 구조"></a>분산운영체제 구조</h3><ul>
<li>성형 연결구조(STAR)<ul>
<li>모든 사이트는 하나의 호스트에 직접연결</li>
<li>중앙 컴퓨터 장애 시 모든 사이트 간 통신불가</li>
<li>통신 비 최대 두개의 링크만 필요(통신비 저렴)<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="파일보호기법"><a href="#파일보호기법" class="headerlink" title="파일보호기법"></a>파일보호기법</h3><h4 id="종류-3"><a href="#종류-3" class="headerlink" title="종류"></a>종류</h4><ul>
<li>파일의 명명(Naming) : 파일이름을 모르는 사용자를 접근대상에서 제외시킴</li>
<li>비밀번호(password) : 각 파일에 판독 암호와 기록 암호를 부여하여 암호를 아는 사용자에게만 접근허용</li>
<li>접근제어(Access Control) : 사용자에 따라 공유 데이터에 접근할 수 있는 권한을 제한</li>
</ul>
<h4 id="보안유지기법"><a href="#보안유지기법" class="headerlink" title="보안유지기법"></a>보안유지기법</h4><ul>
<li>외부보안<ul>
<li>시설보안 : 천재지변이나 외부 침입자로부터의 보안</li>
<li>운용보안 : 전산소 관리 및 경영자들의 정책과 통제에 의해 이루어지는 보안</li>
</ul>
</li>
<li>사용자 인터페이스 보안<ul>
<li>운영체제가 사용자의 신원을 확인 후 권한이 있는 사용자에게만 시스템의 프로그램과 데이터를 사용할 수 있게 하는 보안기법</li>
</ul>
</li>
<li>내부보안<ul>
<li>하드웨어나 운영체제의 내장된 보안 기능을 이용하여 시스템의 신뢰성을 유지하고 보안문제를 해결하는 기법<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="자원보호기법"><a href="#자원보호기법" class="headerlink" title="자원보호기법"></a>자원보호기법</h3><p>객체(자원)에 불법적으로 접근하는 것을 제어하고 객체(자원)에 물리적인 손상을 예방하는 것</p>
<h4 id="종류-4"><a href="#종류-4" class="headerlink" title="종류"></a>종류</h4><ul>
<li>접근 제어 행렬(Acess Control Matrix)<ul>
<li>자원 보호의 일반적인 모델</li>
<li>객체에 대한 접근권한을 행렬로써 표시한 기법</li>
</ul>
</li>
<li>전역 테이블(Global Table)<ul>
<li>가장 단순한 구현방법</li>
<li>3개의 순서쌍인 영역, 객체, 접근권한의 집합을 목록형태로 구성한 기법</li>
</ul>
</li>
<li>접근 제어 리스트(Acess Control List)<ul>
<li>접근 제어 행렬의 열 즉, 객체를 중심으로 리스트를 구성한 기법</li>
</ul>
</li>
<li>권한(자격) 리스트(Capability List)<ul>
<li>접근 제어 행렬의 행 즉, 영역을 중심으로 리스트를 구성한 기법</li>
<li>사용자에 대한 자격들로 구성된다.</li>
<li>자격은 객체와 그 객체에 호용된 연산 리스트임<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="프로세서의-결합도"><a href="#프로세서의-결합도" class="headerlink" title="프로세서의 결합도"></a>프로세서의 결합도</h3><ul>
<li><p>약결합(Loosely Coupled) 시스템</p>
<ul>
<li>각 프로세스마다 독립된 메로리를 가진 시스템 -&gt; 분산 처리 시스템</li>
<li>둘 이상의 독립된 컴퓨터 시스템을 통신망을 통하여 연결한 시스템</li>
<li>각 시스템 독립적인 운영체제</li>
<li>각 시스템은 독립적으로 작동하며, 필요한 경우 상호 통신 가능</li>
<li>프로세서 간 통신은 메세지전달 및 원격 프로시저 호출을 통해서 이루어진다.</li>
<li>CPU간 결합력이 약함</li>
</ul>
</li>
<li><p>강결합(Tightly Coupled) 시스템</p>
<ul>
<li>동일한 운영체제 하에 여러개의 프로세서가 하나의 메모리를 공유하는 시스템 -&gt; 다중 처리 시스템</li>
<li>하나의 운영체제가 모든 프로세서 및 시스템 하드웨어를 제어함</li>
<li>프로세서간 통신은 공유 메모리를 통해 이루어진다.</li>
<li>공유 메모리를 차지하려는 프로세서간 경쟁을 최소화해야한다.</li>
<li>CPU간 결합력이 강합<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="페이지의-크기"><a href="#페이지의-크기" class="headerlink" title="페이지의 크기"></a>페이지의 크기</h3><ul>
<li>작을경우<ul>
<li>페이지 단편화가 감소</li>
<li>한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다.</li>
<li>기억장치 효율이 높아짐</li>
<li>맵 테이블의 크기가 커지고, 매핑속도가 늦어짐</li>
<li>디스크 접근 횟수가 많아져서 전체적인 입출력 시간 증가</li>
<li>필요한 내용만 적재될 확률이 높기 때문에 더 효율적인 워킹 셋을 유지할 수 있다.</li>
</ul>
</li>
<li>큰 경우<ul>
<li>페이지 단편화 증가</li>
<li>한개의 페이지를 주기억장치로 이동하는 시간이 늘어난다.</li>
<li>디스크 접근횟수가 줄어들어 입출력 효율성이 증가한다.</li>
<li>프로그램에 불필요한 내용까지도 주기억장치에 적재될 수 있다.<br><br><br></li>
</ul>
</li>
</ul>
<h3 id="교착상태-해결방법"><a href="#교착상태-해결방법" class="headerlink" title="교착상태 해결방법"></a>교착상태 해결방법</h3><ul>
<li>예방기법 : 교착상태가 발생하지 않도록 사전에 시스템을 제어, 교착 발생 4가지 조건중 한가지를 제거함으로써 자원 낭비가 가장 심함<ul>
<li>상호 배제 부정</li>
<li>점유 및 대기 부정</li>
<li>비선점 부정</li>
<li>환형 대기 부정</li>
</ul>
</li>
<li>회피 기법 : 교착상태가 발생할 가능성을 배제하지 않고, 교착발생시 적절히 피해나가능 방법<ul>
<li>은행원 알고리즘 : 각 프로세스에게 자원을 할당하여 교착상태가 발생하지 않는다.<br><br><br></li>
</ul>
</li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#정보처리기사_필기" >
    <span class="tag-code">정보처리기사_필기</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/03/01/test/test01/">
        <span class="nav-arrow">← </span>
        
          정보처리기사 필기 - 1과목(데이터베이스)
        
      </a>
    
    
      <a class="nav-right" href="/2019/03/02/test/test03/">
        
          정보처리기사 필기 - 4과목(소프트웨어 공학)
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#정보처리기사-필기"><span class="toc-nav-text">정보처리기사 -필기</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3과목-운영체제"><span class="toc-nav-text">3과목 - 운영체제</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#시스템-소프트웨어의-구성"><span class="toc-nav-text">시스템 소프트웨어의 구성</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#운영체제의-개요"><span class="toc-nav-text">운영체제의 개요</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#정의"><span class="toc-nav-text">정의</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#목적"><span class="toc-nav-text">목적</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#성능평가기준"><span class="toc-nav-text">성능평가기준</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#기능"><span class="toc-nav-text">기능</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#운영체제-운용-기법-및-발달-과정"><span class="toc-nav-text">운영체제 운용 기법 및 발달 과정</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#운영체제-운용-기법"><span class="toc-nav-text">운영체제 운용 기법</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#운영체제-발달-과정"><span class="toc-nav-text">운영체제 발달 과정</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#매크로와-매크로-프로세서"><span class="toc-nav-text">매크로와 매크로 프로세서</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#링커-로더"><span class="toc-nav-text">링커/로더</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#링커"><span class="toc-nav-text">링커</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#로더"><span class="toc-nav-text">로더</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#정의-1"><span class="toc-nav-text">정의</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#기능-1"><span class="toc-nav-text">기능</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#종류"><span class="toc-nav-text">종류</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#프로세스"><span class="toc-nav-text">프로세스</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#정의-2"><span class="toc-nav-text">정의</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#국부성-Locality-구역성"><span class="toc-nav-text">국부성(Locality, 구역성)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#종류-1"><span class="toc-nav-text">종류</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#디렉토리의-구조"><span class="toc-nav-text">디렉토리의 구조</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#하이퍼-큐브"><span class="toc-nav-text">하이퍼 큐브</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#HRN-기법"><span class="toc-nav-text">HRN 기법</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#UNIX"><span class="toc-nav-text">UNIX</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#특징"><span class="toc-nav-text">특징</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#UNIX-시스템의-구성"><span class="toc-nav-text">UNIX 시스템의 구성</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#명령어"><span class="toc-nav-text">명령어</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#기억장치-관리-전략"><span class="toc-nav-text">기억장치 관리 전략</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#반입전략-Fetch"><span class="toc-nav-text">반입전략(Fetch)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#배치전략-Placement"><span class="toc-nav-text">배치전략(Placement)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#교체전략"><span class="toc-nav-text">교체전략</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#스레싱-Thrashing"><span class="toc-nav-text">스레싱(Thrashing)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#워킹셋-Working-set"><span class="toc-nav-text">워킹셋(Working set)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#페이지부재"><span class="toc-nav-text">페이지부재</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#세마포어-Semaphore"><span class="toc-nav-text">세마포어(Semaphore)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#교혼-Swapping"><span class="toc-nav-text">교혼(Swapping)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#파일-디스크립터-File-Descriptor"><span class="toc-nav-text">파일 디스크립터(File Descriptor)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#직접-파일-Direct-File-직접-접근방식"><span class="toc-nav-text">직접 파일(Direct File), 직접 접근방식</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#장점"><span class="toc-nav-text">장점</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#단점"><span class="toc-nav-text">단점</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#다중-처리기의-운영체제-구조"><span class="toc-nav-text">다중 처리기의 운영체제 구조</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#가상-기억장치-Virtual-Memory"><span class="toc-nav-text">가상 기억장치(Virtual Memory)</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#구현기법"><span class="toc-nav-text">구현기법</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#PCB-Process-Control-Block"><span class="toc-nav-text">PCB(Process Control Block)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#디스크-스케줄링"><span class="toc-nav-text">디스크 스케줄링</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#목적-1"><span class="toc-nav-text">목적</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#종류-2"><span class="toc-nav-text">종류</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#분산운영체제-구조"><span class="toc-nav-text">분산운영체제 구조</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#파일보호기법"><span class="toc-nav-text">파일보호기법</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#종류-3"><span class="toc-nav-text">종류</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#보안유지기법"><span class="toc-nav-text">보안유지기법</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#자원보호기법"><span class="toc-nav-text">자원보호기법</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#종류-4"><span class="toc-nav-text">종류</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#프로세서의-결합도"><span class="toc-nav-text">프로세서의 결합도</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#페이지의-크기"><span class="toc-nav-text">페이지의 크기</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#교착상태-해결방법"><span class="toc-nav-text">교착상태 해결방법</span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2019/03/01/test/test02/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2020 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>